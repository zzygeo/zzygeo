<!DOCTYPE html>
<html lang="en">

<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8">
	<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
	
	<!-- title -->
	
	<title>
	
		摄影测量 | 
	 
	立志做个全栈
	</title>
	
	<!-- keywords,description -->
	 

	<!-- favicon -->
	
	<link rel="shortcut icon" href="/favicon.ico">
	


	<!-- search -->
	<script>
		var searchEngine = "https://www.google.com/search?q=";
		if(typeof searchEngine == "undefined" || searchEngine == null || searchEngine == ""){
			searchEngine = "https://www.google.com/search?q=";
		}
		var homeHost = "zzygeo.cn";
		if(typeof homeHost == "undefined" || homeHost == null || homeHost == ""){
			homeHost = window.location.host;
		}
	</script>


	
<link rel="stylesheet" href="/css/main.css">

	
<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css">

	
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.17.1/build/styles/darcula.min.css">

	
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">


	
<script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>

	
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>

	
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.17.1/build/highlight.min.js"></script>

	
<script src="https://cdn.jsdelivr.net/npm/jquery-pjax@2.0.1/jquery.pjax.min.js"></script>

	
<script src="/js/main.js"></script>

	
		
<script src="https://cdn.jsdelivr.net/npm/leancloud-storage/dist/av-min.js"></script>

		
<script src="https://cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js"></script>

	
	
		<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	
<meta name="generator" content="Hexo 5.2.0"><link rel="alternate" href="/atom.xml" title="立志做个全栈" type="application/atom+xml">
</head>

<body>
	<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?3efe99c287df5a1d6f0d02d187e403c1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

<header id="header">
    <a id="title" href="/" class="logo">立志做个全栈</a>

	<ul id="menu">
		<li class="menu-item">
			<a href="/about" class="menu-item-link">ABOUT</a>
		</li>
	

	
		<li class="menu-item">
			<a href="/categories" class="menu-item-link">分类</a>
		</li>
	

		<li class="menu-item">
			<a href="https://github.com/wujun234/uid-generator-spring-boot-starter" class="menu-item-link" target="_blank">
				UidGenerator
			</a>
		</li>
		<li class="menu-item">
			<a href="https://github.com/zzygeo" class="menu-item-link" target="_blank">
				<i class="fa fa-github fa-2x"></i>
			</a>
		</li>
	</ul>
</header>

	
<div id="sidebar">
	<button id="sidebar-toggle" class="toggle" ><i class="fa fa-arrow-right " aria-hidden="true"></i></button>
	
	<div id="site-toc">
		<input id="search-input" class="search-input" type="search" placeholder="按回车全站搜索">
		<div id="tree">
			

			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										C++
									</a>
									
							<ul>
								<li class="file">
									<a href="/2021/05/31/C++/C++%E7%9F%A5%E8%AF%86%E7%82%B9/">
										C++知识点
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2021/06/21/C++/Visual%20Studio%E6%B7%BB%E5%8A%A0%E5%BA%93/">
										Visual Studio添加库
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file active">
									<a href="/2021/06/29/C++/%E6%91%84%E5%BD%B1%E6%B5%8B%E9%87%8F/">
										摄影测量
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										Cesium
									</a>
									
							<ul>
								<li class="file">
									<a href="/2021/06/10/Cesium/Cesiun%E5%AD%A6%E4%B9%A0/">
										Cesiun学习
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										Hexo
									</a>
									
							<ul>
								<li class="file">
									<a href="/2021/01/20/Hexo/github%E8%AE%BE%E7%BD%AE%E8%87%AA%E5%B7%B1%E7%9A%84%E5%9F%9F%E5%90%8D/">
										github设置自己的域名
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/10/02/Hexo/hexo-d-%E5%87%BA%E7%8E%B0%E9%94%99%E8%AF%AF%E7%9A%84%E7%94%A8%E6%88%B7%E5%90%8D%E5%92%8C%E5%AF%86%E7%A0%81%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/">
										hexo-d-出现错误的用户名和密码的解决办法
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/09/24/Hexo/markdown%E8%AF%AD%E6%B3%95/">
										markdown语法
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/10/02/Hexo/%E6%96%B0%E7%94%B5%E8%84%91%E4%B8%8A%E9%83%A8%E7%BD%B2hexo/">
										新电脑上部署hexo
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										Java基础
									</a>
									
							<ul>
								<li class="file">
									<a href="/2021/05/24/Java%E5%9F%BA%E7%A1%80/IDEA%E5%BF%AB%E6%8D%B7%E9%94%AE/">
										IDEA快捷键
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2021/07/13/Java%E5%9F%BA%E7%A1%80/Java%E7%9F%A5%E8%AF%86%E7%82%B9/">
										Java知识点
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2021/07/12/Java%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">
										设计模式
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										PCL
									</a>
									
							<ul>
								<li class="file">
									<a href="/2020/10/04/PCL/PCL-1-11-Visual-Studio-2019-%E9%85%8D%E7%BD%AE/">
										PCL-1-11-Visual-Studio-2019-配置
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/12/27/PCL/pcl-vs-cmake%E7%BC%96%E8%AF%91/">
										pcl-vs-cmake编译
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										Ubuntu
									</a>
									
							<ul>
								<li class="file">
									<a href="/2021/03/14/Ubuntu/Ubuntu%E6%9B%B4%E6%8D%A2%E6%BA%90%E6%95%99%E7%A8%8B/">
										Ubuntu更换源教程
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/10/23/Ubuntu/Unable-to-access-https-gitee-com-%E8%87%AA%E5%B7%B1%E7%9A%84%E9%A1%B9%E7%9B%AE-Could-not-resolve-host-gitee-com%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3/">
										Unable-to-access-https-gitee-com-自己的项目-Could-not-resolve-host-gitee-com问题的解决
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2021/03/14/Ubuntu/dpkg%E8%A2%AB%E4%B8%AD%E6%96%AD%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/">
										dpkg被中断的解决办法
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2021/03/14/Ubuntu/ubuntu%E4%B8%8B%E7%9A%84firefox%E6%97%A0%E6%B3%95%E6%92%AD%E6%94%BE%E8%A7%86%E9%A2%91%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">
										ubuntu下的firefox无法播放视频解决方案
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2021/03/14/Ubuntu/ubuntu%E4%B8%8B%E8%A7%A3%E5%86%B3wps2019%E7%BC%BA%E5%B0%91%E5%AD%97%E4%BD%93%E9%97%AE%E9%A2%98/">
										ubuntu下解决wps2019缺少字体问题
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2021/03/14/Ubuntu/ubuntu%E5%AE%89%E8%A3%85gcc%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB%E6%8A%A5%E9%94%99/">
										ubuntu安装gcc依赖关系报错
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2021/03/14/Ubuntu/ubuntu%E5%AE%89%E8%A3%85vim%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB%E6%8A%A5%E9%94%99/">
										ubuntu安装vim依赖关系报错
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2021/03/14/Ubuntu/ubuntu%E9%85%8D%E7%BD%AEC-C-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/">
										ubuntu配置C-C-开发环境
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2021/03/14/Ubuntu/%E5%AE%89%E8%A3%85snap/">
										安装snap
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										其他
									</a>
									
							<ul>
								<li class="file">
									<a href="/2020/09/26/%E5%85%B6%E4%BB%96/%E6%88%91%E7%9A%84Office%E6%BF%80%E6%B4%BB%E7%A0%81/">
										我的Office激活码
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/10/04/%E5%85%B6%E4%BB%96/%E8%B5%84%E6%BA%90/">
										资源
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										前端
									</a>
									
							<ul>
								<li class="file">
									<a href="/2021/08/25/%E5%89%8D%E7%AB%AF/JS%E7%BB%86%E8%8A%82/">
										JS细节
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2021/08/17/%E5%89%8D%E7%AB%AF/css%E7%BB%86%E8%8A%82/">
										css细节
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2021/07/24/%E5%89%8D%E7%AB%AF/vue%E5%AD%A6%E4%B9%A0/">
										vue学习
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
		</div>
	</div>
</div>

	<!-- 引入正文 -->
	<div id="content">
		<h1 id="article-title">

	摄影测量
</h1>
<div class="article-meta">
	
	<span>Regular</span>
	<span>2021-06-29 12:23:30</span>
		<div id="article-categories">
    
		<span>Categories：</span>
            
                
                    <span>
                        <i class="fa fa-folder" aria-hidden="true">
                        <a href="/categories/摄影测量/">摄影测量</a>
                        </i>
                      
                    </span>
                
            
    

    
		<span>Tags：</span>
            
    
		</div>

</div>

<div id="article-content">
	<h1 id="三方库"><a href="#三方库" class="headerlink" title="三方库"></a>三方库</h1><p>Eigen、Ceres Solver、opencv等</p>
<h1 id="main-cpp"><a href="#main-cpp" class="headerlink" title="main.cpp"></a>main.cpp</h1><pre><code class="lang-c++">#include &quot;image.h&quot;;
#include &quot;file_io.h&quot;
#include &quot;space_resection.h&quot;
#include &quot;feature_matching.h&quot;
#include &quot;image_orientation.h&quot;
#include &quot;forward_intersection.h&quot;

int main() &#123;
    /*Image img;
    vector&lt;Vector3d&gt; Pts;
    vector&lt;Vector2d&gt; pts;
    readImageInfoFromTxt(&quot;D:\\documents\\Photogrammetry\\task1\\Practice\\ImgInfo_example.txt&quot;, img, Pts, pts);
    img.print();

    SpaceResection resection;
    //resection.EulerAngleMethod(img, Pts, pts);
    resection.useCeres(img, Pts, pts);*/

    Image imgL;
    if (!imgL.readImgData(&quot;D:\\documents\\Photogrammetry\\task1\\images\\_MG_1813.JPG&quot;)) &#123;
        return 0;
    &#125;

    FeatureDetection fdetection;
    vector&lt;KeyPoint&gt; keypoints1;
    Mat description1;
    clock_t time0 = clock();

    //fdetection.Harris(imgL.mat_, keypoints1, description1, 2, 3, 0.05, 0.85);
    //fdetection.Sift(imgL.mat_, keypoints1, description1);
    fdetection.Surf(imgL.mat_, keypoints1, description1, 400);

    clock_t time1 = clock();
    cout &lt;&lt; &quot;Totally &quot; &lt;&lt; keypoints1.size() &lt;&lt; &quot; key points detected.\n&quot;;
    cout &lt;&lt; &quot;Feature detection takes time: &quot; &lt;&lt; (time1 - time0) / 1000.0 &lt;&lt; &quot; s.\n&quot;;

    fdetection.showFeature(imgL.mat_, keypoints1);
    cv::waitKey(0);

    /*Image imgR;
    if (!imgR.readImgData(&quot;D:\\documents\\Photogrammetry\\task1\\images\\_MG_1814.JPG&quot;)) &#123;
        return 0;
    &#125;

    IO io;
    io.focal_ = 51.6962;
    io.cx_ = 4312.66;
    io.cy_ = 2911.24;
    io.k1_ = -0.168583;
    io.k2_ = 0.316329;
    io.k3_ = 0.434715;
    io.p1_ = -0.00030953;
    io.p2_ = 0.000414809;
    imgL.io_ = imgR.io_ = io;
    imgL.pixel_size_ = imgR.pixel_size_ = 0.00414;
    FeatureDetection fdetection;
    vector&lt;KeyPoint&gt; keypoints1, keypoints2;
    Mat description1, description2;
    clock_t time_start = clock();

    fdetection.Surf(imgL.mat_, keypoints1, description1, 400);
    fdetection.Surf(imgR.mat_, keypoints2, description2, 400);

    FeatureMatching fmatching;
    vector&lt;DMatch&gt; matches;
    fmatching.FLANN_based(description1, description2, matches, 0.7);

    vector&lt;Vector2d&gt; pixelPtsL(matches.size()), pixelPtsR(matches.size());
    for (int i = 0; i &lt; matches.size(); i++) &#123;
        pixelPtsL[i] = Vector2d(keypoints1[matches[i].queryIdx].pt.x, keypoints1[matches[i].queryIdx].pt.y);
        pixelPtsR[i] = Vector2d(keypoints2[matches[i].trainIdx].pt.x, keypoints2[matches[i].trainIdx].pt.y);
    &#125;

    //相对定向
    RelativeOrientation ro;
    Mat rR;
    Vector3d rT;
    ro.cv(imgL, imgR, pixelPtsL, pixelPtsR, rR, rT);

    //用相对定向结果计算三维点坐标
    vector&lt;Point3d&gt; space_pts;
    Mat mask;
    Mat RcvL = (cv::Mat_&lt;double&gt;(3, 3) &lt;&lt; 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0);
    Mat TcvL = Mat::zeros(3, 1, CV_64FC1);
    Mat RcvR, TcvR;
    rR.copyTo(RcvR);
    TcvR = (cv::Mat_&lt;double&gt;(3, 1) &lt;&lt; rT.x(), rT.y(), rT.z());

    ForwardIntersection forIntersection;
    forIntersection.cv(imgL, imgR, RcvL, RcvR, TcvL, TcvR, pixelPtsL, pixelPtsR, space_pts, mask);

    string path = &quot;D:\\documents\\libraries\\3dviewer\\structure.yml&quot;;
    std::vector&lt;Mat&gt; Rs, Ts;
    Rs.push_back(RcvL);
    Rs.push_back(RcvR);
    Ts.push_back(TcvL);
    Ts.push_back(TcvR);
    save_structure(path, Rs, Ts, space_pts, mask);*/
&#125;
</code></pre>
<h1 id="file-io-h"><a href="#file-io-h" class="headerlink" title="file_io.h"></a>file_io.h</h1><pre><code class="lang-c++">#pragma once
#include &quot;image.h&quot;
#include &lt;fstream&gt;

int readImageInfoFromTxt(const string&amp; path, Image&amp; img, vector&lt;Vector3d&gt;&amp; Pts, vector&lt;Vector2d&gt;&amp; pts) &#123;
    ifstream infile(path, ios::in);
    if (!infile.is_open()) &#123;
        cout &lt;&lt; &quot;Lol,failed to open Txt!&quot;;
        return 0;
    &#125;

    while (!infile.eof()) &#123;
        string str;
        infile &gt;&gt; str;
        if (str == &quot;ImagePath&quot;) &#123;
            string img_path;
            infile &gt;&gt; img_path;
            img.path_ = img_path;
        &#125;
        else if (str == &quot;width&quot;)
            infile &gt;&gt; img.width_;
        else if (str == &quot;height&quot;)
            infile &gt;&gt; img.height_;
        else if (str == &quot;pixel_size&quot;)
            infile &gt;&gt; img.pixel_size_;
        else if (str == &quot;focal_length&quot;)
            infile &gt;&gt; img.io_.focal_;
        else if (str == &quot;principle_point&quot;)
            infile &gt;&gt; img.io_.cx_ &gt;&gt; img.io_.cy_;
        else if (str == &quot;distortions&quot;)
            infile &gt;&gt; img.io_.k1_ &gt;&gt; img.io_.k2_ &gt;&gt; img.io_.k3_ &gt;&gt; img.io_.p1_ &gt;&gt; img.io_.p2_;
        else if (str == &quot;Points&quot;) &#123;
            int num;
            infile &gt;&gt; num;
            Pts.resize(num);
            pts.resize(num);
            for (int i = 0; i &lt; num; i++)
                infile &gt;&gt; Pts[i].x() &gt;&gt; Pts[i].y() &gt;&gt; Pts[i].z() &gt;&gt; pts[i].x() &gt;&gt; pts[i].y();
            break;
        &#125;
    &#125;
    infile.close();
    return 1;
&#125;
</code></pre>
<h1 id="image-h"><a href="#image-h" class="headerlink" title="image.h"></a>image.h</h1><pre><code class="lang-c++">#pragma once
#include &lt;opencv2/core/core.hpp&gt;
#include &lt;opencv2/imgcodecs.hpp&gt;
#include &lt;opencv2/highgui.hpp&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;Eigen/Core&gt;
#include &lt;vector&gt;

using namespace Eigen;
using namespace cv;
using namespace std;

struct IO &#123;
    float focal_; //像主距
    float cx_; //像主点x,单位为像素
    float cy_; //像主点y，单位为像素
    float k1_;
    float k2_;
    float k3_;
    float p1_;
    float p2_;
&#125;;

struct EO &#123;
    MatrixXd R_;
    MatrixXd T_;
&#125;;

class Image &#123;
public:
    //无参构造函数
    Image() &#123;
        width_ = 0;
        height_ = 0;
        pixel_size_ = 0;
        io_.focal_ = 35;
        io_.cx_ = 0;
        io_.cy_ = 0;
        io_.k1_ = io_.k2_ = io_.k3_ = io_.p1_ = io_.p2_ = 0.0;
        eo_.R_ = MatrixXd::Ones(3, 3);
        eo_.T_ = MatrixXd::Ones(3, 1);
    &#125;
    //有参构造函数
    Image(const int&amp; width, const int&amp; height, const float&amp; pixel_size) &#123;
        width_ = width;
        height_ = height;
        pixel_size_ = pixel_size;
        io_.focal_ = 35;
        io_.cx_ = (width - 1) / 2;
        io_.cy_ = (height - 1) / 2;
        io_.k1_ = io_.k2_ = io_.k3_ = io_.p1_ = io_.p2_ = 0.0;
        eo_.R_ = MatrixXd::Ones(3, 3);
        eo_.T_ = MatrixXd::Ones(3, 1);
    &#125;

    //属性值
public:
    //影像文件路径
    string path_ = &quot;&quot;;

    //影像基本参数
    int width_;
    int height_;
    float pixel_size_; //单位为mm

    //内参
    IO io_;

    //外参
    EO eo_;

    Mat mat_;
public:
    void print() &#123;
        cout &lt;&lt; &quot;width: &quot; &lt;&lt; width_ &lt;&lt; endl
            &lt;&lt; &quot;height: &quot; &lt;&lt; height_ &lt;&lt; endl
            &lt;&lt; &quot;pixel size: &quot; &lt;&lt; pixel_size_ &lt;&lt; endl
            &lt;&lt; &quot;focal length: &quot; &lt;&lt; io_.focal_ &lt;&lt; endl
            &lt;&lt; &quot;principle point: &quot; &lt;&lt; io_.cx_ &lt;&lt; &quot;, &quot; &lt;&lt; io_.cy_ &lt;&lt; endl
            &lt;&lt; &quot;distortion params: &quot; &lt;&lt; io_.k1_ &lt;&lt; &quot; &quot; &lt;&lt; io_.k2_ &lt;&lt; &quot; &quot; &lt;&lt; io_.k3_ &lt;&lt; &quot; &quot; &lt;&lt; io_.p1_ &lt;&lt; &quot; &quot; &lt;&lt; io_.p2_ &lt;&lt; endl
            &lt;&lt; &quot;position: &quot; &lt;&lt; eo_.T_(0, 0) &lt;&lt; &quot; &quot; &lt;&lt; eo_.T_(1, 0) &lt;&lt; &quot; &quot; &lt;&lt; eo_.T_(2, 0) &lt;&lt; endl
            &lt;&lt; &quot;rotation: &quot; &lt;&lt; endl
            &lt;&lt; eo_.R_(0, 0) &lt;&lt; &quot; &quot; &lt;&lt; eo_.R_(0, 1) &lt;&lt; &quot; &quot; &lt;&lt; eo_.R_(0, 2) &lt;&lt; endl
            &lt;&lt; eo_.R_(1, 0) &lt;&lt; &quot; &quot; &lt;&lt; eo_.R_(1, 1) &lt;&lt; &quot; &quot; &lt;&lt; eo_.R_(1, 2) &lt;&lt; endl
            &lt;&lt; eo_.R_(2, 0) &lt;&lt; &quot; &quot; &lt;&lt; eo_.R_(2, 1) &lt;&lt; &quot; &quot; &lt;&lt; eo_.R_(2, 2) &lt;&lt; endl;
    &#125;
    //将像点由像素坐标转换为像平面坐标
    void pixelpoints2imagepoints(const vector&lt;Vector2d&gt;&amp; pixelPts, vector&lt;Vector2d&gt;&amp; imgPts);

    MatrixXd getRotationfromAngles(const double&amp; phi, const double&amp; omega, const double&amp; kappa);

    int readImgData(const string&amp; filepath) &#123;
        mat_ = imread(filepath); //读文件
        if (mat_.data == NULL) &#123;//测试影像是否打开
            cout &lt;&lt; &quot;Failed to read the image file.\n&quot;;
            return 0;
        &#125;
        path_ = filepath;
        width_ = mat_.cols;
        height_ = mat_.rows;
    &#125;

    void showImg() &#123;
        if (mat_.data == NULL) &#123;
            cout &lt;&lt; &quot;No image data.\n&quot;;
            return;
        &#125;
        Mat img_show;
        mat_.copyTo(img_show);
        namedWindow(path_, CV_WINDOW_NORMAL);
        resizeWindow(path_, 960, int(height_ * 960.0 / width_));
        moveWindow(path_, 100, 100);
        imshow(path_, img_show);
    &#125;

&#125;;

int save_structure(
    const string&amp; savepath,
    const std::vector&lt;Mat&gt;&amp; Rs,
    const std::vector&lt;Mat&gt;&amp; Ts,
    const std::vector&lt;Point3d&gt;&amp; points,
    const Mat&amp; mask
);
</code></pre>
<h1 id="image-cpp"><a href="#image-cpp" class="headerlink" title="image.cpp"></a>image.cpp</h1><pre><code class="lang-c++">#include &quot;image.h&quot;
#include &lt;vector&gt;

void Image::pixelpoints2imagepoints(const vector&lt;Vector2d&gt;&amp; pixelPts, vector&lt;Vector2d&gt;&amp; imgPts) &#123;
    double pix_size = pixel_size_ / 1000.0;
    imgPts.resize(pixelPts.size());
    for (int i = 0; i &lt; pixelPts.size(); i++) &#123;
        double u = pixelPts[i].x();
        double v = pixelPts[i].y();
        double x = (u - io_.cx_) * pix_size;
        double y = -(v - io_.cy_) * pix_size;
        double r2 = x * x + y * y;
        double r4 = r2 * r2;
        double r6 = r2 * r4;
        imgPts[i].x() = x + x * (io_.k1_ * r2 + io_.k2_ * r4 + io_.k3_ * r6) + io_.p1_ * (r2 + 2 * x * x) + 2 * io_.p2_ * x * y;
        imgPts[i].y() = y + y * (io_.k1_ * r2 + io_.k2_ * r4 + io_.k3_ * r6) + io_.p1_ * (r2 + 2 * y * y) + 2 * io_.p2_ * x * y;
    &#125;
&#125;

MatrixXd Image::getRotationfromAngles(const double&amp; phi, const double&amp; omega, const double&amp; kappa) &#123;
    eo_.R_(0, 0) = cos(phi) * cos(kappa) - sin(phi) * sin(omega) * sin(kappa);
    eo_.R_(0, 1) = -cos(phi) * sin(kappa) - sin(phi) * sin(omega) * cos(kappa);
    eo_.R_(0, 2) = -sin(phi) * cos(omega);
    eo_.R_(1, 0) = cos(omega) * sin(kappa);
    eo_.R_(1, 1) = cos(omega) * cos(kappa);
    eo_.R_(1, 2) = -sin(omega);
    eo_.R_(2, 0) = sin(phi) * cos(kappa) + cos(phi) * sin(omega) * sin(kappa);
    eo_.R_(2, 1) = -sin(phi) * sin(kappa) + cos(phi) * sin(omega) * cos(kappa);
    eo_.R_(2, 2) = cos(phi) * cos(omega);

    return eo_.R_;
&#125;

int save_structure(
    const string&amp; savepath,
    const std::vector&lt;Mat&gt;&amp; Rs,
    const std::vector&lt;Mat&gt;&amp; Ts,
    const std::vector&lt;Point3d&gt;&amp; points,
    const Mat&amp; mask
) &#123;
    int n = (int)Rs.size();

    FileStorage fs(savepath, FileStorage::WRITE);
    if (!fs.isOpened())
        return 0;

    fs &lt;&lt; &quot;Camera Count&quot; &lt;&lt; n;
    fs &lt;&lt; &quot;Point Count&quot; &lt;&lt; (int)points.size();

    fs &lt;&lt; &quot;Rotations&quot; &lt;&lt; &quot;[&quot;;
    for (size_t i = 0; i &lt; n; ++i) &#123;
        if (Rs[i].empty())
            fs &lt;&lt; cv::Mat::zeros(3, 3, CV_64FC1);
        else
            //fs &lt;&lt; Rs[i].inv();
            fs &lt;&lt; Rs[i];
    &#125;
    fs &lt;&lt; &quot;]&quot;;

    fs &lt;&lt; &quot;Motions&quot; &lt;&lt; &quot;[&quot;;
    for (size_t i = 0; i &lt; n; ++i)
    &#123;
        if (Ts[i].empty() || Rs[i].empty())
            fs &lt;&lt; cv::Mat::zeros(3, 1, CV_64FC1);
        else
            //fs &lt;&lt; -Rs[i].inv() * Ts[i];
            fs &lt;&lt; Ts[i];
    &#125;
    fs &lt;&lt; &quot;]&quot;;

    fs &lt;&lt; &quot;Points&quot; &lt;&lt; &quot;[&quot;;
    for (size_t i = 0; i &lt; points.size(); ++i)
    &#123;
        fs &lt;&lt; points[i];
    &#125;
    fs &lt;&lt; &quot;]&quot;;

    fs &lt;&lt; &quot;Colors&quot; &lt;&lt; &quot;[&quot;;
    for (size_t i = 0; i &lt; points.size(); ++i)
    &#123;
        if (mask.at&lt;uchar&gt;(i) &gt; 0)
            fs &lt;&lt; Vec3b(255, 255, 0);
        else
            fs &lt;&lt; Vec3b(0, 0, 255);
    &#125;
    fs &lt;&lt; &quot;]&quot;;

    fs.release();
    return 1;

&#125;
</code></pre>
<h1 id="space-resection-h"><a href="#space-resection-h" class="headerlink" title="space_resection.h"></a>space_resection.h</h1><pre><code class="lang-c++">#pragma once
#include &quot;image.h&quot;

class SpaceResection &#123;

public:
    int EulerAngleMethod(Image img, const vector&lt;Vector3d&gt;&amp; Pts, const vector&lt;Vector2d&gt;&amp; pts);

    int useCeres(Image&amp; img, const vector&lt;Vector3d&gt;&amp; Pts, const vector&lt;Vector2d&gt;&amp; pts);
&#125;;
</code></pre>
<h1 id="space-resection-cpp"><a href="#space-resection-cpp" class="headerlink" title="space_resection.cpp"></a>space_resection.cpp</h1><pre><code class="lang-c++">#include &quot;space_Resection.h&quot;
#include&lt;cmath&gt;
#include&lt;Eigen/LU&gt;
#include &lt;ceres/ceres.h&gt;
#include &lt;glog/logging.h&gt;

#ifdef max
#undef max
#endif //max

#ifdef min
#undef min
#endif //min

constexpr auto G_ERROR = 1e-3;        //平移坐标改正值阈值
constexpr auto A_ERROR = 1e-7;        //旋转角改正值阈值

static double f_ = 50;
struct EulerAngleBackCrossResidual
&#123;
    /*
    X,Y,Z,x,y分别为观测值
    */
    EulerAngleBackCrossResidual(double X, double Y, double Z, double x, double y)
        : X_(X), Y_(Y), Z_(Z), x_(x), y_(y) &#123;&#125;;

    template &lt;class T&gt;
    bool operator()(const T* const pBackCrossParameters, T* residual) const &#123;
        T dXs = pBackCrossParameters[0];
        T dYs = pBackCrossParameters[1];
        T dZs = pBackCrossParameters[2];
        T dPhi = pBackCrossParameters[3];
        T dOmega = pBackCrossParameters[4];
        T dKappa = pBackCrossParameters[5];

        T a1 = ceres::cos(dPhi) * ceres::cos(dKappa) - ceres::sin(dPhi) * ceres::sin(dOmega) * ceres::sin(dKappa);
        T a2 = -ceres::cos(dPhi) * ceres::sin(dKappa) - ceres::sin(dPhi) * ceres::sin(dOmega) * ceres::cos(dKappa);
        T a3 = -ceres::sin(dPhi) * ceres::cos(dOmega);
        T b1 = ceres::cos(dOmega) * ceres::sin(dKappa);
        T b2 = ceres::cos(dOmega) * ceres::cos(dKappa);
        T b3 = -ceres::sin(dOmega);
        T c1 = ceres::sin(dPhi) * ceres::cos(dKappa) + ceres::cos(dPhi) * ceres::sin(dOmega) * ceres::sin(dKappa);
        T c2 = -ceres::sin(dPhi) * ceres::sin(dKappa) + ceres::cos(dPhi) * ceres::sin(dOmega) * ceres::cos(dKappa);
        T c3 = ceres::cos(dPhi) * ceres::cos(dOmega);

        T XX = a1 * (X_ - dXs) + b1 * (Y_ - dYs) + c1 * (Z_ - dZs);
        T YY = a2 * (X_ - dXs) + b2 * (Y_ - dYs) + c2 * (Z_ - dZs);
        T ZZ = a3 * (X_ - dXs) + b3 * (Y_ - dYs) + c3 * (Z_ - dZs);

        //有两个残差
        residual[0] = T(x_) + T(f_) * XX / ZZ;
        residual[1] = T(y_) + T(f_) * YY / ZZ;

        return true;
    &#125;
private:
    const double X_;
    const double Y_;
    const double Z_;
    const double x_;
    const double y_;
&#125;;


int SpaceResection::EulerAngleMethod(Image img, const vector&lt;Vector3d&gt;&amp; Pts, const vector&lt;Vector2d&gt;&amp; pts) &#123;
    //计算外方位元素初始值
    int Num = max(3.0, pts.size() / 2.0);//用一般的点进行空间后方交会计算，另一半进行精度验证

    vector&lt;Vector2d&gt; imgPts;

    img.pixelpoints2imagepoints(pts, imgPts);

    double f = img.io_.focal_ / 1000.0;

    //估算摄影比例尺
    double GS = 0, SS = 0;
    for (int i = 0; i &lt; Num - 1; i++) &#123;
        GS += (Pts[i] - Pts[i + 1]).norm();
        SS += (imgPts[i] - imgPts[i + 1]).norm();
    &#125;
    double lfScale = GS / SS;

    //估算外方位元素初始值
    double Xs = 0, Ys = 0, Zs = 0, phi = 0, omega = 0, kappa = 0;
    for (int i = 0; i &lt; Num; i++) &#123;
        Xs += Pts[i].x();
        Ys += Pts[i].y();
        Zs += Pts[i].z();
    &#125;
    Xs /= Num;
    Ys /= Num;
    Zs /= Num;
    Zs += f * lfScale;

    double fSANGLE = atan2((imgPts[1] - imgPts[0]).y(), (imgPts[1] - imgPts[0]).x());
    double fGANGLE = atan2((Pts[1] - Pts[0]).y(), (Pts[1] - Pts[0]).x());
    kappa = fSANGLE - fGANGLE;


    MatrixXd B = MatrixXd(2 * Num, 6);
    MatrixXd L = MatrixXd(2 * Num, 1);
    MatrixXd Delta = MatrixXd::Ones(6, 1);
    int iterationNum = 0;
    do &#123;
        //误差方程
        MatrixXd R = img.getRotationfromAngles(phi, omega, kappa);
        for (int i = 0; i &lt; Num; i++) &#123;
            MatrixXd P = MatrixXd(3, 1);
            P(0, 0) = Pts[i].x() - Xs;
            P(1, 0) = Pts[i].y() - Ys;
            P(2, 0) = Pts[i].z() - Zs;
            MatrixXd PP = R.transpose() * P;
            double x = imgPts[i].x();
            double y = imgPts[i].y();

            //double x = -f * PP(0,0) / PP(2, 0)
            //double y = -f * PP(1, 0) / PP(2,0)

            double b11 = (R(0, 0) * f + R(0, 2) * x) / PP(2, 0);
            double b12 = (R(1, 0) * f + R(1, 2) * x) / PP(2, 0);
            double b13 = (R(2, 0) * f + R(2, 2) * x) / PP(2, 0);
            double b14 = y * sin(omega) - (x / f * (x * cos(kappa) - y * sin(kappa)) + f * cos(kappa)) * cos(omega);
            double b15 = -f * sin(kappa) - x / f * (x * sin(kappa) + y * cos(kappa));
            double b16 = y;

            double b21 = (R(0, 1) * f + R(0, 2) * y) / PP(2, 0);
            double b22 = (R(1, 1) * f + R(1, 2) * y) / PP(2, 0);
            double b23 = (R(2, 1) * f + R(2, 2) * y) / PP(2, 0);
            double b24 = -x * sin(omega) - (y / f * (x * cos(kappa) - y * sin(kappa)) - f * sin(kappa)) * cos(omega);
            double b25 = -f * cos(kappa) - y / f * (x * sin(kappa) + y * cos(kappa));
            double b26 = -x;

            double xx = -f * PP(0, 0) / PP(2, 0);
            double yy = -f * PP(1, 0) / PP(2, 0);

            B(i * 2 + 0, 0) = b11; B(i * 2 + 0, 1) = b12; B(i * 2 + 0, 2) = b13;
            B(i * 2 + 0, 3) = b14; B(i * 2 + 0, 4) = b15; B(i * 2 + 0, 5) = b16;
            B(i * 2 + 1, 0) = b21; B(i * 2 + 1, 1) = b22; B(i * 2 + 1, 2) = b23;
            B(i * 2 + 1, 3) = b24; B(i * 2 + 1, 4) = b25; B(i * 2 + 1, 5) = b26;
            L(i * 2 + 0, 0) = imgPts[i].x() - xx;
            L(i * 2 + 1, 0) = imgPts[i].y() - yy;
        &#125;
        cout &lt;&lt; &quot;********** iteration num:&quot; &lt;&lt; iterationNum &lt;&lt; &quot;*****************&quot; &lt;&lt; endl;
        cout &lt;&lt; &quot;B: &quot; &lt;&lt; endl &lt;&lt; B &lt;&lt; endl &lt;&lt; &quot;-----------------&quot; &lt;&lt; endl;
        cout &lt;&lt; &quot;L: &quot; &lt;&lt; endl &lt;&lt; L &lt;&lt; endl &lt;&lt; &quot;-----------------&quot; &lt;&lt; endl;
        MatrixXd BT = B.transpose();
        MatrixXd BTB = BT * B;
        MatrixXd BTBinv = BTB.inverse();
        Delta = BTBinv * (BT * L);

        cout &lt;&lt; &quot;Delta: &quot; &lt;&lt; endl &lt;&lt; Delta &lt;&lt; endl &lt;&lt; endl;

        //修正外方位元素
        Xs += Delta(0, 0);
        Ys += Delta(1, 0);
        Zs += Delta(2, 0);
        phi += Delta(3, 0);
        omega += Delta(4, 0);
        kappa += Delta(5, 0);

        iterationNum++;

    &#125; while ((fabs(Delta(0, 0)) &gt; G_ERROR || fabs(Delta(1, 0)) &gt; G_ERROR || fabs(Delta(2, 0)) &gt; G_ERROR ||
        fabs(Delta(3, 0)) &gt; A_ERROR || fabs(Delta(4, 0)) &gt; A_ERROR || fabs(Delta(5, 0)) &gt; A_ERROR)
        &amp;&amp; iterationNum &lt; 1000);

    //计算单位权中误差
    MatrixXd v = B * Delta - L;
    cout &lt;&lt; &quot;v: &quot; &lt;&lt; endl &lt;&lt; v &lt;&lt; endl &lt;&lt; &quot;--------------&quot; &lt;&lt; endl;
    MatrixXd s = v.transpose() * v;
    double m0 = sqrtf(s(0, 0) / (2 * Num - 6));
    cout &lt;&lt; &quot;--------------单位权中误差 m0= &quot; &lt;&lt; m0 &lt;&lt; &quot;--------------------&quot; &lt;&lt; endl;

    img.eo_.T_(0, 0) = Xs;
    img.eo_.T_(1, 0) = Ys;
    img.eo_.T_(2, 0) = Zs;

    //验证
    MatrixXd R = img.getRotationfromAngles(phi, omega, kappa);
    for (int i = 0; i &lt; Pts.size(); i++) &#123;
        double x = imgPts[i].x();
        double y = imgPts[i].y();
        MatrixXd P = MatrixXd(3, 1);
        P(0, 0) = Pts[i].x() - Xs;
        P(1, 0) = Pts[i].y() - Ys;
        P(2, 0) = Pts[i].z() - Zs;
        MatrixXd PP = R.transpose() * P;
        double xx = -f * PP(0, 0) / PP(2, 0);
        double yy = -f * PP(1, 0) / PP(2, 0);
        double du = (x - xx) / img.pixel_size_;
        double dv = (y - yy) / img.pixel_size_;

        if (i &gt;= Num)
            cout &lt;&lt; &quot;check points: --------------&quot; &lt;&lt; endl;
        cout &lt;&lt; &quot;point &quot; &lt;&lt; i &lt;&lt; &quot;: dx=&quot; &lt;&lt; du &lt;&lt; &quot;,  dy=&quot; &lt;&lt; dv &lt;&lt; &quot; error = &quot; &lt;&lt; sqrtf(du * du + dv * dv) &lt;&lt; &quot; pixels &quot;
            &lt;&lt; endl &lt;&lt; &quot;----------------&quot; &lt;&lt; endl;
    &#125;
    cout &lt;&lt; &quot;Position: &quot;;
    cout &lt;&lt; img.eo_.T_(0, 0) &lt;&lt; &quot;, &quot; &lt;&lt; img.eo_.T_(1, 0) &lt;&lt; &quot;, &quot; &lt;&lt; img.eo_.T_(2, 0) &lt;&lt; endl;
    cout &lt;&lt; &quot;Rotation: &quot; &lt;&lt; endl &lt;&lt; img.eo_.R_;
    return 1;
&#125;

int SpaceResection::useCeres(Image&amp; img, const vector&lt;Vector3d&gt;&amp; Pts, const vector&lt;Vector2d&gt;&amp; pts) &#123;
    //计算外方位元素初始值
    int Num = max(3.0, pts.size() / 2.0);//用一般的点进行空间后方交会计算，另一半进行精度验证

    vector&lt;Vector2d&gt; imgPts;

    img.pixelpoints2imagepoints(pts, imgPts);

    double f = img.io_.focal_ / 1000.0;

    //估算摄影比例尺 
    double GS = 0, SS = 0;
    for (int i = 0; i &lt; Num - 1; i++) &#123;
        GS += (Pts[i] - Pts[i + 1]).norm();
        SS += (imgPts[i] - imgPts[i + 1]).norm();
    &#125;
    double lfScale = GS / SS;

    //估算外方位元素初始值
    double Xs = 0, Ys = 0, Zs = 0, phi = 0, omega = 0, kappa = 0;
    for (int i = 0; i &lt; Num; i++) &#123;
        Xs += Pts[i].x();
        Ys += Pts[i].y();
        Zs += Pts[i].z();
    &#125;
    Xs /= Num;
    Ys /= Num;
    Zs /= Num;
    Zs += f * lfScale;

    double fSANGLE = atan2((imgPts[1] - imgPts[0]).y(), (imgPts[1] - imgPts[0]).x());
    double fGANGLE = atan2((Pts[1] - Pts[0]).y(), (Pts[1] - Pts[0]).x());
    kappa = fSANGLE - fGANGLE;


    MatrixXd B = MatrixXd(2 * Num, 6);
    MatrixXd L = MatrixXd(2 * Num, 1);
    MatrixXd Delta = MatrixXd::Ones(6, 1);

    //利用Ceres Solver计算外方位元素
    f_ = f;
    double dBackCrossParameters[6] = &#123; Xs, Ys, Zs, phi, omega, kappa &#125;;
    ceres::Problem problem;
    for (int i = 0; i &lt; Num; i++) &#123;
        EulerAngleBackCrossResidual* pResidual =
            new EulerAngleBackCrossResidual(Pts[i].x(), Pts[i].y(), Pts[i].z(), imgPts[i].x(), imgPts[i].y());
        problem.AddResidualBlock(
            new ceres::AutoDiffCostFunction&lt;EulerAngleBackCrossResidual, 2, 6&gt;(pResidual),
            NULL, dBackCrossParameters);
    &#125;

    ceres::Solver::Options m_options;
    ceres::Solver::Summary m_summary;
    m_options.max_num_iterations = 1000;
    m_options.linear_solver_type = ceres::DENSE_QR;
    m_options.minimizer_progress_to_stdout = true;

    ceres::Solve(m_options, &amp;problem, &amp;m_summary);

    cout &lt;&lt; &quot;-------------------------------&quot; &lt;&lt; endl;
    cout.precision(10);
    cout &lt;&lt; m_summary.BriefReport() &lt;&lt; &quot;\n&quot;;

    img.eo_.T_(0, 0) = dBackCrossParameters[0];
    img.eo_.T_(1, 0) = dBackCrossParameters[1];
    img.eo_.T_(2, 0) = dBackCrossParameters[2];

    //验证
    MatrixXd R = img.getRotationfromAngles(dBackCrossParameters[3], dBackCrossParameters[4], dBackCrossParameters[5]);
    for (int i = Num; i &lt; Pts.size(); i++) &#123;
        double x = imgPts[i].x();
        double y = imgPts[i].y();
        MatrixXd P = MatrixXd(3, 1);
        P(0, 0) = Pts[i].x() - Xs;
        P(1, 0) = Pts[i].y() - Ys;
        P(2, 0) = Pts[i].z() - Zs;
        MatrixXd PP = R.transpose() * P;
        double xx = -f * PP(0, 0) / PP(2, 0);
        double yy = -f * PP(1, 0) / PP(2, 0);
        double du = (x - xx) / img.pixel_size_;
        double dv = (y - yy) / img.pixel_size_;
        cout &lt;&lt; &quot;point &quot; &lt;&lt; i &lt;&lt; &quot;: dx=&quot; &lt;&lt; du &lt;&lt; &quot;,  dy=&quot; &lt;&lt; dv &lt;&lt; &quot; error = &quot; &lt;&lt; sqrtf(du * du + dv * dv) &lt;&lt; &quot; pixels &quot;
            &lt;&lt; endl &lt;&lt; &quot;----------------&quot; &lt;&lt; endl;

    &#125;

    cout &lt;&lt; &quot;Position: &quot;;
    cout &lt;&lt; img.eo_.T_(0, 0) &lt;&lt; &quot;, &quot; &lt;&lt; img.eo_.T_(1, 0) &lt;&lt; &quot;, &quot; &lt;&lt; img.eo_.T_(2, 0) &lt;&lt; endl;
    cout &lt;&lt; &quot;Rotation: &quot; &lt;&lt; endl &lt;&lt; img.eo_.R_;
    return 1;
&#125;
</code></pre>
<h1 id="feature-matching-h"><a href="#feature-matching-h" class="headerlink" title="feature_matching.h"></a>feature_matching.h</h1><pre><code class="lang-c++">#pragma once
#include &lt;opencv2/core.hpp&gt;

using namespace std;
using namespace cv;

class FeatureDetection &#123;
public:
    int Harris(
        const Mat&amp; img,                    //影像
        vector&lt;KeyPoint&gt;&amp; keypoints,    //影像上的特征点
        Mat&amp; description,                //特征点描述
        int blockSize = 2,                //Neighborhood size
        int apertureSize = 3,            //Aperture parameter for the Sobel operator
        double k = 0.04,                //Harris detector free parameter
        float thresh = 0.75                //threshold(0 ~ 1.0)
    );

    void showFeature(const Mat&amp; img, const vector&lt;KeyPoint&gt;&amp; keypoints);

    int Sift(
        const Mat&amp; img,                    //影像
        vector&lt;KeyPoint&gt;&amp; keypoints,    //影像上的特征点
        Mat&amp; description,                //特征点描述
        const int&amp; nfeatrues = 0,        //The number of best features to ratain
        const int&amp; nOctaveLayers = 3,    //The number of layers in each octave
        const double&amp; contrastThreshold = 0.04,    //The contrast threshold will be divided by
        const double&amp; edgeThreshold = 20,        //The threshold used to filter out edge-like features.
        const double&amp; sigma = 1.6                //The sigma if the Gaussian applied to the input image at the octave.
    );

    int Surf(
        const Mat&amp; img,                    //影像
        vector&lt;KeyPoint&gt;&amp; keypoints,    //影像上的特征点
        Mat&amp; description,                //特征点描述
        const double&amp; hessianThreshold = 100,    //Threshold for hessian keypoint detector used in Surf.
        const int&amp; nOctaves = 4,                //Number of pyramid octaves the keypoint detector will use.    
        const int&amp; nOctaveLayers = 3            //Number of octave layers within each octave.
    );
&#125;;

class FeatureMatching &#123;
public:
    int Brute_force(
        const Mat&amp; description1,        //特征点描述
        const Mat&amp; description2,        //特征点描述
        vector&lt;DMatch&gt;&amp; matched,        //匹配结果
        const float&amp; ratio_thresh = 0.7
    );

    void showMatches(
        const Mat&amp; img1,
        const vector&lt;KeyPoint&gt;&amp; keypoints1,
        const Mat&amp; img2,
        const vector&lt;KeyPoint&gt;&amp; keypoints2,
        const vector&lt;DMatch&gt;&amp; matches
    );

    int FLANN_based(
        const Mat&amp; description1,
        const Mat&amp; description2,
        vector&lt;DMatch&gt;&amp; matches,
        const float&amp; ratio_thresh = 0.7
    );
&#125;;
</code></pre>
<h1 id="feature-matching-cpp"><a href="#feature-matching-cpp" class="headerlink" title="feature_matching.cpp"></a>feature_matching.cpp</h1><pre><code class="lang-c++">#include &quot;feature_matching.h&quot;
#include &lt;opencv2/highgui.hpp&gt;
#include &lt;opencv2/imgproc.hpp&gt;
#include &lt;opencv2/features2d.hpp&gt;
#include &lt;opencv2/xfeatures2d.hpp&gt;

using namespace cv::xfeatures2d;

int FeatureDetection::Harris(
    const Mat&amp; img,
    vector&lt;KeyPoint&gt;&amp; keypoints,
    Mat&amp; description,
    int blockSize,
    int apertureSize,
    double k,
    float thresh) &#123;
    Mat img_gray;
    cvtColor(img, img_gray, COLOR_RGB2GRAY);

    //Corners 角点特征提取
    Mat dst, dst_norm;
    dst = Mat::zeros(img_gray.size(), CV_32FC1);
    cornerHarris(img_gray, dst, blockSize, apertureSize, k, BORDER_DEFAULT);

    //特征影像归一化处理
    normalize(dst, dst_norm, 0, 1.0, NORM_MINMAX, CV_32FC1, Mat());

    //提取特征点
    keypoints.resize(0);

    for (int j = 1; j &lt; dst_norm.rows - 1; j++) &#123;
        for (int i = 1; i &lt; dst_norm.cols - 1; i++) &#123;
            if (dst_norm.at&lt;float&gt;(j, i) &gt; thresh)
                keypoints.push_back(KeyPoint(i, j, 20.0));
        &#125;
    &#125;

    //将角点转换为特征描述
    //特征描述description为一个矩阵，其中矩阵的每一行对应一个Keypoints
    //每一行为一个9维的向量，向量1个值为当前特征点的灰度值，剩余8个值分别为向量像素点与当前特征点的灰度差
    description = Mat::zeros(keypoints.size(), 9, CV_32F);
    for (int i = 0; i &lt; keypoints.size(); i++) &#123;
        float v = img_gray.at&lt;uchar&gt;(keypoints[i].pt);
        description.at&lt;float&gt;(i, 0) = v;
        description.at&lt;float&gt;(i, 1) = img_gray.at&lt;uchar&gt;(keypoints[i].pt - Point2f(-1, -1)) - v;
        description.at&lt;float&gt;(i, 2) = img_gray.at&lt;uchar&gt;(keypoints[i].pt - Point2f(-1, 0)) - v;
        description.at&lt;float&gt;(i, 3) = img_gray.at&lt;uchar&gt;(keypoints[i].pt - Point2f(-1, 1)) - v;
        description.at&lt;float&gt;(i, 4) = img_gray.at&lt;uchar&gt;(keypoints[i].pt - Point2f(0, -1)) - v;
        description.at&lt;float&gt;(i, 5) = img_gray.at&lt;uchar&gt;(keypoints[i].pt - Point2f(0, 1)) - v;
        description.at&lt;float&gt;(i, 6) = img_gray.at&lt;uchar&gt;(keypoints[i].pt - Point2f(0, -1)) - v;
        description.at&lt;float&gt;(i, 7) = img_gray.at&lt;uchar&gt;(keypoints[i].pt - Point2f(0, 0)) - v;
        description.at&lt;float&gt;(i, 8) = img_gray.at&lt;uchar&gt;(keypoints[i].pt - Point2f(0, 1)) - v;
    &#125;

    return 1;
&#125;

void FeatureDetection::showFeature(const Mat&amp; img, const vector&lt;KeyPoint&gt;&amp; keypoints) &#123;
    Mat img_show;
    img.copyTo(img_show);
    if (img_show.channels() == 1) &#123;
        cvtColor(img_show, img_show, COLOR_GRAY2BGR);
    &#125;

    for (int i = 0; i &lt; keypoints.size(); i++) &#123;
        Point p = keypoints[i].pt;
        circle(img_show, p, keypoints[i].size, Scalar(0, 255, 0), 10, 8, 0);
    &#125;

    string win_str = &quot;Featured image&quot;;
    namedWindow(win_str, WINDOW_NORMAL);
    resizeWindow(win_str, 960, int(img_show.rows * 960.0 / img_show.cols));
    moveWindow(win_str, 100, 100);
    imshow(win_str, img_show);
&#125;

int FeatureDetection::Sift(
    const Mat&amp; img,
    vector&lt;KeyPoint&gt;&amp; keypoints,
    Mat&amp; description,
    const int&amp; nfeatrues, /* = 0, 保留的最佳特性的数量*/
    const int&amp; nOctaveLayers, /* = 3，高斯金字塔最小层级数，由图像自动计算出 */
    const double&amp; contrastThreshold, /* = 0.04， 对比阈值用于过滤区域中的弱特征。阈值越大，检测器产生的特征越少*/
    const double&amp; edgeThreshold, /* = 10, 用于过滤掉类似边缘特征的阈值，与对比阈值不同，即边缘阈值越大，滤出的特征越少*/
    const double&amp; sigma /* = 1.6， 高斯输入层级， 如果图像分辨率较低，则可能需要减少数值*/
) &#123;
    Mat img_gray;
    cvtColor(img, img_gray, COLOR_RGB2GRAY);

    Ptr&lt;SIFT&gt; detector = SIFT::create(nfeatrues, nOctaveLayers, contrastThreshold, edgeThreshold, sigma, CV_32F);
    detector-&gt;detectAndCompute(img_gray, Mat(), keypoints, description, false);

    return 1;
&#125;

int FeatureDetection::Surf(
    const Mat&amp; img,
    vector&lt;KeyPoint&gt;&amp; keypoints,
    Mat&amp; description,
    const double&amp; hessianThreshold,
    const int&amp; nOctaves,
    const int&amp; nOctaveLayers
) &#123;
    Mat img_gray;
    cvtColor(img, img_gray, COLOR_RGB2GRAY);

    Ptr&lt;SURF&gt; detector = SURF::create(hessianThreshold, nOctaves, nOctaveLayers);
    detector-&gt;detectAndCompute(img_gray, noArray(), keypoints, description);
    return 1;
&#125;

int FeatureMatching::Brute_force(
    const Mat&amp; description1,
    const Mat&amp; description2,
    vector&lt;DMatch&gt;&amp; matches,
    const float&amp; ratio_thresh
) &#123;
    vector&lt;vector&lt;DMatch&gt;&gt; all_matches;
    BFMatcher BF_matcher(NORM_L2);
    BF_matcher.knnMatch(description1, description2, all_matches, 2);

    float mindistance = FLT_MAX;
    for (int i = 0; i &lt; all_matches.size(); i++) &#123;
        if (all_matches[i][0].distance &gt; ratio_thresh * all_matches[i][1].distance) &#123;
            continue;
        &#125;

        float distance = all_matches[i][0].distance;
        if (distance &lt; mindistance) &#123;
            mindistance = distance;
        &#125;
    &#125;

    vector&lt;DMatch&gt; good_matches;
    for (int j = 0; j &lt; all_matches.size(); j++) &#123;
        if (all_matches[j][0].distance &gt; ratio_thresh * all_matches[j][1].distance ||
            all_matches[j][0].distance &gt; 5 * mindistance) &#123;
            continue;
        &#125;

        good_matches.push_back(all_matches[j][0]);
    &#125;
    matches = good_matches;
    return 1;
&#125;

void FeatureMatching::showMatches(
    const Mat&amp; img1,
    const vector&lt;KeyPoint&gt;&amp; keypoints1,
    const Mat&amp; img2,
    const vector&lt;KeyPoint&gt;&amp; keypoints2,
    const vector&lt;DMatch&gt;&amp; matches
) &#123;
    // Draw matches
    Mat img_matches;
    //原始图像尺寸太大，需要适当缩放
    Mat mat1, mat2;
    resize(img1, mat1, Size(), 0.15, 0.15);
    resize(img2, mat2, Size(), 0.15, 0.15);
    vector&lt;KeyPoint&gt; kpts1 = keypoints1;
    vector&lt;KeyPoint&gt; kpts2 = keypoints2;
    for (int i = 0; i &lt; kpts1.size(); i++) &#123;
        kpts1[i].pt *= 0.15;
    &#125;
    for (int i = 0; i &lt; kpts2.size(); i++) &#123;
        kpts2[i].pt *= 0.15;
    &#125;

    //生成绘制匹配结果的图像
    drawMatches(mat1, kpts1, mat2, kpts2, matches, img_matches, Scalar::all(-1),
        Scalar::all(-1), vector&lt;char&gt;(), DrawMatchesFlags::NOT_DRAW_SINGLE_POINTS);

    //Show detected matches
    string win_str = &quot;Matches&quot;;
    namedWindow(win_str, WINDOW_NORMAL);
    resizeWindow(win_str, img_matches.cols, img_matches.rows);
    imshow(&quot;Matches&quot;, img_matches);
&#125;

int FeatureMatching::FLANN_based(
    const Mat&amp; description1,
    const Mat&amp; description2,
    vector&lt;DMatch&gt;&amp; matches,
    const float&amp; ratio_thresh
) &#123;
    vector &lt;vector&lt;DMatch&gt;&gt; all_matches;
    Ptr&lt;DescriptorMatcher&gt; FB_matcher = DescriptorMatcher::create(DescriptorMatcher::FLANNBASED);
    FB_matcher-&gt;knnMatch(description1, description2, all_matches, 2);

    float mindistance = FLT_MAX;
    for (int i = 0; i &lt; all_matches.size(); i++) &#123;
        if (all_matches[i][0].distance &gt; ratio_thresh * all_matches[i][1].distance) &#123;
            continue;
        &#125;

        float distance = all_matches[i][0].distance;
        if (distance &lt; mindistance) &#123;
            mindistance = distance;
        &#125;
    &#125;

    vector&lt;DMatch&gt; good_matches;
    for (int j = 0; j &lt; all_matches.size(); j++) &#123;
        if (all_matches[j][0].distance &gt; ratio_thresh * all_matches[j][1].distance ||
            all_matches[j][0].distance &gt; 5 * mindistance) &#123;
            continue;
        &#125;

        good_matches.push_back(all_matches[j][0]);
    &#125;
    matches = good_matches;
    return 1;
&#125;
</code></pre>
<h1 id="image-orientation-h"><a href="#image-orientation-h" class="headerlink" title="image_orientation.h"></a>image_orientation.h</h1><pre><code class="lang-c++">#pragma once

#include &quot;image.h&quot;

class RelativeOrientation &#123;

public:
    int ContinuousMethod(
        const Image&amp; imgL,                    //左像
        const Image&amp; imgR,                    //右像
        const vector&lt;Vector2d&gt;&amp; pixelPtsL,    //左像上的特征点
        const vector&lt;Vector2d&gt;&amp; pixelPtsR,    //右像上的特征点
        Mat&amp; rR,                            //右像相对于左像的旋转矩阵
        Vector3d&amp; rT                        //右像相对于左像的平移参数
    );

    int IndependentMethod(
        const Image&amp; imgL,                    //左像
        const Image&amp; imgR,                    //右像
        const vector&lt;Vector2d&gt;&amp; pixelPtsL,    //左像上的特征点
        const vector&lt;Vector2d&gt;&amp; pixelPtsR,    //右像上的特征点
        Mat&amp; rR,                            //右像相对于左像的旋转矩阵
        Vector3d&amp; rT                        //右像相对于左像的平移参数
    );

    int cv(
        const Image&amp; imgL,
        const Image&amp; imgR,
        const vector&lt;Vector2d&gt;&amp; pixelPtsL,
        const vector&lt;Vector2d&gt;&amp; pixelPtsR,
        Mat&amp; rR,
        Vector3d&amp; rT
    );
&#125;;
</code></pre>
<h1 id="image-orientation-cpp"><a href="#image-orientation-cpp" class="headerlink" title="image_orientation.cpp"></a>image_orientation.cpp</h1><pre><code class="lang-c++">#include &quot;image_orientation.h&quot;
#include &lt;opencv2/calib3d.hpp&gt;

int RelativeOrientation::cv(
    const Image&amp; imgL,
    const Image&amp; imgR,
    const vector&lt;Vector2d&gt;&amp; pixelPtsL,
    const vector&lt;Vector2d&gt;&amp; pixelPtsR,
    Mat&amp; rR,
    Vector3d&amp; rT
) &#123;
    if (pixelPtsL.size() != pixelPtsR.size()) &#123;
        return 0;
    &#125;

    //假设左右影像为同一传感器拍摄的影像，即具有相同的内参
    double focal_length = imgL.io_.focal_ / imgL.pixel_size_;
    Point2d principle_point = Point2d(imgL.io_.cx_, imgL.io_.cy_);

    vector&lt;Point2d&gt; pts1(pixelPtsL.size()), pts2(pixelPtsR.size());
    for (int i = 0; i &lt; pixelPtsL.size(); i++) &#123;
        pts1[i] = Point2d(pixelPtsL[i].x(), pixelPtsL[i].y());
        pts2[i] = Point2d(pixelPtsR[i].x(), pixelPtsR[i].y());
    &#125;

    //计算本征矩阵
    Mat mask;
    Mat E = cv::findEssentialMat(pts1, pts2, focal_length, principle_point,
        RANSAC, 0.9999, 1.0, mask);
    if (E.empty()) &#123;
        return 0;
    &#125;

    double feasible_count = cv::countNonZero(mask);
    //对于RANSAC来说，outlier的数量大于50%时，结果是不可靠的
    if (feasible_count / pixelPtsL.size() &lt; 0.5) &#123;
        return 0;
    &#125;

    //分解本征矩阵，获取相对变换
    Mat R, t;
    int pass_count = cv::recoverPose(E, pts1, pts2, R, t, focal_length, principle_point, mask);
    //同时，位于两个相机前方的点数量要足够大
    if (((double)pass_count) / feasible_count &lt; 0.7) &#123;
        return 0;
    &#125;

    R.copyTo(rR);
    rT = Vector3d(t.at&lt;double&gt;(0, 0), t.at&lt;double&gt;(1, 0), t.at&lt;double&gt;(2, 0));

    //这里的rR和rT满足CV里的坐标转换关系，即
    //            | x2 |            | x1 |
    //            | y2 |    = R *    | y1 | + t
    //            | z2 |            | z1 |     
    return 1;
&#125;
</code></pre>
<h1 id="forword-intersection-h"><a href="#forword-intersection-h" class="headerlink" title="forword_intersection.h"></a>forword_intersection.h</h1><pre><code class="lang-c++">#pragma once

#include &quot;image.h&quot;

class ForwardIntersection
&#123;
public:
    ForwardIntersection() &#123;&#125;;
    ~ForwardIntersection() &#123;&#125;;

private:
    Mat_&lt;double&gt; LinearLSTriangulation(
        Point3d u,
        Matx34d P,
        Point3d u1,
        Matx34d P1)
    &#123;
        //build matrix A for homogenous equation system Ax = 0
        //assume X = (x,y,z,1), for Linear-LS method
        //which turns it into a AX = B system, where A is 4x3, X is 3x1 and B is 4x1
        Matx43d A(u.x * P(2, 0) - P(0, 0), u.x * P(2, 1) - P(0, 1), u.x * P(2, 2) - P(0, 2),
            u.y * P(2, 0) - P(1, 0), u.y * P(2, 1) - P(1, 1), u.y * P(2, 2) - P(1, 2),
            u1.x * P1(2, 0) - P1(0, 0), u1.x * P1(2, 1) - P1(0, 1), u1.x * P1(2, 2) - P1(0, 2),
            u1.y * P1(2, 0) - P1(1, 0), u1.y * P1(2, 1) - P1(1, 1), u1.y * P1(2, 2) - P1(1, 2)
        );
        Mat_&lt;double&gt; B = (Mat_&lt;double&gt;(4, 1) &lt;&lt; -(u.x * P(2, 3) - P(0, 3)),
            -(u.y * P(2, 3) - P(1, 3)),
            -(u1.x * P1(2, 3) - P1(0, 3)),
            -(u1.y * P1(2, 3) - P1(1, 3)));

        Mat_&lt;double&gt; X;
        solve(A, B, X, DECOMP_SVD);

        return X;
    &#125;

    Mat_&lt;double&gt; IterativeLinearLSTriangulation(
        Point3d u,
        Matx34d P,
        Point3d u1,
        Matx34d P1)
    &#123;

        double wi = 1, wi1 = 1;
        Mat_&lt;double&gt; X(4, 1);

        for (int i = 0; i &lt; 10; i++)
        &#123;
            //Hartley suggests 10 iterations at most
            Mat_&lt;double&gt; X_ = LinearLSTriangulation(u, P, u1, P1);
            X(0) = X_(0); X(1) = X_(1); X(2) = X_(2); X(3) = 1.0;

            //recalculate weights
            double p2x = Mat_&lt;double&gt;(Mat_&lt;double&gt;(P).row(2) * X)(0);
            double p2x1 = Mat_&lt;double&gt;(Mat_&lt;double&gt;(P1).row(2) * X)(0);

            //breaking point
            if (fabsf(wi - p2x) &lt;= 0.000001 &amp;&amp; fabsf(wi1 - p2x1) &lt;= 0.000001) break;

            wi = p2x;
            wi1 = p2x1;

            //reweight equations and solve
            Matx43d A((u.x * P(2, 0) - P(0, 0)) / wi, (u.x * P(2, 1) - P(0, 1)) / wi, (u.x * P(2, 2) - P(0, 2)) / wi,
                (u.y * P(2, 0) - P(1, 0)) / wi, (u.y * P(2, 1) - P(1, 1)) / wi, (u.y * P(2, 2) - P(1, 2)) / wi,
                (u1.x * P1(2, 0) - P1(0, 0)) / wi1, (u1.x * P1(2, 1) - P1(0, 1)) / wi1, (u1.x * P1(2, 2) - P1(0, 2)) / wi1,
                (u1.y * P1(2, 0) - P1(1, 0)) / wi1, (u1.y * P1(2, 1) - P1(1, 1)) / wi1, (u1.y * P1(2, 2) - P1(1, 2)) / wi1
            );
            Mat_&lt;double&gt; B = (Mat_&lt;double&gt;(4, 1) &lt;&lt; -(u.x * P(2, 3) - P(0, 3)) / wi,
                -(u.y * P(2, 3) - P(1, 3)) / wi,
                -(u1.x * P1(2, 3) - P1(0, 3)) / wi1,
                -(u1.y * P1(2, 3) - P1(1, 3)) / wi1
                );

            solve(A, B, X_, DECOMP_SVD);
            X(0) = X_(0); X(1) = X_(1); X(2) = X_(2); X(3) = 1.0;
        &#125;

        return X;
    &#125;
public:
    int cv(
        const Image&amp; imgL,
        const Image&amp; imgR,
        const Mat&amp; RcvL,
        const Mat&amp; RcvR,
        const Mat&amp; TcvL,
        const Mat&amp; TcvR,
        const vector&lt;Vector2d&gt;&amp; pixelPtsL,
        const vector&lt;Vector2d&gt;&amp; pixelPtsR,
        vector&lt;Point3d&gt;&amp; space_pts,
        Mat&amp; mask
    )
    &#123;
        Mat proj1(3, 4, CV_64FC1);
        Mat proj2(3, 4, CV_64FC1);
        double fx = imgL.io_.focal_ / imgL.pixel_size_;
        double fy = fx;
        double cx = imgL.io_.cx_;
        double cy = imgL.io_.cy_;
        Mat K = (cv::Mat_&lt;double&gt;(3, 3) &lt;&lt; fx, 0, cx, 0, fy, cy, 0, 0, 1);

        RcvL.convertTo(proj1(Range(0, 3), Range(0, 3)), CV_64FC1);
        proj1.at&lt;double&gt;(0, 3) = TcvL.at&lt;double&gt;(0);
        proj1.at&lt;double&gt;(1, 3) = TcvL.at&lt;double&gt;(1);
        proj1.at&lt;double&gt;(2, 3) = TcvL.at&lt;double&gt;(2);

        RcvR.convertTo(proj2(Range(0, 3), Range(0, 3)), CV_64FC1);
        proj2.at&lt;double&gt;(0, 3) = TcvR.at&lt;double&gt;(0);
        proj2.at&lt;double&gt;(1, 3) = TcvR.at&lt;double&gt;(1);
        proj2.at&lt;double&gt;(2, 3) = TcvR.at&lt;double&gt;(2);

        // triangulate points
        int pts_size = pixelPtsL.size();
        space_pts.resize(pixelPtsL.size());
        for (int i = 0; i &lt; pts_size; i++)
        &#123;
            Point2f kp = Point2f(pixelPtsL[i].x(), pixelPtsL[i].y());
            Point3d u1(kp.x, kp.y, 1.0);
            Mat_&lt;double&gt; um1 = K.inv() * Mat_&lt;double&gt;(u1);
            u1 = Point3d(um1.at&lt;double&gt;(0), um1.at&lt;double&gt;(1), um1.at&lt;double&gt;(2));
            Point2f kp1 = Point2f(pixelPtsR[i].x(), pixelPtsR[i].y());
            Point3d u2(kp1.x, kp1.y, 1.0);
            Mat_&lt;double&gt; um2 = K.inv() * Mat_&lt;double&gt;(u2);
            u2 = Point3d(um2.at&lt;double&gt;(0), um2.at&lt;double&gt;(1), um2.at&lt;double&gt;(2));

            Mat_&lt;double&gt; X = IterativeLinearLSTriangulation(u1, proj1, u2, proj2);
            space_pts[i] = Point3d(X(0), X(1), X(2));
        &#125;

        int fail_count = 0;
        mask = cv::Mat::ones(1, space_pts.size(), CV_8UC1);
        for (int i = 0; i &lt; space_pts.size(); i++)
        &#123;
            Mat P = (Mat_&lt;double&gt;(4, 1) &lt;&lt; space_pts[i].x, space_pts[i].y, space_pts[i].z, 1);
            Mat pix1 = K * proj1 * P;
            pix1 /= pix1.at&lt;double&gt;(2);

            Mat pix2 = K * proj2 * P;
            pix2 /= pix2.at&lt;double&gt;(2);

            double d1 = (pix1.at&lt;double&gt;(0) - pixelPtsL[i].x()) * (pix1.at&lt;double&gt;(0) - pixelPtsL[i].x()) + (pix1.at&lt;double&gt;(1) - pixelPtsL[i].y()) * (pix1.at&lt;double&gt;(1) - pixelPtsL[i].y());
            double d2 = (pix2.at&lt;double&gt;(0) - pixelPtsR[i].x()) * (pix2.at&lt;double&gt;(0) - pixelPtsR[i].x()) + (pix2.at&lt;double&gt;(1) - pixelPtsR[i].y()) * (pix2.at&lt;double&gt;(1) - pixelPtsR[i].y());

            if (d1 &gt; 2 || d2 &gt; 2) //若反投影到影像上与像点的距离大于2个像素，则判断为失配点
            &#123;
                mask.at&lt;uchar&gt;(i) = 0;
                fail_count++;
            &#125;
        &#125;
        if (fail_count &gt; space_pts.size() * 0.8) //80%以上都失败 返回0
            return 0;

        return 1;
    &#125;
&#125;;
</code></pre>

</div>


    <div class="post-guide">
        <div class="item left">
            
              <a href="/2021/07/12/Java%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">
                  <i class="fa fa-angle-left" aria-hidden="true"></i>
                  设计模式
              </a>
            
        </div>
        <div class="item right">
            
              <a href="/2021/06/21/C++/Visual%20Studio%E6%B7%BB%E5%8A%A0%E5%BA%93/">
                Visual Studio添加库
                <i class="fa fa-angle-right" aria-hidden="true"></i>
              </a>
            
        </div>
    </div>




<script>
	
	
</script>
	</div>
	<div id="footer">
	<p>
	©2019-<span id="footerYear"></span> 
	<a href="/">Regular</a> 
	
	
		|
		<span id="busuanzi_container_site_pv">
			pv
			<span id="busuanzi_value_site_pv"></span>
		</span>
		|
		<span id="busuanzi_container_site_uv"> 
			uv
			<span id="busuanzi_value_site_uv"></span>
		</span>
	
	<br>
	Theme <a href="//github.com/wujun234/hexo-theme-tree" target="_blank">Tree</a>
	by <a href="//github.com/wujun234" target="_blank">WuJun</a>
	Powered by <a href="//hexo.io" target="_blank">Hexo</a>
	</p>
</div>
<script type="text/javascript"> 
	document.getElementById('footerYear').innerHTML = new Date().getFullYear() + '';
</script>
	<button id="totop-toggle" class="toggle"><i class="fa fa-angle-double-up" aria-hidden="true"></i></button>
</body>
</html>