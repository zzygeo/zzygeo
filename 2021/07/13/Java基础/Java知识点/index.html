<!DOCTYPE html>
<html lang="en">

<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8">
	<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
	
	<!-- title -->
	
	<title>
	
		Java知识点 | 
	 
	立志做个全栈
	</title>
	
	<!-- keywords,description -->
	 

	<!-- favicon -->
	
	<link rel="shortcut icon" href="/favicon.ico">
	


	<!-- search -->
	<script>
		var searchEngine = "https://www.google.com/search?q=";
		if(typeof searchEngine == "undefined" || searchEngine == null || searchEngine == ""){
			searchEngine = "https://www.google.com/search?q=";
		}
		var homeHost = "zzygeo.cn";
		if(typeof homeHost == "undefined" || homeHost == null || homeHost == ""){
			homeHost = window.location.host;
		}
	</script>


	
<link rel="stylesheet" href="/css/main.css">

	
<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css">

	
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.17.1/build/styles/darcula.min.css">

	
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">


	
<script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>

	
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>

	
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.17.1/build/highlight.min.js"></script>

	
<script src="https://cdn.jsdelivr.net/npm/jquery-pjax@2.0.1/jquery.pjax.min.js"></script>

	
<script src="/js/main.js"></script>

	
		
<script src="https://cdn.jsdelivr.net/npm/leancloud-storage/dist/av-min.js"></script>

		
<script src="https://cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js"></script>

	
	
		<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	
<meta name="generator" content="Hexo 5.2.0"><link rel="alternate" href="/atom.xml" title="立志做个全栈" type="application/atom+xml">
</head>

<body>
	<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?3efe99c287df5a1d6f0d02d187e403c1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

<header id="header">
    <a id="title" href="/" class="logo">立志做个全栈</a>

	<ul id="menu">
		<li class="menu-item">
			<a href="/about" class="menu-item-link">ABOUT</a>
		</li>
	

	
		<li class="menu-item">
			<a href="/categories" class="menu-item-link">分类</a>
		</li>
	

		<li class="menu-item">
			<a href="https://github.com/wujun234/uid-generator-spring-boot-starter" class="menu-item-link" target="_blank">
				UidGenerator
			</a>
		</li>
		<li class="menu-item">
			<a href="https://github.com/zzygeo" class="menu-item-link" target="_blank">
				<i class="fa fa-github fa-2x"></i>
			</a>
		</li>
	</ul>
</header>

	
<div id="sidebar">
	<button id="sidebar-toggle" class="toggle" ><i class="fa fa-arrow-right " aria-hidden="true"></i></button>
	
	<div id="site-toc">
		<input id="search-input" class="search-input" type="search" placeholder="按回车全站搜索">
		<div id="tree">
			

			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										C++
									</a>
									
							<ul>
								<li class="file">
									<a href="/2021/05/31/C++/C++%E7%9F%A5%E8%AF%86%E7%82%B9/">
										C++知识点
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2021/06/21/C++/Visual%20Studio%E6%B7%BB%E5%8A%A0%E5%BA%93/">
										Visual Studio添加库
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2021/06/29/C++/%E6%91%84%E5%BD%B1%E6%B5%8B%E9%87%8F/">
										摄影测量
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										Cesium
									</a>
									
							<ul>
								<li class="file">
									<a href="/2021/06/10/Cesium/Cesiun%E5%AD%A6%E4%B9%A0/">
										Cesiun学习
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										Hexo
									</a>
									
							<ul>
								<li class="file">
									<a href="/2021/01/20/Hexo/github%E8%AE%BE%E7%BD%AE%E8%87%AA%E5%B7%B1%E7%9A%84%E5%9F%9F%E5%90%8D/">
										github设置自己的域名
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/10/02/Hexo/hexo-d-%E5%87%BA%E7%8E%B0%E9%94%99%E8%AF%AF%E7%9A%84%E7%94%A8%E6%88%B7%E5%90%8D%E5%92%8C%E5%AF%86%E7%A0%81%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/">
										hexo-d-出现错误的用户名和密码的解决办法
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/09/24/Hexo/markdown%E8%AF%AD%E6%B3%95/">
										markdown语法
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/10/02/Hexo/%E6%96%B0%E7%94%B5%E8%84%91%E4%B8%8A%E9%83%A8%E7%BD%B2hexo/">
										新电脑上部署hexo
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										Java基础
									</a>
									
							<ul>
								<li class="file">
									<a href="/2021/05/24/Java%E5%9F%BA%E7%A1%80/IDEA%E5%BF%AB%E6%8D%B7%E9%94%AE/">
										IDEA快捷键
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file active">
									<a href="/2021/07/13/Java%E5%9F%BA%E7%A1%80/Java%E7%9F%A5%E8%AF%86%E7%82%B9/">
										Java知识点
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2021/07/12/Java%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">
										设计模式
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										PCL
									</a>
									
							<ul>
								<li class="file">
									<a href="/2020/10/04/PCL/PCL-1-11-Visual-Studio-2019-%E9%85%8D%E7%BD%AE/">
										PCL-1-11-Visual-Studio-2019-配置
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/12/27/PCL/pcl-vs-cmake%E7%BC%96%E8%AF%91/">
										pcl-vs-cmake编译
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										Ubuntu
									</a>
									
							<ul>
								<li class="file">
									<a href="/2021/03/14/Ubuntu/Ubuntu%E6%9B%B4%E6%8D%A2%E6%BA%90%E6%95%99%E7%A8%8B/">
										Ubuntu更换源教程
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/10/23/Ubuntu/Unable-to-access-https-gitee-com-%E8%87%AA%E5%B7%B1%E7%9A%84%E9%A1%B9%E7%9B%AE-Could-not-resolve-host-gitee-com%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3/">
										Unable-to-access-https-gitee-com-自己的项目-Could-not-resolve-host-gitee-com问题的解决
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2021/03/14/Ubuntu/dpkg%E8%A2%AB%E4%B8%AD%E6%96%AD%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/">
										dpkg被中断的解决办法
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2021/03/14/Ubuntu/ubuntu%E4%B8%8B%E7%9A%84firefox%E6%97%A0%E6%B3%95%E6%92%AD%E6%94%BE%E8%A7%86%E9%A2%91%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">
										ubuntu下的firefox无法播放视频解决方案
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2021/03/14/Ubuntu/ubuntu%E4%B8%8B%E8%A7%A3%E5%86%B3wps2019%E7%BC%BA%E5%B0%91%E5%AD%97%E4%BD%93%E9%97%AE%E9%A2%98/">
										ubuntu下解决wps2019缺少字体问题
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2021/03/14/Ubuntu/ubuntu%E5%AE%89%E8%A3%85gcc%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB%E6%8A%A5%E9%94%99/">
										ubuntu安装gcc依赖关系报错
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2021/03/14/Ubuntu/ubuntu%E5%AE%89%E8%A3%85vim%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB%E6%8A%A5%E9%94%99/">
										ubuntu安装vim依赖关系报错
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2021/03/14/Ubuntu/ubuntu%E9%85%8D%E7%BD%AEC-C-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/">
										ubuntu配置C-C-开发环境
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2021/03/14/Ubuntu/%E5%AE%89%E8%A3%85snap/">
										安装snap
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										其他
									</a>
									
							<ul>
								<li class="file">
									<a href="/2020/09/26/%E5%85%B6%E4%BB%96/%E6%88%91%E7%9A%84Office%E6%BF%80%E6%B4%BB%E7%A0%81/">
										我的Office激活码
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/10/04/%E5%85%B6%E4%BB%96/%E8%B5%84%E6%BA%90/">
										资源
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										前端
									</a>
									
							<ul>
								<li class="file">
									<a href="/2021/09/13/%E5%89%8D%E7%AB%AF/ES6-11/">
										ES6-11
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2021/08/25/%E5%89%8D%E7%AB%AF/JS%E7%BB%86%E8%8A%82/">
										JS细节
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2021/08/17/%E5%89%8D%E7%AB%AF/css%E7%BB%86%E8%8A%82/">
										css细节
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2021/07/24/%E5%89%8D%E7%AB%AF/vue%E5%AD%A6%E4%B9%A0/">
										vue学习
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
		</div>
	</div>
</div>

	<!-- 引入正文 -->
	<div id="content">
		<h1 id="article-title">

	Java知识点
</h1>
<div class="article-meta">
	
	<span>Regular</span>
	<span>2021-07-13 16:24:14</span>
		<div id="article-categories">
    
		<span>Categories：</span>
            
                
                    <span>
                        <i class="fa fa-folder" aria-hidden="true">
                        <a href="/categories/Java/">Java</a>
                        </i>
                      
                    </span>
                
            
    

    
		<span>Tags：</span>
            
    
		</div>

</div>

<div id="article-content">
	<h1 id="Java面向对象"><a href="#Java面向对象" class="headerlink" title="Java面向对象"></a>Java面向对象</h1><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口就是制定规范，给出一些没有实现的方法，封装到一起，到某个类要使用的时候，在根据具体情况把这些方法写出来。</p>
<p>在JDK8.0以后，接口可以有静态方法，默认方法。</p>
<p>但是在默认方法前面必须加default关键字</p>
<p>接口细节：</p>
<p>1.接口不可以被实例化</p>
<p>2.接口中的所有方法是public方法，接口中抽象方法，可以不用abstract修饰</p>
<p>3.一个普通类实现接口，就必须将该接口的所有方法都实现</p>
<p>4.抽象类去实现接口时，可以不实现接口的抽象方法</p>
<p>5.一个类同时可以实现多个接口</p>
<p>6.接口中的==属性==，只能是final的，而且是public static final修饰的，如int a =1;实际上是 public static final int a =1;</p>
<p>7.接口不能继承其他的类，但是可以继承多个别的接口</p>
<p>8.接口的修饰符，只能是public和默认，这点和类的修饰符是一样的</p>
<p>接口和类的比较</p>
<p>接口可以理解为是Java对单继承机制的补充</p>
<p>一个先天，一个后天</p>
<pre><code class="lang-java">package com.zzy.interface_;

public class Interface02 &#123;
    public static void main(String[] args) &#123;
        LittleMonkey littleMonkey = new LittleMonkey(&quot;小悟空&quot;);
        littleMonkey.climbing();
        littleMonkey.swimming();
        littleMonkey.flying();
    &#125;
&#125;

class Money &#123;
    private String name;

    public Money(String name) &#123;
        this.name = name;
    &#125;

    public String getName() &#123;
        return name;
    &#125;

    public void climbing() &#123;
        System.out.println( name + &quot;会爬树...&quot;);
    &#125;
&#125;

interface Fishable &#123;
    void swimming();
&#125;

interface Birdable &#123;
    void flying();
&#125;
//继承父类
class LittleMonkey extends Money implements Fishable, Birdable&#123;
    public LittleMonkey(String name) &#123;
        super(name);
    &#125;

    @Override
    public void swimming() &#123;
        System.out.println(getName() + &quot;通过学习，学会了游泳...&quot;);
    &#125;

    @Override
    public void flying() &#123;
        System.out.println(getName() + &quot;通过学习，学会了飞行...&quot;);
    &#125;
&#125;
</code></pre>
<p>接口的动态绑定机制案例</p>
<pre><code class="lang-java">package com.zzy.interface_;

public class InterfaceExercise &#123;
    public static void main(String[] args) &#123;
        Usb_[] usb = new Usb_[2];
        usb[0] = new Iphone_();
        usb[1] = new Camera_();
        for (int i = 0; i &lt; usb.length; i++) &#123;
            if (usb[i] instanceof Iphone_) &#123;
                ((Iphone_) usb[i]).call();
            &#125;
            usb[i].work();
        &#125;
    &#125;
&#125;

interface Usb_ &#123;
    void work();
&#125;

class Iphone_ implements Usb_ &#123;
    @Override
    public void work() &#123;
        System.out.println(&quot;手机开始工作...&quot;);
    &#125;

    public void call() &#123;
        System.out.println(&quot;手机可以打电话...&quot;);
    &#125;
&#125;

class Camera_ implements Usb_ &#123;
    @Override
    public void work() &#123;
        System.out.println(&quot;相机开始工作&quot;);
    &#125;
&#125;
</code></pre>
<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>内部类最大的特点就是可以直接访问私有属性，并且可以体现类与类之间的包含关系</p>
<p>内部类的分类，有4种。</p>
<p>定义在外部类局部位置上（比如方法内）：</p>
<p>1.局部内部类（有类名）</p>
<p>2.匿名内部类（没有类名，重点）</p>
<p>定义在外部类的成员位置上：</p>
<p>1.成员内部类</p>
<p>2.静态内部类</p>
<h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><pre><code class="lang-java">package com.zzy.InnerClass;

public class LocalInnerClass &#123;
    public static void main(String[] args) &#123;
        //演示
        Outer02 outer02 = new Outer02();
        outer02.m1();
        System.out.println(&quot;Outer02的hashcode&quot; + outer02);
    &#125;
&#125;

class Outer02 &#123;
    private int n1 = 100;
    public void m2()&#123;
        System.out.println(&quot;m2()...&quot;);
    &#125;;
    public void m1() &#123;
        //局部内部类是定义在外部类的局部位置，通常在方法
        //不能添加访问修饰符，但是可以使用final修饰，因为局部变量也可以使用final修饰
        //作用域：仅仅在定义它的方法或代码块中
        final class Inner02 &#123;//局部内部类
            //可以直接访问外部类的所有成员，包含私有的
            private int n1 = 800;
            public void f1() &#123;
                //局部内部类可以直接访问外部类的成员
                //如果外部类和局部内部类重名时，默认遵循就近原则，如果想访问外部类的成员
                // 则可以使用外部类名.this.成员
                //这里的Outer02.this就可以理解为对象，谁调用了这个方法，他就代表那个对象
                System.out.println(&quot;n1 = &quot; + n1 + &quot; 外部类的n1 = &quot; + Outer02.this.n1);
                //证明一下这个Outer02.this的地址
                System.out.println(&quot;Outer02.this hashcode = &quot; + Outer02.this);
                m2();
            &#125;
        &#125;

        //外部类在方法中，可以创建Inner02对象，然后调用方法调用
        Inner02 inner02 = new Inner02();
        inner02.f1();
    &#125;
&#125;
</code></pre>
<h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>本质还是类，还是定义在内部的，它是匿名的，系统会给他分配名字，它同时还是一个对象</p>
<pre><code class="lang-java">package com.zzy.InnerClass;

public class AnonymousInnerClass &#123;
    public static void main(String[] args) &#123;
        //1.接口的匿名内部类
        //原因：当只调用对象一次时，进行接口实现，若存在多个，则会造成多个对象创建，浪费资源
        //因此需要用匿名内部类进行简化。
        //编译类型看左边：A     运行类型其实是匿名内部类,为外部类$1(系统分配)
        //jdk底层在创建匿名内部类时，立马就创建了其实例，并把地址返回给 tiger
        //匿名内部类使用一次，就不能再使用
        A tiger = new A() &#123;
            @Override
            public void cry() &#123;
                System.out.println(&quot;老虎在叫唤...&quot;);
            &#125;
        &#125;;
        //输出其运行类型采用getclass()方法
        System.out.println(&quot;tiger的运行类型为&quot; + tiger.getClass());
        tiger.cry();


        //2.基于类的匿名内部类
        //编译类型：Father，运行类型是匿名内部类
        //同时也返回了匿名内部类的对象
        //这里的Jack会传给father的构造器
        Father father = new Father(&quot;Jack&quot;) &#123;
            @Override
            public void test() &#123;
                System.out.println(&quot;匿名内部类重写了test方法...&quot;);
            &#125;
        &#125;;
        System.out.println(&quot;father对象的运行类型为 &quot; + father.getClass());
        father.test();
    &#125;
&#125;

class Outer03 &#123;
    private int n1 =10;

    public void method() &#123;
    &#125;

&#125;

interface A &#123;
    //基于接口的匿名内部类
    public void cry();
&#125;

class Father &#123;
    //基于类的匿名内部类
    public Father(String name) &#123;

    &#125;

    public void test() &#123;

    &#125;
&#125;
</code></pre>
<p>匿名内部类的两种创建方法及细节</p>
<pre><code class="lang-java">package com.zzy.InnerClass;

public class AnonymousInnerClass01 &#123;
    public static void main(String[] args) &#123;
        Outer04 outer04 = new Outer04();
        outer04.f1();
        System.out.println(&quot;外部的hashcode = &quot; + outer04);
    &#125;
&#125;

class Outer04 &#123;
    private int n1 =99;
    public void f1() &#123;
        //创建一个基于类的匿名内部类
        //第一种调用方法
        //不能添加访问修饰符，因为它的地位就是一个局部变量
        //作用域：仅仅是在方法或者代码块中
        Person p = new Person() &#123;
            private int n1 =88;
            @Override
            public void hi() &#123;
                //可以直接访问外部类的所有成员，包含私有的
                //如果外部类和匿名内部类的成员重名时，匿名内部类访问的话，
                //默认遵循就近原则，如果想访问外部类的成员，则可以使用(外部类名.this.成员)去访问
                System.out.println(&quot;匿名内部类重写了hi()方法...&quot;);
                System.out.println(&quot;n1 = &quot; + n1);//访问内部的n1
                System.out.println(&quot;外部n1 = &quot; + Outer04.this.n1);
                System.out.println(&quot;内部的hashcode = &quot; + Outer04.this);
            &#125;
        &#125;;
        p.hi();//动态绑定机制

        //第二种调用方法
        new Person() &#123;
            @Override
            public void hi() &#123;
                System.out.println(&quot;匿名内部类重写了hi()方法,第二种...&quot;);
            &#125;
        &#125;.hi();

        new Person() &#123;
            @Override
            public void ok(String name) &#123;
                System.out.println(&quot;重写了&quot; + name);
            &#125;
        &#125;.ok(&quot;Jack&quot;);
    &#125;
&#125;

class Person &#123;
    public void hi() &#123;
        System.out.println(&quot;Person hi()&quot;);
    &#125;

    public void ok(String name) &#123;
        System.out.println(&quot;Person ok() &quot; + name);
    &#125;
&#125;
</code></pre>
<p>匿名内部类的实践</p>
<pre><code class="lang-java">package com.zzy.InnerClass;

public class InnerClassExercise02 &#123;
    public static void main(String[] args) &#123;
        CellPhone cellPhone = new CellPhone();
        cellPhone.alarmClock(new Bell() &#123;
            @Override
            public void ring() &#123;
                System.out.println(&quot;懒猪起床了...&quot;);
            &#125;
        &#125;);
        //在这里，编译类型是匿名内部类，重写了ring方法
        cellPhone.alarmClock(new Bell() &#123;
            @Override
            public void ring() &#123;
                System.out.println(&quot;小伙伴上课了...&quot;);
            &#125;
        &#125;);
    &#125;
&#125;

interface Bell &#123;
    public void ring();
&#125;

class CellPhone &#123;
    public void alarmClock(Bell bell) &#123;
        System.out.println(bell.getClass());
        bell.ring();//动态绑定机制
    &#125;
&#125;
</code></pre>
<h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><p>成员内部类是定义在外部类的成员位置，并且没有static修饰</p>
<pre><code class="lang-java">package com.zzy.InnerClass;

import java.util.PrimitiveIterator;

public class MemberInnerClass01 &#123;
    public static void main(String[] args) &#123;
        Outer05 outer05 = new Outer05();
        outer05.m1();

        //外部其他类，使用成员内部类的三种方法
        //第一种方法
        Outer05.Inner05 inner05 = outer05.new Inner05();
        inner05.say();

        //第二种方式，在外部类中，编写一个方法，可以返回Inner08对象
        Outer05.Inner05 inner05instance = outer05.getInner05Instance();
        inner05instance.say();

        //第三种方式
        Outer05.Inner05 inner05_ = new Outer05().new Inner05();
        inner05_.say();
    &#125;
&#125;

class Outer05 &#123;
    private int n1 = 10;
    public String name = &quot;张三&quot;;
    //可以添加任意访问修饰符(public、protected、默认、private),因为它的地位就是一个成员
    //作用域：和外部类的其他成员一样，为整个类体
    public class Inner05 &#123;//成员内部类
        private int n1 =66;
        private String name = &quot;李四&quot;;
        public void say() &#123;
            //可以直接访问外部类的所有成员，包含私有的
            //如果成员内部类的成员和外部类的成员重名,会遵守就近原则。
            System.out.println(&quot;成员内部类的n1 = &quot; + n1 + &quot; 成员内部类类的name = &quot; + name);
            System.out.println(&quot;外部类n1=&quot; + Outer05.this.n1 + &quot; 外部类的name=&quot; + Outer05.this.name);
        &#125;
    &#125;
    //方法，返回一个Inner05的实例
    public Inner05 getInner05Instance() &#123;
        return new Inner05();
    &#125;
    //调用成员内部类
    public void m1() &#123;
        Inner05 inner05 = new Inner05();
        inner05.say();
    &#125;
&#125;
</code></pre>
<h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><pre><code class="lang-java">package com.zzy.InnerClass;

public class StaticInnerClass01 &#123;
    public static void main(String[] args) &#123;
        Outer6 outer6 = new Outer6();
        outer6.m1();

        //外部其他类使用静态内部类
        //方式1
        //因为静态内部类，是可以通过类名直接访问
        Outer6.Inner6 inner6 = new Outer6.Inner6();
        inner6.say();

        //方式2，编写一个普通方法，可以返回静态内部类的对象实例
        Outer6.Inner6 inner6_ = outer6.getInner6();
        inner6_.say();

        //方式3，编写一个静态方法
        Outer6.Inner6 inner6_1 = Outer6.getInner6_();
        inner6_1.say();
    &#125;
&#125;

class Outer6 &#123;
    private int n1 =10;
    private static String name = &quot;张三&quot;;
    //静态内部类
    //放在外部类的成员位置，有static修饰
    //可以添加任意的修饰符，因为它的地位就是一个成员
    //作用域：整个类体
    static class Inner6 &#123;
        private static String name = &quot;zzy学java&quot;;
        public void say() &#123;
            //可以直接访问外部类的所有静态成员，包含私有的，但不能访问非静态成员
            //如果成员内部类的成员和外部类的成员重名,会遵守就近原则。但访问外部类不用加this了
            System.out.println(name);
            System.out.println(Outer6.name);
        &#125;
    &#125;

    public Inner6 getInner6() &#123;
        return new Inner6();
    &#125;

    public static Inner6 getInner6_() &#123;
        return new Inner6();
    &#125;
    //外部内调用
    public void m1() &#123;
        Inner6 inner6 = new Inner6();
        inner6.say();
    &#125;
&#125;
</code></pre>
<h2 id="枚举和注解"><a href="#枚举和注解" class="headerlink" title="枚举和注解"></a>枚举和注解</h2><p>自定义实现枚举</p>
<p>1.构造器私有化</p>
<p>2.本类内部创建一组对象</p>
<p>3.对外暴露对象（添加public final static修饰符）</p>
<p>4.可以提供get方法，但是不要提供set方法。</p>
<pre><code class="lang-java">package com.zzy.enum_;

/**
 * @autho: 周钟炎
 * @version: 1.0
 */
public class Enum02 &#123;
    public static void main(String[] args) &#123;
        System.out.println(Season_.AUTUMN);
    &#125;
&#125;

//自定义枚举实现
class Season_ &#123;
    private String name;
    private String desc;

    //1.将构造器私有化
    //2.去掉set方法
    //3.在Season内部，直接创建固定的对象

    //定义了四个对象
    public final static Season_ SPRING = new Season_(&quot;春天&quot;, &quot;温暖&quot;);
    public final static Season_ SUMMER = new Season_(&quot;夏天&quot;, &quot;炎热&quot;);
    public final static Season_ AUTUMN = new Season_(&quot;秋天&quot;, &quot;凉爽&quot;);
    public final static Season_ WINTER = new Season_(&quot;冬天&quot;, &quot;寒冷&quot;);
    private Season_(String name, String desc) &#123;
        this.name = name;
        this.desc = desc;
    &#125;

    public String getName() &#123;
        return name;
    &#125;

    public String getDesc() &#123;
        return desc;
    &#125;

    @Override
    public String toString() &#123;
        return &quot;Season_&#123;&quot; +
                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +
                &quot;, desc=&#39;&quot; + desc + &#39;\&#39;&#39; +
                &#39;&#125;&#39;;
    &#125;
&#125;
</code></pre>
<p>关键字实现枚举</p>
<p>主要是对类的创建做了简化。</p>
<pre><code class="lang-java">package com.zzy.enum_;

/**
 * @autho: 周钟炎
 * @version: 1.0
 */
public class Enum03 &#123;
    public static void main(String[] args) &#123;
        System.out.println(Season1.SPRING);
    &#125;
&#125;
//关键字实现枚举
enum Season1 &#123;
    //使用关键字来实现enum
    //1.使用关键字enum替代class
    //2.按照下面的写法，如果有多个常量，使用,间隔即可
    //3.如果使用enum来实现枚举，要求将定义常量对象写在最前面
    SPRING(&quot;春天&quot;, &quot;温暖&quot;),
    SUMMER(&quot;夏天&quot;, &quot;炎热&quot;);
    private String name;
    private String desc;
    private Season1(String name, String desc) &#123;
        this.name = name;
        this.desc = desc;
    &#125;

    public String getName() &#123;
        return name;
    &#125;

    public String getDesc() &#123;
        return desc;
    &#125;

    @Override
    public String toString() &#123;
        return &quot;Season_&#123;&quot; +
                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +
                &quot;, desc=&#39;&quot; + desc + &#39;\&#39;&#39; +
                &#39;&#125;&#39;;
    &#125;
&#125;
</code></pre>
<p>==Javap可以将编译的class文件反编译，从而看到一些重要的信息。==</p>
<p>枚举练习</p>
<pre><code class="lang-java">package com.zzy.enum_;

/**
 * @autho: 周钟炎
 * @version: 1.0
 */
public class EnumExercise &#123;
    public static void main(String[] args) &#123;
        Gender boy = Gender.BOY;
        Gender bou2 = Gender.BOY;
        //所有的enum类都继承了Enum类，它的toString方法返回的是名字
        System.out.println(boy);
        System.out.println(boy == bou2);
    &#125;
&#125;

enum Gender&#123;
    BOY,GIRL;
&#125;
</code></pre>
<p>枚举方法的使用:</p>
<pre><code class="lang-java">package com.zzy.enum_;

/**
 * @autho: 周钟炎
 * @version: 1.0
 */
public class EnumMethod &#123;
    //演示Enum类的各种方法的使用
    public static void main(String[] args) &#123;
        Season1 spring = Season1.SPRING;
        //输入枚举变量的名字
        System.out.println(spring.name());
        //输出的是该枚举对象的次序，从0开始编号
        System.out.println(spring.ordinal());
        //从反编译可以看出，values方法,返回Season1[],含有定义的所有枚举对象
        Season1[] values = Season1.values();

        for(Season1 i : values) &#123;//简洁的写法
            System.out.println(&quot;i = &quot; + i);
        &#125;

        //valueof：将字符串转换成枚举对象，要求字符串必须为已有的常量名，否则报异常
        //1.根据你输入的&quot;SUMMER&quot;到Season1的枚举对象去查找
        //2.如果找到了，就返回，如果没找到，就报错
        Season1 summer = Season1.valueOf(&quot;SUMMER&quot;);
        System.out.println(&quot;autumn = &quot; + summer);

        //compareTO:比较两个枚举常量，比较的就是编号
        //self.ordinal - other.ordinal
        System.out.println(Season1.SPRING.compareTo(Season1.SUMMER));
    &#125;
&#125;
</code></pre>
<p>枚举练习</p>
<pre><code class="lang-java">package com.zzy.enum_;

/**
 * @autho: 周钟炎
 * @version: 1.0
 */
public class EnumExercise01 &#123;
    public static void main(String[] args) &#123;
        Week[] values = Week.values();
        System.out.println(&quot;所有输出的信息如下：&quot;);
        for (Week i : values) &#123;
            System.out.println(i);
        &#125;
    &#125;
&#125;


enum Week &#123;
    MONDAY(&quot;星期一&quot;),
    TUESDAY(&quot;星期二&quot;),
    WEDNESDAY(&quot;星期三&quot;),
    THURSDAY(&quot;星期四&quot;),
    FRIDAY(&quot;星期五&quot;),
    SATURDAY(&quot;星期六&quot;),
    SUNDAY(&quot;星期日&quot;);
    private String week;
    private Week(String week) &#123;
        this.week = week;
    &#125;

    @Override
    public String toString() &#123;
        return week;
    &#125;
&#125;
</code></pre>
<p>enum细节：</p>
<p>1.使用enum关键词后，就不能再继承其他类了，因为enum会隐式的继承Enum，而Java是单继承机制。</p>
<p>2.枚举类和普通类一样，可以实现接口。</p>
<p>Target是修饰注解的注解，称为元注解。</p>
<p>@Deprecated修饰某个元素，表示该元素已经过时了，即不推荐使用，但是仍然可以使用。</p>
<p>当们不希望看到这些警告的时候，可以使用SuppressWarnings注解来抑制警告信息</p>
<p>元注解：</p>
<p>1.Retention，指定注解的作用范围</p>
<p>2.Target，指定注解可以在哪些地方使用</p>
<p>3.Documented，指定该注解是否会在javadoc体现</p>
<p>4.Inherited，子类会继承父类注解</p>
<p>枚举搭配switch使用：</p>
<pre><code class="lang-java">package com.zzy.annotation;

/**
 * @autho: 周钟炎
 * @version: 1.0
 */
public class Homework07 &#123;
    public static void main(String[] args) &#123;
        Color green = Color.GREEN;
        green.show();

        switch (green) &#123;
            case YELLOW:
                System.out.println(&quot;匹配到黄色...&quot;);
                break;
            case RED:
                System.out.println(&quot;匹配到红色...&quot;);
                break;
            case BLACK:
                System.out.println(&quot;匹配到黑色...&quot;);
                break;
            case BLUE:
                System.out.println(&quot;匹配到蓝色...&quot;);
                break;
            case GREEN:
                System.out.println(&quot;匹配到绿色...&quot;);
                break;
            default:
                System.out.println(&quot;没有匹配到...&quot;);
        &#125;
    &#125;
&#125;

enum Color implements IColor&#123;
    RED(255,0,0),
    BLUE(0,0,255),
    BLACK(0,0,0),
    YELLOW(255,255,0),
    GREEN(0,255,0);
    private int redValue;
    private int greenValue;
    private int blueValue;

    Color(int redValue, int greenValue, int blueValue) &#123;
        this.redValue = redValue;
        this.greenValue = greenValue;
        this.blueValue = blueValue;
    &#125;

    @Override
    public void show() &#123;
        System.out.println(&quot;redValue = &quot; + redValue);
        System.out.println(&quot;redValue = &quot; + greenValue);
        System.out.println(&quot;redValue = &quot; + blueValue);
    &#125;
&#125;

interface IColor &#123;
    abstract void show();
&#125;
</code></pre>
<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><pre><code class="lang-java">//如果程序员，认为一段代码可能出现异常，可以使用try-catch异常处理机制来解决
//从而保证程序的健壮性
//如果进行了异常处理，那么即使出现了异常，程序也可以继续执行
</code></pre>
<p>执行过程中所发生的异常事件可分为两大类</p>
<p>1.Error（错误）：Java虚拟机无法解决的严重问题。如：JVM系统内部错误、资源耗尽等严重情况。</p>
<p>2.Exception:其他因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理。Exception又分为两大类：运行时异常【程序运行时，发生的异常】和编译时异常【编程时，编译器检查出的异常】。</p>
<p>常见的运行时异常：</p>
<p>1.NullPointerException 空指针异常</p>
<p>2.ArithmeticException 数学运算异常</p>
<p>3.ArrayIndexOutOfBoundsException 数组下标越界异常</p>
<p>4.ClassCastException 类型转换异常</p>
<p>5.NumberFormatException 数字格式不正确异常</p>
<h2 id="try-catch异常处理"><a href="#try-catch异常处理" class="headerlink" title="try-catch异常处理"></a>try-catch异常处理</h2><pre><code class="lang-java">package com.zzy.exception_;

/**
 * @autho: 周钟炎
 * @version: 1.0
 */
public class Exception02 &#123;
    public static void main(String[] args) &#123;
        try &#123;//碰到异常以后会跳过后面的代码，直接执行catch块
            //如果异常没有发生，则顺序执行try的代码块，不会进入到catch
            //如果想不管是否发生异常，都执行以下代码，可以用finally
            String str = &quot;zzy学Java&quot;;
            int a = Integer.parseInt(str);
            System.out.println(&quot;数字：&quot; + a);
        &#125; catch (NumberFormatException e) &#123;
            System.out.println(&quot;异常信息 = &quot; + e.getMessage());
        &#125;finally &#123;
            System.out.println(&quot;finally代码块被执行&quot;);
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="lang-java">package com.zzy.exception_;

/**
 * @autho: 周钟炎
 * @version: 1.0
 */
public class Exception03 &#123;
    public static void main(String[] args) &#123;
        //可以使用多个catch分别捕获不同的异常，相应处理
        //但是要求子类异常写在前面，父类异常写在后面
        try &#123;
            Person person = new Person();
            person = null;
            System.out.println(person.name);
            int n1 = 10;
            int n2 = 0;
            int res = n1 / n2;
        &#125; catch (NullPointerException e) &#123;
            System.out.println(&quot;异常信息是：&quot; + e.getMessage());
        &#125;catch (ArithmeticException e) &#123;
            System.out.println(&quot;异常信息是：&quot; + e.getMessage());
        &#125;
        catch (Exception e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
        &#125;
    &#125;
&#125;

class Person &#123;
    public String name = &quot;jack&quot;;

    public String getName() &#123;
        return name;
    &#125;
&#125;
</code></pre>
<p>可以使用try-finally配合使用，这种用法相当于没有捕获异常，因为程序会崩溃。应用场景一般是执行一段代码，不管是否发生异常，都必须执行某个业务逻辑。</p>
<p>异常处理练习题：</p>
<pre><code class="lang-java">package com.zzy.exception_;

/**
 * @autho: 周钟炎
 * @version: 1.0
 */
public class ExceptionExercise &#123;
    public static int method() &#123;
        int i = 1;
        try &#123;
            i++;
            String[] names = new String[3];
            if (names[1].equals(&quot;tom&quot;)) &#123;
                System.out.println(names[1]);
            &#125;else &#123;
                names[3] = &quot;hspedu&quot;;
            &#125;
            return 1;
        &#125;catch (ArrayIndexOutOfBoundsException e) &#123;
            return 2;
        &#125;catch (NullPointerException e) &#123;
            return ++i; //这里的i会被传给临时变量，最后再返回这个临时变量
        &#125;finally &#123;
            ++i;
            System.out.println(&quot;i = &quot; + i);
        &#125;
    &#125;

    public static void main(String[] args) &#123;
        System.out.println(method());
    &#125;
&#125;
</code></pre>
<p>利用异常控制输入：</p>
<pre><code class="lang-java">package com.zzy.exception_;

import java.util.Scanner;

/**
 * @autho: 周钟炎
 * @version: 1.0
 */
public class ExceptionExercise01 &#123;
    public static void main(String[] args) &#123;
        Scanner scanner = new Scanner(System.in);
        int num = 0;
        while (true) &#123;
            System.out.println(&quot;请输入一个整数：&quot;);
            try &#123;
                num = Integer.parseInt(scanner.next());
                break;
            &#125; catch (NumberFormatException e) &#123;
                System.out.println(&quot;你输入的不是一个整数...&quot;);
            &#125;
        &#125;
        System.out.println(&quot;你输入的值：&quot; + num);
    &#125;
&#125;
</code></pre>
<h2 id="throws异常处理"><a href="#throws异常处理" class="headerlink" title="throws异常处理"></a>throws异常处理</h2><p>1.如果一个方法可能生成某种异常，但是并不能确定如何处理这种异常，则该方法应显示地声明抛出异常，表明该方法将不对这些异常进行处理，而由该方法的调用者负责处理。</p>
<p>2.在方法声明中用throws语句可以声明抛出异常的列表，throws后面的异常类型可以是方法中产生的异常，也可以是它的父类</p>
<p>细节：</p>
<p>==子类重写父类的方法时，对抛出异常的规定：子类重写的方法，所抛出的异常类型要么和父类一样，要么为父类抛出的异常类型的子类==</p>
<h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><pre><code class="lang-java">package com.zzy.throws_;

/**
 * @autho: 周钟炎
 * @version: 1.0
 */
public class CustomException &#123;
    public static void main(String[] args) &#123;
        int age = 180;
        if (!(age &gt;= 18 &amp;&amp; age &lt;= 120)) &#123;
            //这里可以沟通构造器设置它的信息
            throw new AgeException(&quot;年龄需要在18-120岁之间...&quot;);
        &#125;

        System.out.println(&quot;你的年龄范围正确...&quot;);
    &#125;
&#125;

//一般都继承运行时异常，不然是编译时异常，还需要对它进行处理，程序才能跑起来
class AgeException extends RuntimeException &#123;
    public AgeException(String message) &#123;//构造器
        super(message);
    &#125;
&#125;
</code></pre>
<p>throw和throws的区别</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>意义</th>
<th>位置</th>
<th>后面跟的东西</th>
</tr>
</thead>
<tbody>
<tr>
<td>throws</td>
<td>异常的一种处理方式</td>
<td>方法声明处</td>
<td>异常类型</td>
</tr>
<tr>
<td>throw</td>
<td>自定义异常的关键字</td>
<td>方法体中</td>
<td>异常对象</td>
</tr>
</tbody>
</table>
</div>
<p>异常案例：</p>
<p>==finally输出在throw之前==</p>
<pre><code class="lang-java">package com.zzy.throws_;

/**
 * @autho: 周钟炎
 * @version: 1.0
 */
public class ExceptionExercise &#123;
    public static void main(String[] args) &#123;
        try &#123;
            ReturnExceptionDemo.methodA();
        &#125;catch (Exception e) &#123;
            System.out.println(e.getMessage());
        &#125;

        ReturnExceptionDemo.methodB();
    &#125;
&#125;

class ReturnExceptionDemo &#123;
    static void methodA() &#123;
        try &#123;
            System.out.println(&quot;进入方法A...&quot;);
            //先输出finally里的内容，再throw
            throw new RuntimeException(&quot;制造异常...&quot;);
        &#125; finally &#123;
            System.out.println(&quot;用A方法的finally...&quot;);
        &#125;
    &#125;

    static void methodB() &#123;
        try &#123;
            System.out.println(&quot;进入方法B...&quot;);
            return;
        &#125;finally &#123;
            System.out.println(&quot;调用B方法的finally...&quot;);
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="lang-java">package com.zzy.throws_;

import java.util.Scanner;

/**
 * @autho: 周钟炎
 * @version: 1.0
 */
public class Homework01 &#123;
    public static void main(String[] args) &#123;
        try &#123;
            Scanner scanner = new Scanner(System.in);
            System.out.println(&quot;输入第一个数：&quot;);
            //可能有输入异常
            int num1 = Integer.parseInt(scanner.next());
            System.out.println(&quot;输入第二个数：&quot;);
            int num2 = Integer.parseInt(scanner.next());
            //可能有算数异常
            int res = cal(num1, num2);
            System.out.println(&quot;输出的结果为：&quot; + res);
        &#125; catch (NumberFormatException e) &#123;
            System.out.println(&quot;请输入整数...&quot;);
        &#125; catch (ArithmeticException e) &#123;
            System.out.println(&quot;分母不能为0...&quot;);
        &#125;
    &#125;

    public static int cal(int n1, int n2) &#123;
        return n1 / n2;
    &#125;
&#125;
</code></pre>
<h1 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h1><h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><p>针对8种基本定义相应的引用类型-包装类</p>
<p>boolean、char这两的父类是Object，byte、short、int、long、float、double的父类是Number</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_44707077/article/details/116030063">深入浅出Java包装类_TD230的博客-CSDN博客</a></p>
<h2 id="包装类和-基本数据的转换"><a href="#包装类和-基本数据的转换" class="headerlink" title="包装类和 基本数据的转换"></a>包装类和 基本数据的转换</h2><p>装箱和拆箱</p>
<pre><code class="lang-java">package com.zzy.wrapper;

/**
 * @autho: 周钟炎
 * @version: 1.0
 */
public class Integer01 &#123;
    public static void main(String[] args) &#123;
        //int-&gt;Integer的装箱和拆箱
        //jdk5前是手动装箱和拆箱
        int n1 = 100;
        Integer integer = Integer.valueOf(n1);
        //手动拆箱
        int i = integer.intValue();

        //jdk5后，就可以自动装箱和自动拆箱
        int n2 = 200;
        Integer integer2 = n2; //底层使用的是仍然是 Integer.valueOf(n2)
        //自动拆箱
        int n3 = integer2; //底层使用的仍然是 int n3 = integer.intValue()
    &#125;
&#125;
</code></pre>
<p>==三元运算符是一个整体==</p>
<pre><code class="lang-java">package com.zzy.wrapper;

/**
 * @autho: 周钟炎
 * @version: 1.0
 */
public class Exercise01 &#123;
    public static void main(String[] args) &#123;
        Object obj1 = true ? new Integer(1) : new Double(2.0);
        //这里结果是1.0，三元运算符是一个整体，要先提升优先级
        System.out.println(obj1);
    &#125;
&#125;
</code></pre>
<p>包装类和String的转换</p>
<pre><code class="lang-java">package com.zzy.wrapper;

/**
 * @autho: 周钟炎
 * @version: 1.0
 */
public class WrapperVsString &#123;
    public static void main(String[] args) &#123;
        //包装类(Integer)装成String
        Integer i1 = 100; //自动装箱
        //方式1
        String str1 = i1 + &quot;&quot;; //这里只是值传递

        //方式二
        String str2 = i1.toString();

        //方式三
        String str3 = String.valueOf(i1);

        //把String转成包装类
        int i2 = Integer.parseInt(str4); //这里换成Integer可以用到自动装箱
        Integer i3 = new Integer(str4);
        Integer i4 = Integer.valueOf(str4);
    &#125;
&#125;
</code></pre>
<p>练习：</p>
<pre><code class="lang-java">package com.zzy.wrapper;

/**
 * @autho: 周钟炎
 * @version: 1.0
 */
public class Exercise02 &#123;
    public static void main(String[] args) &#123;
        Integer i = new Integer(1);
        Integer j = new Integer(1);
        System.out.println(i == j);

        //主要看valueOf的源码
        Integer m = 1;
        Integer n = 1;
        System.out.println(m == n);

        Integer x = 128;
        Integer y = 128;
        System.out.println( x == y);
    &#125;
&#125;
</code></pre>
<h2 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h2><pre><code class="lang-java">package com.zzy.string_;

/**
 * @autho: 周钟炎
 * @version: 1.0
 */
public class String01 &#123;
    public static void main(String[] args) &#123;
        String name = &quot;zzy&quot;;

        //创建String对象的两种方式
        //方式1,直接创建
        //方式一先从常量池查看是否有&quot;zzy&quot;数据空间，如果有，直接指向；如果没有则重新创建，然后指向
        //最终指向的是常量池的空间地址
        String s = &quot;zzy&quot;;

        //方式2，调用构造器
        //先在堆中创建空间，里面维护了value属性，指向常量池的zzy空间，如果常量池没有&quot;zzy&quot;，重新创建，
        //如果有，直接通过value指向。最终的是堆中的空间地址
        String s1 = new String(&quot;zzy&quot;);

        String a = &quot;abc&quot;;
        String b = new String(&quot;abc&quot;);
        System.out.println(a.equals(b)); //T
        System.out.println(a == b); //F
        //intern方法就是到常量池去找这个b对象，如果有，直接返回常量池的地址，
        // 没有就在常量池创建一个在返回
        System.out.println(a == b.intern()); //T
        System.out.println(b == b.intern()); //F

        //这里在常量池里创建了两个对象
        String str1 = &quot;abc&quot;;
        str1 = &quot;bcd&quot;;

        //这里在常量池创建了一个对象，底层会对其进行优化
        String str2 = &quot;hello&quot; + &quot;abc&quot;;


        String str3 = &quot;zzy&quot;;
        String str4 = &quot;java&quot;;
        //下面两条语句有着明细的区别，str5是先在池中创建一个StringBuilder对象，然后append添加进去
        // 最后将拼接起来的字符串返回给堆区，堆区再指向str5，所以返回的是堆中的地址
        //str6是直接拼接，返回的是池中的地址
        String str5 = str3 + str4;
        String str6 = &quot;zzy&quot; + &quot;java&quot;;
        System.out.println(str5 == str6); //F
    &#125;
&#125;
</code></pre>
<p>案例</p>
<pre><code class="lang-java">package com.zzy.string_;

/**
 * @autho: 周钟炎
 * @version: 1.0
 */
public class String02 &#123;
    public static void main(String[] args) &#123;
        Test01 ex = new Test01();
        //这个changes方法会在栈上重新开辟一块区域，运行完就销毁了
        ex.changes(ex.str, ex.ch);
        System.out.println(ex.str + &quot;and&quot;); //hspand
        System.out.println(ex.ch); //hava
    &#125;
&#125;

class Test01 &#123;
    String str = new String(&quot;hsp&quot;);
    final char[] ch = &#123;&#39;j&#39;, &#39;a&#39;, &#39;v&#39;, &#39;a&#39;&#125;;
    public void changes(String str, char ch[]) &#123;
        str = &quot;java&quot;;
        ch[0] = &#39;h&#39;;
    &#125;
&#125;
</code></pre>
<p>String类的常用方法</p>
<p>String类是保存字符串常量的，每次更新都需要重新开辟空间，效率较低，因此Java设计者还提供了StringBuilder和StringBuffer来增强String的功能，并提高效率</p>
<pre><code class="lang-java">package com.zzy.string_;

/**
 * @autho: 周钟炎
 * @version: 1.0
 */
public class StringMethod &#123;
    public static void main(String[] args) &#123;
        String str = &quot;春眠不觉晓，处处闻啼鸟，夜来风雨声，花落知多少&quot;;
        String[] str1 = str.split(&quot;，&quot;);
        for (String i : str1) &#123;
            System.out.println(i);
        &#125;

        //在分割时，碰见特殊字符，则需要进行转义
        String str2 = &quot;E:\\aaa\\bbb&quot;;
        String[] str3 = str2.split(&quot;\\\\&quot;);
        for (String i : str3) &#123;
            System.out.println(i);
        &#125;

        //字符串转成字符数组
        String str4 = &quot;happy&quot;;
        char[] chars =  str4.toCharArray();
        for (char i : chars) &#123;
            System.out.println(i);
        &#125;

        //format可以定义String的输出格式
        String name = &quot;Han Shun Ping&quot;;
        String[] s = str.split(&quot; &quot;);
         String format = String.format(&quot; %s,%s ,%c&quot;, s[2], s[0], s[1].charAt(0));
        System.out.println(format);
    &#125;
&#125;
</code></pre>
<p>StringBuffer类</p>
<p>StringBuffer代表可变的字符序列，可以对字符串内容进行增删。</p>
<pre><code class="lang-java">package com.zzy.stringbuffer_;

/**
 * @autho: 周钟炎
 * @version: 1.0
 */
public class StringBuffer01 &#123;
    public static void main(String[] args) &#123;
        //在父类中 AbstractStringBuilder有属性byte[]，不是final修饰的
        //因此它是存放在堆中，不是存放在常量池
        //StringBuffer是一个final类，不能被继承
        //因为StringBuffer字符内容是存在byte[] value里的 ，因此每次变化内容不用都更换地址，
        // 除非是内存不够了，效率高于String
        StringBuffer stringBuffer = new StringBuffer(&quot;hello&quot;);

    &#125;
&#125;
</code></pre>
<p>StringBuffer的几种构造器</p>
<pre><code class="lang-java">package com.zzy.stringbuffer_;

/**
 * @autho: 周钟炎
 * @version: 1.0
 */
public class StringBuffer02 &#123;
    public static void main(String[] args) &#123;
        //1.创建一个默认为16大小的char[]，用于存放字符内容
        StringBuffer stringBuffer1 = new StringBuffer();

        //2.通过构造器指定char[]大小
        StringBuffer stringBuffer2 = new StringBuffer(100);

        //3.通过给一个String创建StringBuffer
        StringBuffer stringBuffer3 = new StringBuffer(&quot;zzy&quot;);
    &#125;
&#125;
</code></pre>
<p>String与StringBuffer的转换</p>
<pre><code class="lang-java">package com.zzy.stringbuffer_;

/**
 * @autho: 周钟炎
 * @version: 1.0
 */
public class StringAndStringBuffer &#123;
    public static void main(String[] args) &#123;
        //String-&gt;StringBuffer
        String str = &quot;hello&quot;;
        //方式1，使用构造器,但是这里只是stringbuffer做了改变
        StringBuffer stringBuffer = new StringBuffer(str);

        //方式2，先创建一个空的，在用append去增加
        StringBuffer stringBuffer1 = new StringBuffer();
        stringBuffer1.append(str);

        //StringBuffer-&gt;String
        StringBuffer stringBuffer2 = new StringBuffer(&quot;zzy&quot;);
        //方式1，使用StringBuffer提供的toString方法
        String str1 = stringBuffer2.toString();
        //方式2，使用String提供的构造器
        String s = new String(stringBuffer2);
    &#125;
&#125;
</code></pre>
<p>StringBuffer的增删改查</p>
<p>1.增 append 2.删 delete 3.改 replace 4. indexOf 5. 插 insert 6. 获取长度 length</p>
<pre><code class="lang-java">package com.zzy.stringbuffer_;

/**
 * @autho: 周钟炎
 * @version: 1.0
 */
public class StringBuferMethod &#123;
    public static void main(String[] args) &#123;
        StringBuffer stringBuffer = new StringBuffer(&quot;hello&quot;);
        //尾插
        stringBuffer.append(&quot;,&quot;);
        stringBuffer.append(&quot;张三丰&quot;);
        stringBuffer.append(&quot;张无忌&quot;).append(100).append(true).append(10.5);
        System.out.println(stringBuffer);

        //删除
        stringBuffer.delete(12, 15);
        System.out.println(stringBuffer);//前闭后开

        //修改
        stringBuffer.replace(9,12,&quot;周芷若&quot;);
        System.out.println(stringBuffer);

        //查找
        int num = stringBuffer.indexOf(&quot;张三丰&quot;);
        System.out.println(num);

        //插入,在索引为9的位置插入，原来索引为9的内容自动后移
        stringBuffer.insert(9, &quot;操&quot;);
        System.out.println(stringBuffer);
        //长度
        System.out.println(stringBuffer.length());
    &#125;
&#125;
</code></pre>
<p>练习题</p>
<pre><code class="lang-java">package com.zzy.stringbuffer_;

import java.util.Scanner;

/**
 * @autho: 周钟炎
 * @version: 1.0
 */
public class StringBufferExercise &#123;
    public static void main(String[] args) &#123;
        Scanner scanner = new Scanner(System.in);
        String str = scanner.next();
        StringBuffer stringBuffer = new StringBuffer(str);
        //查
        for (int i = stringBuffer.lastIndexOf(&quot;.&quot;) - 3; i &gt; 0 ; i -= 3) &#123;
            stringBuffer = stringBuffer.insert(i, &quot;,&quot;);
        &#125;
        System.out.println(stringBuffer);
    &#125;

&#125;
</code></pre>
<p>StringBuilder类</p>
<p>1.一个可变的字符序列。此类提供一个与StringBuffer兼容的API，但不保证同步（有线程安全问题）。该类被设计用作StringBuffer的一个简易替换，用在字符串缓冲区被单个线程使用的时候。如果可能，建议优先采用该类，因为在大多数实现中，它比StringBuffer要快。</p>
<p>2.在StringBuilder上的主要操作是append和insert方法，可以重载这些方法，以接受任意类型的数据。</p>
<p>String: 不可变字符序列，效率低，但是复用率高。</p>
<p>StringBuffer：可变字符序列，效率较高，线程安全。</p>
<p>StringBuilder:可变字符序列，效率最高，线程不安全。</p>
<p>使用的原则：</p>
<p>1.如果字符串存在大量的修改操作，一般使用StringBuffer或者StringBuilder</p>
<p>2.如果字符串存在大量的修改操作，并在单线程的情况下，使用StringBuilder</p>
<p>3.如果字符串存在大量的修改操作，并在多线程的情况下，使用StringBuilder</p>
<p>4.如果我们字符串很少修改，被多个对象引用，使用String,比如配置信息</p>
<h2 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h2><p>一般都为静态方法</p>
<pre><code class="lang-java">package com.zzy.math_;

import com.sun.jdi.DoubleValue;

import java.sql.SQLOutput;

/**
 * @autho: 周钟炎
 * @version: 1.0
 */
public class MathMethod &#123;
    public static void main(String[] args) &#123;
        //Math常用方法
        //abs 绝对值
        int abs = Math.abs(-2);
        System.out.println(abs);

        //pow 求幂
        double pow = Math.pow(2, 3);
        System.out.println(pow);

        //ceil 向上取整 返回最小整数（转成double)
        double ceil = Math.ceil(- 3.1);
        System.out.println(ceil);

        //floor 向下取整,坐标轴右边为上,(装成double)
        double floor = Math.floor(-3.1);
        System.out.println(floor);

        //round 四舍五入
        long round = Math.round(4.5);
        System.out.println(round);

        //开方
        double x = Math.sqrt(10);
        System.out.println(x);

        //返回随机数,返回[0, 1)的数
        double y = Math.random();
        double z = Math.floor( y * 6 + 2);
        System.out.println(z);

        //max, min 返回最大值和最小值
        int min = Math.min(1, 9);
        int max = Math.max(45, 90);
        System.out.println(&quot;max = &quot; + max);
        System.out.println(&quot;min = &quot; + min);
    &#125;
&#125;
</code></pre>
<h2 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h2><p>toString方法，打印出数组所有元素</p>
<pre><code class="lang-java">package com.zzy.array_;

import java.util.Arrays;
import java.util.Comparator;

/**
 * @autho: 周钟炎
 * @version: 1.0
 */
public class ArrayMethod01 &#123;
    public static void main(String[] args) &#123;
        Integer[] integers = &#123;1, 20, 90&#125;;
        //Arrays的toString方法
        System.out.println(Arrays.toString(integers));

        //排序
        Integer[] arr1 = &#123;1, -1, 7, 0, 89&#125;;
        //可以使用冒泡排序，也可以使用Arrays提供的sort方法
        //数组是引用类型,所以通过sort排序后，会直接影响到实参 arr
        Arrays.sort(arr1);
        System.out.println(&quot;排序后...&quot;);
        System.out.println(Arrays.toString(arr1));

        //定制排序，实现了Comparator接口的匿名内部类
        Arrays.sort(arr1, new Comparator&lt;Integer&gt;() &#123;
            @Override
            public int compare(Integer o1, Integer o2) &#123;
                return o2 -o1;
            &#125;
        &#125;);
        System.out.println(Arrays.toString(arr1));
    &#125;
&#125;
</code></pre>
<p>自己实现排序：</p>
<pre><code class="lang-java">package com.zzy.array_;

import java.util.Arrays;
import java.util.Comparator;

/**
 * @autho: 周钟炎
 * @version: 1.0
 */
public class ArraySortCustom &#123;
    public static void main(String[] args) &#123;
        int[] arr = &#123;1, -1, 8, 0, 20 &#125;;
        bubble_sort01(arr, new Comparator() &#123;
            @Override
            public int compare(Object o1, Object o2) &#123;
                int i1 = (Integer) o1; //向下转型加自动拆箱
                int i2 = (Integer) o2;
                return i1 -i2; //return i2 -i1;
            &#125;
        &#125;);
        System.out.println(Arrays.toString(arr));
    &#125;

    public static void bubble_sort(int[] arr) &#123;
        for (int i = 0; i &lt; arr.length ; i++) &#123;
            for (int j = i+1; j &lt;arr.length ; j++) &#123;
                if ( arr[i] &gt; arr[j]) &#123;
                    int temp = arr[i];
                    arr[i] = arr[j];
                    arr[j] = temp;
                &#125;
            &#125;
        &#125;
    &#125;

    //结合冒泡 + 定制
    public static void bubble_sort01 (int[] arr, Comparator c) &#123;
        for (int i = 0; i &lt; arr.length ; i++) &#123;
            for (int j = i+1; j &lt;arr.length ; j++) &#123;
                //数组的排序由if里的语句去控制
                if ( c.compare(arr[i], arr[j]) &gt; 0) &#123;
                    int temp = arr[i];
                    arr[i] = arr[j];
                    arr[j] = temp;
                &#125;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="lang-java">package com.zzy.array_;

import java.util.Arrays;
import java.util.List;

/**
 * @autho: 周钟炎
 * @version: 1.0
 */
public class ArrayMethod02 &#123;
    public static void main(String[] args) &#123;
        Integer[] arr = &#123;1, 2, 90, 123, 567&#125;;
        //使用binarySearch 二叉查找，要求数组是有序的
        //如果该数组是无序的，不能使用binarySearch
        //如果不存在，就返回 -(low + 1)，low代表他应该存在的位置
        int index = Arrays.binarySearch(arr, 568);
        System.out.println(index); //-6

        //copyOf 数组元素的复制,从arr中拷贝 arr.length个元素到newArr
        //如果拷贝的长度 &gt;原来数组，就在原来的数组尾插一个null
        Integer[] newArr = Arrays.copyOf(arr, arr.length + 1);
        System.out.println(Arrays.toString(newArr));

        //fill 数组填充,使用99替换原来的数组
        Integer[] num = &#123;9, 3, 2&#125;;
        Arrays.fill(num, 99);
        System.out.println(&quot;数组填充后...&quot;);
        System.out.println(Arrays.toString(num));

        //equals 比较两个数组元素内容是否完全一致,如果是则返回true
        Integer[] arr1 = &#123;1, 2, 90, 123, 567&#125;;
        boolean bool = Arrays.equals(arr, arr1);
        System.out.println(bool);

        //asList 将一组值，转换成List, List是一个接口
        List&lt;Integer&gt; asList = Arrays.asList(2, 3, 4, 5, 6, 1);
        System.out.println(&quot;asList = &quot; + asList);
    &#125;
&#125;
</code></pre>
<h2 id="System"><a href="#System" class="headerlink" title="System"></a>System</h2><p>1.exit退出当前程序</p>
<p>2.arraycopy：复制数组元素，比较适合底层调用，一般使用Arrays.copyOf完成复制数组</p>
<p>3.currentTimeMillens:返回当前时间距离1970-1-1的毫秒数</p>
<p>4.gc:运行垃圾回收机制System.gc();</p>
<h2 id="BigInteger和BigDecimal"><a href="#BigInteger和BigDecimal" class="headerlink" title="BigInteger和BigDecimal"></a>BigInteger和BigDecimal</h2><pre><code class="lang-java">package com.zzy.bignum_;

import java.math.BigInteger;

/**
 * @autho: 周钟炎
 * @version: 1.0
 */
public class bigInteger &#123;
    public static void main(String[] args) &#123;
        //编程中处理很大的整数,用BigInteger
        BigInteger bigInteger = new BigInteger(&quot;2321546576824343&quot;);
        System.out.println(bigInteger);

        //在对BigInteger进行加减乘除的时候，需要使用对应的方法，不能直接进行+ - * /
        BigInteger bigInteger1 = new BigInteger(&quot;100&quot;);
        BigInteger add = bigInteger.add(bigInteger1);
        System.out.println(add);

        BigInteger subtract = bigInteger.subtract(bigInteger1);
        System.out.println(subtract);

        BigInteger multiply = bigInteger.multiply(bigInteger1);
        System.out.println(multiply);

        BigInteger divide = bigInteger.divide(bigInteger1);
        System.out.println(divide);
    &#125;
&#125;
</code></pre>
<pre><code class="lang-java">package com.zzy.bignum_;

import java.math.BigDecimal;
import java.math.RoundingMode;

/**
 * @autho: 周钟炎
 * @version: 1.0
 */
public class bigDecimal_ &#123;
    public static void main(String[] args) &#123;
        //当我们需要保存一个精度很高的数时，double不够用
        BigDecimal bigDecimal = new BigDecimal(&quot;0.3232545465665454325&quot;);
        System.out.println(bigDecimal);
        //再除以小数的时候，可能是一个无限循环的小数，会抛出异常
        BigDecimal bigDecimal1 = new BigDecimal(&quot;3&quot;);
        //在调用divide时，指定精度就可以
        //如果有无限循环小数，就会保留分子的精度
        bigDecimal = bigDecimal.divide(bigDecimal1, RoundingMode.CEILING);
        System.out.println(bigDecimal);
    &#125;
&#125;
</code></pre>
<h2 id="日期类"><a href="#日期类" class="headerlink" title="日期类"></a>日期类</h2><pre><code class="lang-java">package com.zzy.date_;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

/**
 * @autho: 周钟炎
 * @version: 1.0
 */
public class Date01 &#123;
    public static void main(String[] args) throws ParseException &#123;
        //获取当前的系统时间
        Date date = new Date();
        System.out.println(&quot;当前日期 = &quot; + date);
        //默认输出的日期格式是国外的
        //用SimpleDateFormat改变的格式是规定好的
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy年MM月dd日 hh:mm:ss E&quot;);
        String format = simpleDateFormat.format(date);
        System.out.println(format);

        //也可以用构造器，输入毫秒数，但是时间是从1970年1月1号00:00开始的
        Date date1 = new Date(321321);
        System.out.println(date1);

        //把字符串转成Date
        String s = &quot;1996年01月01日 10:20:30 星期一&quot;;
        Date parse = simpleDateFormat.parse(s);
        System.out.println(simpleDateFormat.format(parse));
    &#125;
&#125;
</code></pre>
<p>第二代时间</p>
<pre><code class="lang-java">package com.zzy.date_;

import java.util.Calendar;

/**
 * @autho: 周钟炎
 * @version: 1.0
 */
public class Calender_ &#123;
    public static void main(String[] args) &#123;
        //Calender是一个抽象类,并且其构造器是受保护的
        Calendar c = Calendar.getInstance();
        //里面有很多字段，从中拿出相应的字段就好了
        System.out.println(&quot;c = &quot; + c);
        System.out.println(&quot;年:&quot; + c.get(Calendar.YEAR));
        //返回月的时候是按照0开始编号的
        System.out.println(&quot;月：&quot; + c.get(Calendar.MONTH) + 1);
        System.out.println(&quot;日：&quot; + c.get(Calendar.DAY_OF_MONTH));
        System.out.println(&quot;小时：&quot; + c.get(Calendar.HOUR));
        System.out.println(&quot;24小时制：&quot; + c.get(Calendar.HOUR_OF_DAY));
        System.out.println(&quot;分：&quot; + c.get(Calendar.MINUTE));
        System.out.println(&quot;秒：&quot; + c.get(Calendar.SECOND));

        //需要自己组合格式
    &#125;
&#125;
</code></pre>
<p>第三代时间</p>
<pre><code class="lang-java">package com.zzy.date_;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.time.format.DateTimeFormatter;

/**
 * @autho: 周钟炎
 * @version: 1.0
 */
public class LocalTime_ &#123;
    public static void main(String[] args) &#123;
        LocalDateTime ldt = LocalDateTime.now();
        System.out.println(ldt);
        System.out.println(&quot;年:&quot; + ldt.getYear());
        System.out.println(&quot;月：&quot; + ldt.getMonth());
        System.out.println(&quot;月：&quot; + ldt.getMonthValue());
        System.out.println(&quot;日：&quot; + ldt.getDayOfMonth());
        System.out.println(&quot;时：&quot; + ldt.getHour());
        System.out.println(&quot;分：&quot; + ldt.getMinute());
        System.out.println(&quot;秒：&quot; + ldt.getSecond());

        //获得年月日
        LocalDate now = LocalDate.now();
        //获取时分秒
        LocalTime now2 = LocalTime.now();

        //使用DateTimeFormatter对象进行格式化
        DateTimeFormatter dtf = DateTimeFormatter.ofPattern(&quot;yyyy年MM月dd日 HH小时mm分钟ss秒 E&quot;);
        String s = dtf.format(ldt);
        System.out.println(s);

        //加减时间
        LocalDateTime ldt2 = ldt.plusDays(890);
        System.out.println(dtf.format(ldt2));

        LocalDateTime ldt3 = ldt.minusYears(2);
        System.out.println(dtf.format(ldt3));
    &#125;
&#125;
</code></pre>
<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><p>保存多个数据时使用的是数组，而数组有不足的地方</p>
<p>数组</p>
<p>1.长度开始时必须指定，而且一旦指定，不能更改</p>
<p>2.保存的必须为同一类型的元素</p>
<p>3.增加或者删除元素比较麻烦</p>
<p>集合</p>
<p>1.可以动态保存任意多个对象，使用比较方便。</p>
<p>2.提供了一系列方便的操作对象的方法：add、remover、set、get</p>
<p>3.使用集合添加、删除新元素比较简单</p>
<p>集合主要分为2大类：</p>
<p>单列集合Collection</p>
<p>List: ArrayList、LinkedList、Vector</p>
<p>Set:HashSet、TreeSet</p>
<p>双列集合：</p>
<p>Map: HashMap、TreeMap、Hashtable、Properties</p>
<h2 id="List类的方法"><a href="#List类的方法" class="headerlink" title="List类的方法"></a>List类的方法</h2><pre><code class="lang-java">package com.zzy.collection_;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

/**
 * @autho: 周钟炎
 * @version: 1.0
 */
public class Collection01 &#123;
    public static void main(String[] args) &#123;
        List list = new ArrayList(); //动态绑定
        //增加
        list.add(&quot;jack&quot;);
        list.add(10);
        list.add(true);
        System.out.println(list);

        //删
        list.remove(0);//删除第一个元素
        list.remove(true);//删除某个元素
        System.out.println(list);

        //查找
        System.out.println(list.contains(10));

        //返回元素的个数
        System.out.println(list.size());

        //判断是否为空
        System.out.println(list.isEmpty());

        //清空
//        list.clear();

        //添加多个对象
        ArrayList arrayList = new ArrayList();
        arrayList.add(&quot;红楼梦&quot;);
        arrayList.add(&quot;三国演义&quot;);
        list.addAll(arrayList);
        System.out.println(list);

        //删除多个元素
        list.removeAll(arrayList);
        System.out.println(list);
    &#125;
&#125;
</code></pre>
<p>实现了Iterable接口的可以采用迭代器的方式遍历</p>
<pre><code class="lang-java">package com.zzy.collection_;

import java.util.ArrayList;
import java.util.Iterator;

/**
 * @autho: 周钟炎
 * @version: 1.0
 */
public class CollectionIterator &#123;
    public static void main(String[] args) &#123;
        ArrayList arrayList = new ArrayList();
        arrayList.add(new Book(&quot;三国演义&quot;, &quot;罗贯中&quot;, 19));
        arrayList.add(new Book(&quot;红楼梦&quot;, &quot;曹雪芹&quot;, 20));
        arrayList.add(new Book(&quot;西游记&quot;, &quot;吴世恩&quot;, 22));
        System.out.println(arrayList);

        //遍历
        Iterator it = arrayList.iterator();

        while (it.hasNext()) &#123;
            //因为什么都能存，所以返回的是Object
            Object obj = it.next();
            System.out.println(obj); //动态绑定
        &#125;

        //如果想重新遍历，就要重置迭代器
        it = arrayList.iterator();
        while (it.hasNext()) &#123;
            Object next =  it.next();
            System.out.println(next);
        &#125;
    &#125;
&#125;

class Book &#123;
    public String name;
    public String author;
    public double price;

    public Book(String name, String author, double price) &#123;
        this.name = name;
        this.author = author;
        this.price = price;
    &#125;

    @Override
    public String toString() &#123;
        return &quot;Book&#123;&quot; +
                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +
                &quot;, author=&#39;&quot; + author + &#39;\&#39;&#39; +
                &quot;, price=&quot; + price +
                &#39;&#125;&#39;;
    &#125;
&#125;
</code></pre>
<p>==ctrl加J可以提示所有的快捷键==</p>
<p>List集合类中元素有序，且可重复。</p>
<p>List集合中的每个元素都有其对应的顺序索引</p>
<pre><code class="lang-java">package com.zzy.collection_;

import java.util.ArrayList;
import java.util.List;

/**
 * @autho: 周钟炎
 * @version: 1.0
 */
public class ListMethod &#123;
    public static void main(String[] args) &#123;
        List list = new ArrayList();
        list.add(&quot;老黑&quot;);
        list.add(&quot;大狗&quot;);

        //在指定位置插入
        list.add(1, &quot;大黄&quot;);
        System.out.println(list);

        //加入多个元素
        List list1 = new ArrayList();
        list1.add(&quot;lxc&quot;);
        list1.add(&quot;zy&quot;);
        list.addAll(1, list1);
        System.out.println(list);

        //替换
        list.set(0, &quot;sy&quot;);
        System.out.println(list);

        //返回集合,返回的是一个前闭后开的范围
        List returnlist = list.subList(0, 3);
        System.out.println(returnlist);
    &#125;
&#125;
</code></pre>
<p>ArrayList效率高,但是是线程不安全的</p>
<p>ArrayList源码</p>
<p>1.ArrayList中维护了一个Object类型的数组</p>
<p>2.当创建ArrayList对象时，如果使用的是无参构造器，则初始elementData容量为0，第一次添加，则扩容elementData为10，如需再次扩容，则扩容elmentData为1.5倍。</p>
<p>3.如果使用的是制定大小的构造器，则初始化elementData容量为指定大小，如果需要扩容，则直接扩容elementData为1.5倍。</p>
<p>transient //表示瞬间的、短暂的，表示该属性不会被序列号</p>
<p>Vector</p>
<p>1.Vector底层也是一个对象数组， protected Object[] elementData;</p>
<p>2.Vector是线程安全的</p>
<p>3.如果是无参，默认为10，满后，就按2倍扩容</p>
<p>LinkedList</p>
<p>1.LinkedList底层实现了双向链表和双端队列的特点</p>
<p>2.可以添加任意元素（元素可以重复），包括null</p>
<p>3.线程不安全，没有实现同步</p>
<p>LinkedList底层维护了一个双向链表，两个属性first和last分别指向首节点和尾结点</p>
<p>每个节点(Node对象)，里面又维护了prev、next、item三个属性，prev指向前一个，通过next指向后一个节点，最近实现双向链表。</p>
<p>比较方便添加和删除</p>
<pre><code class="lang-java">package com.zzy.collection_;

/**
 * @autho: 周钟炎
 * @version: 1.0
 */
public class LinkedList01 &#123;
    public static void main(String[] args) &#123;
        Node jack = new Node(&quot;jack&quot;);
        Node tom = new Node(&quot;tom&quot;);
        Node hsp = new Node(&quot;老韩&quot;);
        //jack-&gt;tom-&gt;hsp
        //连接三个结点
        jack.next = tom;
        tom.next = hsp;
        //hsp-&gt;tom-&gt;jack
        hsp.pre = tom;
        tom.pre = jack;

        Node first = jack;
        Node last = hsp;

        //从头到尾遍历
        while (true) &#123;
            if (first == null) &#123;//true
                break;
            &#125;
            System.out.println(first);
            first = first.next; //tom.next = null;
        &#125;

        //从尾到头遍历
        while (true) &#123;
            if (last == null) &#123;
                break;
            &#125;
            System.out.println(last);
            last = last.pre;
        &#125;

        //在tom和和老韩之间加入一个对象
        Node zf = new Node(&quot;张飞&quot;);

        tom.next = zf;
        zf.next = hsp;
        hsp.pre = zf;
        zf.pre = tom;

        first = jack;
        while (true) &#123;
            if (first == null) &#123;//true
                break;
            &#125;
            System.out.println(first);
            first = first.next; //tom.next = null;
        &#125;
    &#125;
&#125;

class Node &#123;
    public Object item;
    public Node next; //下一个节点
    public Node pre; //前一个节点

    public Node(Object item) &#123;
        this.item = item;
    &#125;

    public String toString() &#123;
        return &quot;Node name = &quot; + item;
    &#125;
&#125;
</code></pre>
<pre><code class="lang-java">package com.zzy.collection_;

import java.util.LinkedList;

/**
 * @autho: 周钟炎
 * @version: 1.0
 */
public class LinkedList02 &#123;
    public static void main(String[] args) &#123;
        LinkedList linkedList = new LinkedList();
        linkedList.add(1);
        linkedList.add(2);
        linkedList.add(3);
        System.out.println(linkedList);

        linkedList.remove();
        System.out.println(linkedList);

        //修改某个节点对象
        linkedList.set(1,999);
        System.out.println(linkedList);

        //得到某个节点对象
        System.out.println(linkedList.get(0));
    &#125;
&#125;
</code></pre>
<h2 id="Set类"><a href="#Set类" class="headerlink" title="Set类"></a>Set类</h2><p>1.无序（添加和取出的顺序不一致），没有索引</p>
<p>2.不允许重复的元素，所以最多包含一个null</p>
<p>HashSet:</p>
<p>1.HashSet底层是HashMap</p>
<p>2.添加一个元素时，先得到hash值，会转成-&gt;索引值</p>
<p>3.找到存储数据表table，看这个索引位置是否有已经存放的元素</p>
<p>4.如果没有，直接加入</p>
<p>5.如果有，调用equals比较，如果相同，就放弃添加，如果不相同，则添加到最后</p>
<p>6.在Java8中，如果一条链表的元素个数达到TREEIFT_THRESHOLD（默认为8），并且table的大小&gt;=MIN_TREEIFY_CAPACITY（默认64），就会进行树化（红黑树）</p>
<p>经典题：</p>
<pre><code class="lang-java">package com.zzy.set_;

import java.util.HashSet;
import java.util.Objects;

/**
 * @autho: 周钟炎
 * @version: 1.0
 */
public class HashSetExercise02 &#123;
    public static void main(String[] args) &#123;
        HashSet hashSet = new HashSet();
        hashSet.add(new Employee_(&quot;zzy&quot;, 30000,
                new Employee_().new MyDate(1998, 11, 24)));
        hashSet.add(new Employee_(&quot;zzy&quot;, 30000,
                new Employee_().new MyDate(1998, 11, 24)));
        System.out.println(hashSet);
    &#125;
&#125;

class Employee_ &#123;
    private String name;
    private double salary;
    private MyDate birthday;

    public Employee_(String name, double salary, MyDate birthday) &#123;
        this.name = name;
        this.salary = salary;
        this.birthday = birthday;
    &#125;

    public Employee_()&#123;&#125;

    class MyDate&#123;
        private int year;
        private int month;
        private int day;

        public MyDate(int year, int month, int day) &#123;
            this.year = year;
            this.month = month;
            this.day = day;
        &#125;

        //通过内部类的hashCode和 equals的重写，套娃使其得到的hashCode依据birthday的内容决定
        //而不是地址
        @Override
        public boolean equals(Object o) &#123;
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            MyDate myDate = (MyDate) o;
            return year == myDate.year &amp;&amp; month == myDate.month &amp;&amp; day == myDate.day;
        &#125;

        @Override
        public int hashCode() &#123;
            return Objects.hash(year, month, day);
        &#125;
    &#125;

    @Override
    public boolean equals(Object o) &#123;
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Employee_ employee_ = (Employee_) o;
        return name.equals(employee_.name) &amp;&amp; birthday.equals(employee_.birthday);
    &#125;

    @Override
    public int hashCode() &#123;
        //这里的name是在常量池,但是要保证内部类的所影响的hashCode一致
        return Objects.hash(name, birthday);
    &#125;
&#125;
</code></pre>
<p>LinkedHashSet</p>
<p>1.在LinkedHashSet中维护了一个hash表和双向链表</p>
<p>2.在某个节点有before和after属性，这样可以形成双向链表</p>
<p>3.在添加一个元素时，先求hash值，再求索引，确定该元素在table的位置，然后将添加的元素加入到双向链接（如果已经存在，不添加【原则和hashset一样】</p>
<p>4.这样的话，我们遍历LinkedHashSet也能确保插入顺序和遍历顺序一致</p>
<p>里面HashMapNode里有内部类LinkedHashMapEntry</p>
<p>==其实set也是键值对的形式，但是其value是用一个常量填充的==</p>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><pre><code class="lang-java">package com.zzy.map_;

import java.util.HashMap;
import java.util.Map;

/**
 * @autho: 周钟炎
 * @version: 1.0
 */
@SuppressWarnings(&#123;&quot;all&quot;&#125;)
public class Map_ &#123;
    public static void main(String[] args) &#123;
        //map接口实现类的特点
        //1.保存具有映射关系的key-value
        //无序的，因为底层还是hashMap
        Map map = new HashMap();
        map.put(&quot;No1&quot;, &quot;zzy&quot;);
        map.put(&quot;No2&quot;, &quot;林动&quot;);
        //当key相同的，会进行替换
        map.put(&quot;No1&quot;, &quot;韩顺平&quot;);
        //value值是可以重复的
        map.put(&quot;No3&quot;, &quot;zzy&quot;);
        System.out.println(&quot;map = &quot; + map);
        //Map的key可以为null，value也可以为空，但是key的null只能有一个，value为null可以有多个
        //key和value之间存在单向一对一关系，即通过指定的key总能找到对应的value

        //通过get方法，传入key，得到相应的value
        System.out.println(map.get(&quot;No1&quot;));
    &#125;
&#125;
</code></pre>
<p>Map的源码解析</p>
<pre><code class="lang-java">package com.zzy.map_;

import java.util.Collection;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;

/**
 * @autho: 周钟炎
 * @version: 1.0
 */
public class MapSource &#123;
    public static void main(String[] args) &#123;
        Map map = new HashMap();
        map.put(&quot;no1&quot;, &quot;韩顺平&quot;);
        map.put(&quot;no2&quot;, &quot;zzy&quot;);

        //1.k-v是在HashMap$Node里面管理的
        //2.k-v为了方便程序员的遍历，还会创建EntrySet集合，该集合存放的元素的类型是Entry
        //3.entrySet中，定义的类型是Map.Entry, 但是实际上存放的还是HashMap$Node,这是因为Ha
        //HashMap$Node implements Map.Entry
        //4.当把HashMap$Node 对象放到entrySet 就方便我们遍历,因为Map.entry提供了重要方法
        //getKey() 和 getValue()
        Set set = map.entrySet();
        for (Object obj : set) &#123;
            Map.Entry entry = (Map.Entry) obj;
            System.out.println(entry.getKey() + &quot;-&quot; + entry.getValue());
        &#125;

        //k值收集到了Set里  value收集到了 Collection
        Set set1 = map.keySet();
        //KeySet
        System.out.println(set1.getClass());
        Collection values = map.values();
        //Values
        System.out.println(values.getClass());
    &#125;
&#125;
</code></pre>
<p>➢扩容机制[和HashSet相同]<br>1) HashMap底层维护了Node类型的数组table,默认为null<br>2)当创建对象时，将加载因子(loadfactor)初始化为0.75.<br>3) 当添加key-val时，通过key的哈希值得到在table的索引。然后判断该索引处是否有元素，<br>如果没有元素直接添加。如果该索引处有元素，继续判断该元素的key是否和准备加入的<br>key相等，如果相等，则直接替换val;如果不相等需要判断是树结构还是链表结构，做出<br>相应处理。如果添加时发现容量不够，则需要扩容。<br>4)第1次添加，则需要扩容table容量为16,临界值(threshold)为12.<br>5)以后再扩容，则需要扩容table容量为原来的2倍，临界值为原来的2倍,即24,依次类推.<br>6)在Java8中，如果一条链表的元素个数超过TREEIFY THRESHOLD(默认是8)，并且<br>table的大小&gt;= MIN TREEIFY CAPACITY(默认64),就会进行树化(红黑树)</p>
<hr>

<p>Map的接口和常用方法</p>
<pre><code class="lang-java">package com.zzy.map_;

import java.util.HashMap;
import java.util.Map;

/**
 * @autho: 周钟炎
 * @version: 1.0
 */
public class MapMethod &#123;
    public static void main(String[] args) &#123;
        Map map = new HashMap();
        map.put(&quot;邓超&quot;, new Book(&quot;&quot;, 100));
        map.put(&quot;王宝强&quot;, &quot;马蓉&quot;);
        map.put(&quot;宋喆&quot;, &quot;马蓉&quot;);
        map.put(&quot;邓超&quot;, &quot;孙俪&quot;);
        map.put(null, &quot;刘亦菲&quot;);
        System.out.println(&quot;map=&quot; +map );

        //remove:根据键删除映射关系
        map.remove(null);
        System.out.println(&quot;map=&quot; +map );

        //通过键获得值
        Object val = map.get(&quot;王宝强&quot;);
        System.out.println(&quot;value = &quot; + val);

        //获取元素个数
        System.out.println(&quot;size = &quot; + map.size());

        //判断元素是否为空
        System.out.println(map.isEmpty());

        //清除l-v
        map.clear();

        //查找键是否存在
        System.out.println(map.containsKey(&quot;邓超&quot;));

    &#125;
&#125;

class Book &#123;
    private String name;
    private int num;

    public Book(String name, int num) &#123;
        this.name = name;
        this.num = num;
    &#125;
&#125;
</code></pre>
<p>Map的遍历</p>
<pre><code class="lang-java">package com.zzy.map_;

import java.util.*;

/**
 * @autho: 周钟炎
 * @version: 1.0
 */
public class Mapfor &#123;
    public static void main(String[] args) &#123;
        Map map = new HashMap();
        map.put(&quot;邓超&quot;, new Book(&quot;&quot;, 100));
        map.put(&quot;王宝强&quot;, &quot;马蓉&quot;);
        map.put(&quot;宋喆&quot;, &quot;马蓉&quot;);
        map.put(&quot;邓超&quot;, &quot;孙俪&quot;);
        map.put(null, &quot;刘亦菲&quot;);

        Set keyset = map.keySet();
        //第一组,通过key获取vales
        for (Object o : keyset) &#123;
            System.out.println(o + &quot;-&quot; + map.get(o));
        &#125;
        Iterator it = keyset.iterator();
        while (it.hasNext()) &#123;
            Object next =  it.next();
            System.out.println(next + &quot;-&quot; + map.get(next));
        &#125;

        //第二组，取出所有的values
        Collection values = map.values();
        for (Object o : values) &#123;
            System.out.println(o);
        &#125;
        Iterator it2= values.iterator();
        while (it2.hasNext()) &#123;
            Object next =  it2.next();
            System.out.println(next);
        &#125;

        //通过EntrySet
        Set set = map.entrySet();
        for (Object o : set) &#123;
            //向下转型
            Map.Entry entry = (Map.Entry) o;
            System.out.println(entry.getKey() + &quot;-&quot; + entry.getValue());
        &#125;
        Iterator it3 = set.iterator();
        while (it3.hasNext()) &#123;
            Object next =  it3.next();
            Map.Entry entry = (Map.Entry) next;
            System.out.println(entry.getKey() + &quot;-&quot; +entry.getValue());
        &#125;
    &#125;
&#125;
</code></pre>

</div>


    <div class="post-guide">
        <div class="item left">
            
              <a href="/2021/07/24/%E5%89%8D%E7%AB%AF/vue%E5%AD%A6%E4%B9%A0/">
                  <i class="fa fa-angle-left" aria-hidden="true"></i>
                  vue学习
              </a>
            
        </div>
        <div class="item right">
            
              <a href="/2021/07/12/Java%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">
                设计模式
                <i class="fa fa-angle-right" aria-hidden="true"></i>
              </a>
            
        </div>
    </div>




<script>
	
	
</script>
	</div>
	<div id="footer">
	<p>
	©2019-<span id="footerYear"></span> 
	<a href="/">Regular</a> 
	
	
		|
		<span id="busuanzi_container_site_pv">
			pv
			<span id="busuanzi_value_site_pv"></span>
		</span>
		|
		<span id="busuanzi_container_site_uv"> 
			uv
			<span id="busuanzi_value_site_uv"></span>
		</span>
	
	<br>
	Theme <a href="//github.com/wujun234/hexo-theme-tree" target="_blank">Tree</a>
	by <a href="//github.com/wujun234" target="_blank">WuJun</a>
	Powered by <a href="//hexo.io" target="_blank">Hexo</a>
	</p>
</div>
<script type="text/javascript"> 
	document.getElementById('footerYear').innerHTML = new Date().getFullYear() + '';
</script>
	<button id="totop-toggle" class="toggle"><i class="fa fa-angle-double-up" aria-hidden="true"></i></button>
</body>
</html>