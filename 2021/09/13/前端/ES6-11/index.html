<!DOCTYPE html>
<html lang="en">

<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8">
	<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
	
	<!-- title -->
	
	<title>
	
		ES6-11 | 
	 
	立志做个全栈
	</title>
	
	<!-- keywords,description -->
	 

	<!-- favicon -->
	
	<link rel="shortcut icon" href="/favicon.ico">
	


	<!-- search -->
	<script>
		var searchEngine = "https://www.google.com/search?q=";
		if(typeof searchEngine == "undefined" || searchEngine == null || searchEngine == ""){
			searchEngine = "https://www.google.com/search?q=";
		}
		var homeHost = "zzygeo.cn";
		if(typeof homeHost == "undefined" || homeHost == null || homeHost == ""){
			homeHost = window.location.host;
		}
	</script>


	
<link rel="stylesheet" href="/css/main.css">

	
<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css">

	
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.17.1/build/styles/darcula.min.css">

	
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">


	
<script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>

	
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>

	
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.17.1/build/highlight.min.js"></script>

	
<script src="https://cdn.jsdelivr.net/npm/jquery-pjax@2.0.1/jquery.pjax.min.js"></script>

	
<script src="/js/main.js"></script>

	
		
<script src="https://cdn.jsdelivr.net/npm/leancloud-storage/dist/av-min.js"></script>

		
<script src="https://cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js"></script>

	
	
		<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	
<meta name="generator" content="Hexo 5.2.0"><link rel="alternate" href="/atom.xml" title="立志做个全栈" type="application/atom+xml">
</head>

<body>
	<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?3efe99c287df5a1d6f0d02d187e403c1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

<header id="header">
    <a id="title" href="/" class="logo">立志做个全栈</a>

	<ul id="menu">
		<li class="menu-item">
			<a href="/about" class="menu-item-link">ABOUT</a>
		</li>
	

	
		<li class="menu-item">
			<a href="/categories" class="menu-item-link">分类</a>
		</li>
	

		<li class="menu-item">
			<a href="https://github.com/wujun234/uid-generator-spring-boot-starter" class="menu-item-link" target="_blank">
				UidGenerator
			</a>
		</li>
		<li class="menu-item">
			<a href="https://github.com/zzygeo" class="menu-item-link" target="_blank">
				<i class="fa fa-github fa-2x"></i>
			</a>
		</li>
	</ul>
</header>

	
<div id="sidebar">
	<button id="sidebar-toggle" class="toggle" ><i class="fa fa-arrow-right " aria-hidden="true"></i></button>
	
	<div id="site-toc">
		<input id="search-input" class="search-input" type="search" placeholder="按回车全站搜索">
		<div id="tree">
			

			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										C++
									</a>
									
							<ul>
								<li class="file">
									<a href="/2021/05/31/C++/C++%E7%9F%A5%E8%AF%86%E7%82%B9/">
										C++知识点
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2021/06/21/C++/Visual%20Studio%E6%B7%BB%E5%8A%A0%E5%BA%93/">
										Visual Studio添加库
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2021/06/29/C++/%E6%91%84%E5%BD%B1%E6%B5%8B%E9%87%8F/">
										摄影测量
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										Cesium
									</a>
									
							<ul>
								<li class="file">
									<a href="/2021/06/10/Cesium/Cesiun%E5%AD%A6%E4%B9%A0/">
										Cesiun学习
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										Hexo
									</a>
									
							<ul>
								<li class="file">
									<a href="/2021/01/20/Hexo/github%E8%AE%BE%E7%BD%AE%E8%87%AA%E5%B7%B1%E7%9A%84%E5%9F%9F%E5%90%8D/">
										github设置自己的域名
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/10/02/Hexo/hexo-d-%E5%87%BA%E7%8E%B0%E9%94%99%E8%AF%AF%E7%9A%84%E7%94%A8%E6%88%B7%E5%90%8D%E5%92%8C%E5%AF%86%E7%A0%81%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/">
										hexo-d-出现错误的用户名和密码的解决办法
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/09/24/Hexo/markdown%E8%AF%AD%E6%B3%95/">
										markdown语法
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/10/02/Hexo/%E6%96%B0%E7%94%B5%E8%84%91%E4%B8%8A%E9%83%A8%E7%BD%B2hexo/">
										新电脑上部署hexo
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										Java基础
									</a>
									
							<ul>
								<li class="file">
									<a href="/2021/05/24/Java%E5%9F%BA%E7%A1%80/IDEA%E5%BF%AB%E6%8D%B7%E9%94%AE/">
										IDEA快捷键
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2021/07/13/Java%E5%9F%BA%E7%A1%80/Java%E7%9F%A5%E8%AF%86%E7%82%B9/">
										Java知识点
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2021/07/12/Java%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">
										设计模式
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										PCL
									</a>
									
							<ul>
								<li class="file">
									<a href="/2020/10/04/PCL/PCL-1-11-Visual-Studio-2019-%E9%85%8D%E7%BD%AE/">
										PCL-1-11-Visual-Studio-2019-配置
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/12/27/PCL/pcl-vs-cmake%E7%BC%96%E8%AF%91/">
										pcl-vs-cmake编译
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										Ubuntu
									</a>
									
							<ul>
								<li class="file">
									<a href="/2021/03/14/Ubuntu/Ubuntu%E6%9B%B4%E6%8D%A2%E6%BA%90%E6%95%99%E7%A8%8B/">
										Ubuntu更换源教程
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/10/23/Ubuntu/Unable-to-access-https-gitee-com-%E8%87%AA%E5%B7%B1%E7%9A%84%E9%A1%B9%E7%9B%AE-Could-not-resolve-host-gitee-com%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3/">
										Unable-to-access-https-gitee-com-自己的项目-Could-not-resolve-host-gitee-com问题的解决
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2021/03/14/Ubuntu/dpkg%E8%A2%AB%E4%B8%AD%E6%96%AD%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/">
										dpkg被中断的解决办法
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2021/03/14/Ubuntu/ubuntu%E4%B8%8B%E7%9A%84firefox%E6%97%A0%E6%B3%95%E6%92%AD%E6%94%BE%E8%A7%86%E9%A2%91%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">
										ubuntu下的firefox无法播放视频解决方案
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2021/03/14/Ubuntu/ubuntu%E4%B8%8B%E8%A7%A3%E5%86%B3wps2019%E7%BC%BA%E5%B0%91%E5%AD%97%E4%BD%93%E9%97%AE%E9%A2%98/">
										ubuntu下解决wps2019缺少字体问题
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2021/03/14/Ubuntu/ubuntu%E5%AE%89%E8%A3%85gcc%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB%E6%8A%A5%E9%94%99/">
										ubuntu安装gcc依赖关系报错
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2021/03/14/Ubuntu/ubuntu%E5%AE%89%E8%A3%85vim%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB%E6%8A%A5%E9%94%99/">
										ubuntu安装vim依赖关系报错
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2021/03/14/Ubuntu/ubuntu%E9%85%8D%E7%BD%AEC-C-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/">
										ubuntu配置C-C-开发环境
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2021/03/14/Ubuntu/%E5%AE%89%E8%A3%85snap/">
										安装snap
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										其他
									</a>
									
							<ul>
								<li class="file">
									<a href="/2020/09/26/%E5%85%B6%E4%BB%96/%E6%88%91%E7%9A%84Office%E6%BF%80%E6%B4%BB%E7%A0%81/">
										我的Office激活码
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/10/04/%E5%85%B6%E4%BB%96/%E8%B5%84%E6%BA%90/">
										资源
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										前端
									</a>
									
							<ul>
								<li class="file active">
									<a href="/2021/09/13/%E5%89%8D%E7%AB%AF/ES6-11/">
										ES6-11
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2021/08/25/%E5%89%8D%E7%AB%AF/JS%E7%BB%86%E8%8A%82/">
										JS细节
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2021/08/17/%E5%89%8D%E7%AB%AF/css%E7%BB%86%E8%8A%82/">
										css细节
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2021/07/24/%E5%89%8D%E7%AB%AF/vue%E5%AD%A6%E4%B9%A0/">
										vue学习
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
		</div>
	</div>
</div>

	<!-- 引入正文 -->
	<div id="content">
		<h1 id="article-title">

	ES6-11
</h1>
<div class="article-meta">
	
	<span>Regular</span>
	<span>2021-09-13 23:32:33</span>
		<div id="article-categories">
    
		<span>Categories：</span>
            
    

    
		<span>Tags：</span>
            
    
		</div>

</div>

<div id="article-content">
	<h1 id="let和const"><a href="#let和const" class="headerlink" title="let和const"></a>let和const</h1><ol>
<li><p>变量不能重复声明</p>
</li>
<li><p>块级作用域</p>
</li>
<li><p>不存在变量提升</p>
</li>
<li><p>不影响作用域链</p>
</li>
</ol>
<pre><code class="lang-js">&#123;
      let school = &quot;中山大学&quot;;
      function fn() &#123;
        console.log(school);
      &#125;
      fn();
    &#125;
</code></pre>
<p>案例</p>
<pre><code class="lang-js">let item = document.getElementsByClassName(&quot;item&quot;);
    for (var i = 0; i &lt; item.length; i++) &#123;
      //这个i是在全局作用域,回调函数在函数点击时触发，这时候i已经成3了
      item[i].onclick = function() &#123;
        item[i].style.backgroundColor = &quot;black&quot;;
      &#125;
    &#125;
</code></pre>
<p>const细节：</p>
<ol>
<li>一定要赋初始值</li>
<li>一般常量使用大写</li>
<li>常量的值不能修改</li>
<li>块级作用域</li>
<li>对于数组和对象的元素修改，不算做对常量的修改，不会报错</li>
</ol>
<h1 id="变量赋值"><a href="#变量赋值" class="headerlink" title="变量赋值"></a>变量赋值</h1><pre><code class="lang-js">const F4 = [&#39;大狗&#39;,&#39;二狗&#39;,&#39;死狗&#39;,&#39;狗贼&#39;];
let [xiao, liu, zhao, song] = F4;

console.log(xiao);
console.log(liu);
</code></pre>
<pre><code class="lang-js">const zhao = &#123;
      name: &#39;赵本山&#39;,
      age: 26,
      xiaopin: function() &#123;
        console.log(&#39;我可以演小品...&#39;);
      &#125;
    &#125;

let &#123; name, age, xiaopin&#125; = zhao;
console.log(name);
console.log(age);
console.log(xiaopin);
xiaopin();
</code></pre>
<h1 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h1><p>内容中可以直接出现换行符</p>
<p>变量拼接</p>
<pre><code class="lang-js">let star = &#39;张国荣&#39;;
let out = `$&#123;star&#125;是我最喜欢的歌手...`;
console.log(out);
</code></pre>
<h1 id="简化对象写法"><a href="#简化对象写法" class="headerlink" title="简化对象写法"></a>简化对象写法</h1><pre><code class="lang-js">/* ES6允许在大括号里，直接写入变量和函数，作为对象的属性和方法，
    这样书写更加简洁 */
    let name =&quot;中山大学&quot;;
    let change = function () &#123;
      console.log(&quot;我们可以改变你...&quot;);
    &#125;
    const school = &#123;
      name,
      change,
      improve() &#123;
        console.log(&quot;我们可以提高你的技能...&quot;);
      &#125;
    &#125;
    console.log(school);
</code></pre>
<h1 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h1><p>this是静态的,this始终指向函数声明时所在作用域下的this的值</p>
<pre><code class="lang-js">/* ES6允许使用[箭头]（=&gt;）定义函数 */
  //  let fn = function(a, b) &#123;
  //   return a + b;
  //  &#125;
   //调用函数
  //  let res = fn(1, 2);
  //  console.log(res);

  function getName() &#123;
    console.log(this.name);
  &#125;

  let getName2 = () =&gt; &#123;
    console.log(this.name);
  &#125;

  window.name = &quot;尚硅谷&quot;;
  const school = &#123;
    name: &quot;ATGUIGU&quot;
  &#125;

  //直接调用
  getName();  //尚硅谷
  getName2(); //尚硅谷

  getName.call(school); //ATGUIGU
  getName2.call(school);  //尚硅谷
</code></pre>
<p>不能作为构造函数实例化对象</p>
<pre><code class="lang-js"> //不能作为构造函数实例化对象
  //  let Person = function(name, age) &#123;
  //    this.name = name;
  //    this.age = age;
  //  &#125;
  //  let me = new Person(&quot;xiao&quot;, 30);
  //  console.log(me); //可行

  let Person = (name, age) =&gt; &#123;
    this.name = name;
    this.age = age;
  &#125;

  let me = new Person(&quot;xiao&quot;, 30);
  console.log(me); //Person is not a constructor
</code></pre>
<p>不能使用arguments变量</p>
<pre><code class="lang-js"> let fn = () =&gt; &#123;
     console.log(arguments);
   &#125;
   fn(100); //arguments is not defined
</code></pre>
<p>箭头函数的简写：</p>
<pre><code class="lang-js">//省略小括号，当形参有且只有一个的时候
    let add = num =&gt; &#123;
      return ++num;
    &#125;
    console.log(add(9));
</code></pre>
<pre><code class="lang-js">  //省略花括号,当代码体只有一条语句的时候,此时return语句也需要省略
    //而且语句的执行结果就是函数的返回值
    let pow = num =&gt;  num * num;
    console.log(pow(8));  //64
</code></pre>
<p>案例</p>
<pre><code class="lang-js">const arr = [1, 6, 9, 10, 100, 25];
      const res = arr.filter(item =&gt; item % 2 === 0 );
      console.log(res);
</code></pre>
<p>箭头函数适合与this无关的回调。定时器，数组的方法的回调。</p>
<p>箭头函数不适合与this有关的回调。事件回调，对象的方法。</p>
<h1 id="ES6允许给函数参数赋初值"><a href="#ES6允许给函数参数赋初值" class="headerlink" title="ES6允许给函数参数赋初值"></a>ES6允许给函数参数赋初值</h1><pre><code class="lang-js"> //ES6允许给函数参数赋初始值
      //1.形参初始值，具有默认值的参数，一般位置要靠后（潜规则）
      // function add(a, b, c = 10) &#123;
      //   return a + b + c;
      // &#125;
      // let res = add(1, 2);
      // console.log(res);

      //与结构赋值结合
      function connect(&#123; host = &quot;127.0.0.1&quot;, username, password, port &#125;) &#123;
        this.host = host;
        this.username = username;
        this.password = password;
        this.port = port;
      &#125;
      connect(&#123;
        host: &quot;localhost&quot;,
        username: &quot;root&quot;,
        password: &quot;root&quot;,
        port: &quot;port&quot;,
      &#125;);
</code></pre>
<h1 id="rest参数"><a href="#rest参数" class="headerlink" title="rest参数"></a>rest参数</h1><pre><code class="lang-js"> //ES6引入rest参数，用于获取函数的实参，用来代替arguments
      //ES5获取实参的方法
      // function date() &#123;
      //   console.log(arguments);
      // &#125;
      // date(1, 2, 3);

      //rest参数
      // function date(...args) &#123;
      //   console.log(args);
      // &#125;
      // date(1,2,3);

      //rest参数必须放到实参最后,不然会报错
      function date(a, b, ...args) &#123;
        console.log(a);
        console.log(b);
        console.log(args);
      &#125;
      date(1, 2, 3, 4, 5, 6, 7);
</code></pre>
<h1 id="拓展运算符"><a href="#拓展运算符" class="headerlink" title="拓展运算符"></a>拓展运算符</h1><pre><code class="lang-js">const tfboys = [&#39;易烊千玺&#39;,&#39;王源&#39;,&#39;王俊凯&#39;];

      function fn() &#123;
        console.log(arguments);
      &#125;
      fn(...tfboys);  //类似于将(a,b,c)，将每个值取出来作为实参
</code></pre>
<pre><code class="lang-js"> const person = [&#39;张三&#39;,&#39;李四&#39;,&#39;王五&#39;];
      const person2 = [&#39;赵六&#39;,&#39;黄七&#39;];
      const person3 = person.concat(person2);
      console.log(person3);
      const person4 = [...person, ...person2];
      console.log(person4);
</code></pre>
<h1 id="Symbol数据类型"><a href="#Symbol数据类型" class="headerlink" title="Symbol数据类型"></a>Symbol数据类型</h1><p>ES6引入了一种新的原始数据类型Symbol，表示独一无二的值。他是JS语言的第七种数据类型，是一种类似于字符串的数据类型。</p>
<p>特点：</p>
<p>Symbol的值是唯一的，用来解决命名冲突的问题。</p>
<p>Symbol值不能与其他数据进行运算。</p>
<p>Symbol定义的对象属性不能使用for…in循环遍历，但是可以使用Reflect.ownKeys来获取对象的所有键名。</p>
<pre><code class="lang-js">//创建stmbol
      let s = Symbol();
      console.log(s, typeof s);

      let s2 = Symbol(&#39;尚硅谷&#39;);
      let s3 = Symbol(&#39;尚硅谷&#39;);
      console.log(s2 === s3); //false

      let s4 = Symbol.for(&#39;尚硅谷&#39;);
      let s5 = Symbol.for(&#39;尚硅谷&#39;);
      console.log(s4 === s5); //true
</code></pre>
<p>案例：</p>
<pre><code class="lang-js"> let game = &#123;
        name: &quot;俄罗斯方块&quot;,
        up() &#123;
          console.log(&quot;@&quot;);
        &#125;,
        down() &#123;
          console.log(&quot;!&quot;);
        &#125;
      &#125;;
      //这么写是拿不到这个字符串的值的，必须来一个去接受它
      // game[Symbol(&#39;up&#39;)] = function() &#123;
      //   console.log(&#39;我可以改变形状...&#39;);
      // &#125;

      //必须拿一个去接受它，然后就能去调用了
      let up = Symbol();
      game[up] = function() &#123;
        console.log(&#39;我可以改变形状...&#39;);
      &#125;
      game[up]();
    //顺便体会下.方式和[]的差别
</code></pre>
<h2 id="Symbol内置属性"><a href="#Symbol内置属性" class="headerlink" title="Symbol内置属性"></a>Symbol内置属性</h2><p>symbol有一些内置属性，用于特定方法下进行使用，可以拓展方法的功能。</p>
<h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><p>迭代器是一种接口，为不同的数据结构提供统一的访问机制。任何数据结构只要部署Iterator接口，就可以完成遍历操作。</p>
<p>原生聚类Iterator接口的数据（可用for of遍历），主要是原型上存在Symbol.iterator的函数.</p>
<ol>
<li>Array</li>
<li>Arguments</li>
<li>Set</li>
<li>Map</li>
<li>String</li>
<li>TypedArray</li>
<li>NodeList</li>
</ol>
<p>工作原理：</p>
<ol>
<li>创建一个指针对象，指向当前数据结构的起始位置</li>
<li>第一次调用对象的next方法，指针自动指向数据结构的第一个成员</li>
<li>接下来不断调用next方法，指针一直往后移动，直到指向最后一个成员</li>
<li>每次调用next方法返回一个包含value和done属性的对象</li>
</ol>
<pre><code class="lang-js">const xiyou = [&#39;唐僧&#39;,&#39;孙悟空&#39;,&#39;猪八戒&#39;,&#39;沙僧&#39;];
      // //使用for...of遍历数组
      // for (let item of xiyou) &#123;
      //   console.log(item);
      // &#125;

      let iterator = xiyou[Symbol.iterator]();
      console.log(iterator);
      console.log(iterator.next());
      console.log(iterator.next());
      console.log(iterator.next());
      console.log(iterator.next()); //done: false 这个表示是否遍历完数组的状态
      console.log(iterator.next()); //done: true
</code></pre>
<pre><code class="lang-js">//自定义遍历规则
      //自己构建Symbol.iterator的规则
      const obj = &#123;
        name: &quot;fpx&quot;,
        components: [&quot;xiaoming&quot;, &quot;doinb&quot;, &quot;xiaotian&quot;],
        [Symbol.iterator]() &#123;
          let index = 0;
          return &#123;
            next: () =&gt; &#123;
              if (index &lt; this.components.length) &#123;
                const res = &#123; value: this.components[index], done: false &#125;;
                index++;
                return res;
              &#125; else &#123;
                return &#123; value: undefined, done: &#39;true&#39;&#125;;
              &#125;
            &#125;,
          &#125;;
        &#125;,
      &#125;;

      for (let item of obj) &#123;
        console.log(item);
      &#125;
</code></pre>
<h1 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h1><p>生成器是ES6提供的一种异步编程解决方案，语法行为与传统函数完全不同。</p>
<pre><code class="lang-js">//生成器，特殊的函数
      //yield相当于函数的分隔符
      function *gen() &#123;
        yield &#39;1&#39;;
        yield &#39;2&#39;;
        yield &#39;3&#39;;
      &#125;

      let iterator = gen();
      console.log(iterator.next());
      console.log(iterator.next());
      console.log(iterator.next());

    //遍历
    for (let item of gen()) &#123;
        console.log(item);
      &#125;
</code></pre>
<pre><code class="lang-js">function* gen(arg) &#123;
        console.log(arg);
        let one = yield 111;
        console.log(one);
        let two = yield 222;
        console.log(two);
        yield 333;
      &#125;

      let iterator = gen(&#39;AAA&#39;);
      console.log(iterator.next());  //AAA,传入参数没问题

      //输入的结果将作为第一个yield的返回值
      console.log(iterator.next(&#39;BBB&#39;)); //BBB

      //输入的结果将作为第二个yield的返回值
      console.log(iterator.next(&#39;CCC&#39;)); //CCC
</code></pre>
<pre><code class="lang-js"> function one() &#123;
        setTimeout(() =&gt; &#123;
          console.log(111);
          iterator.next();
        &#125;, 1000)
      &#125;

      function two() &#123;
        setTimeout(() =&gt; &#123;
          console.log(222);
          iterator.next();
        &#125;, 2000)
      &#125;

      function three() &#123;
        setTimeout(() =&gt; &#123;
          console.log(333);
          iterator.next();
        &#125;, 3000)
      &#125;

      function *gen() &#123;
        yield one();
        yield two();
        yield three();
      &#125;

      let iterator = gen();
      iterator.next();
</code></pre>
<pre><code class="lang-js">//异步获取用户数据、订单数据、商品数据
      function getUsers() &#123;
        setTimeout(() =&gt; &#123;
          let data = &quot;用户数据&quot;;
          iterator.next(data);
        &#125;, 1000)
      &#125;

      function getOrders() &#123;
        setTimeout(() =&gt; &#123;
          let data = &quot;订单数据&quot;;
          iterator.next(data)
        &#125;, 1000)
      &#125;

      function getGoods() &#123;
        setTimeout(() =&gt; &#123;
          let data = &quot;商品数据&quot;;
          iterator.next(data)
        &#125;, 1000)
      &#125;

      function *gen() &#123;
        let users = yield getUsers();
        console.log(users);
        let orders = yield getOrders();
        console.log(orders);
        let goods = yield getGoods();
        console.log(goods);
      &#125;

      let iterator = gen();
      iterator.next()
</code></pre>
<h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><p>Promise是ES6引入的异步编程的新解决方案。语法上Promise是一个构造函数，用来封装异步操作并可以获取其成功或失败的结果。</p>
<ol>
<li>Promise构造函数：Promise(excutor){}</li>
<li>Promise.prototype.then方法</li>
<li>Promise.prototype.catch方法</li>
</ol>
<pre><code class="lang-js">//实例化Promise对象
      const p = new Promise(function(resolve, reject) &#123;
        setTimeout(function() &#123;
          // let data = &quot;数据库中的用户数据&quot;;
          //状态：成功
          // resolve(data);
          let err = &quot;数据读取失败&quot;;
          reject(err);
        &#125;, 1000)
      &#125;)

      //调用promise对象的then方法
      //前面调用了resolve方法，则会调用成功的回调函数
      p.then(function(value) &#123;
        console.log(value);
      &#125;, function(reason) &#123;
        console.log(reason);
      &#125;)
</code></pre>
<pre><code class="lang-js">//引入fs模块
const fs = require(&#39;fs&#39;);

//调用方法读取文件
// fs.readFile(&quot;./resources/长相思.md&quot;,(err, data) =&gt; &#123;
//   if (err) throw err;
//   console.log(data.toString());
// &#125;);

//使用Promise封装一个异步操作,所以里面写异步的操作
const p = new Promise(function(reslove, reject) &#123;
  //读取文件就是异步操作
  fs.readFile(&#39;./resources/长相思.md&#39;,(err, data) =&gt; &#123;
    if (err) reject(err);
    reslove(data)
  &#125;);
&#125;)

p.then(function(value)&#123;
  console.log(value.toString());
&#125;, function(reason) &#123;
  console.log(reason);
&#125;)

//这样就可以避免回调的嵌套
</code></pre>
<h2 id="promise-then方法"><a href="#promise-then方法" class="headerlink" title="promise.then方法"></a>promise.then方法</h2><pre><code class="lang-js">const p = new Promise((resolve, reject) =&gt; &#123;
        setTimeout(() =&gt; &#123;
          resolve(&#39;用户数据&#39;);
        &#125;,1000)
      &#125;)

      //then方法返回的直接也是Promise对象,这个对象状态由回调函数的执行结果决定
      //1.如果回调函数中返回的值是非promise类型的属性，状态为成功，返回值为对象的成功的值
      //2.如果回调函数中返回的值是promise对象，则成功还是失败的状态是根据返回的promise的状态决定的
      //3.抛出异常
      const res = p.then(value =&gt; &#123;
        console.log(value);
        //1.非promise类型的数据
        // return 123;

        //2.是promise对象
        return new Promise((resolve, reject) =&gt; &#123;
          // resolve(&quot;ok&quot;);
          // reject(&quot;失败了&quot;);
          throw new Error(&quot;出错了&quot;);
        &#125;)
      &#125;, reason =&gt; &#123;
        console.log(reason);
      &#125;)

      //这样的特性使得promise.then的方法是可以链式调用的
      //这样就可以避免回调地狱
      const result = p.then(value =&gt; &#123;&#125;, reason =&gt; &#123;&#125;)
      .then(value =&gt; &#123;&#125;, reason =&gt; &#123;&#125;)

      console.log(res);
</code></pre>
<pre><code class="lang-js"> const p = new Promise((resolve, reject) =&gt; &#123;
        setTimeout(() =&gt; &#123;
          reject(&quot;出错了...&quot;);
        &#125;, 1000)
      &#125;)

      //catch的作用相当p.thedn不写第一个函数的作用
      p.catch(function(reason) &#123;
        console.warn(reason);
      &#125;)
</code></pre>
<h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><p>ES6提供了新的数据结构Set(集合)。它类似于数组，但成员的值都是唯一的。集合实现了iterator接口。所以可以使用拓展运算符和for…of进行遍历。</p>
<p>集合的构建和方法的使用</p>
<pre><code class="lang-js">//集合的声明
      let s = new Set();
      let s2 = new Set([&quot;大事儿&quot;, &quot;小事儿&quot;, &quot;好事儿&quot;, &quot;坏事儿&quot;]);
      console.log(s, typeof s);
      console.log(s2, typeof s2);

      //元素个数
      console.log(s2.size);

      //添加新元素
      s2.add(&#39;喜事儿&#39;);
      console.log(s2);

      //删除元素
      s2.delete(&#39;坏事儿&#39;);
      console.log(s2);

      //检测是否有某个元素
      let res = s2.has(&#39;大事儿&#39;);
      console.log(res);

      //清空集合
      // s2.clear();
      // console.log(s2);

      //遍历
      for (let item of s2) &#123;
        console.log(item);
      &#125;
</code></pre>
<p>案例：</p>
<p>数组去重：</p>
<pre><code class="lang-js">let arr = [1,2,3,4,5,4,3,2,1];

      //数组去重，利用集合特性
      // let res = [...new Set(arr)];
      // console.log(res);

      let arr2 = [];
      for (let i in arr) &#123;
        if (arr2.length === 0) &#123;
          arr2.push(arr[i]);
          continue;
        &#125;
        if (arr2.indexOf(arr[i]) === -1) &#123;
          arr2.push(arr[i]);
        &#125;
      &#125;
      console.log(arr2);
</code></pre>
<p>数组求交集：</p>
<pre><code class="lang-js"> let arr = [1, 2, 3, 4, 5, 4, 3, 2, 1];
  let arr2 = [4, 5, 6, 5, 6];
      //交集
      let arr3 = [...new Set(arr)].filter((item) =&gt; arr2.indexOf(item) !== -1)
      console.log(arr3);
</code></pre>
<p>数组求并集：</p>
<pre><code class="lang-js"> let arr = [1, 2, 3, 4, 5, 4, 3, 2, 1];

      let arr2 = [4, 5, 6, 5, 6];

      //并集
      let union = [...new Set([...arr, ...arr2])];
      console.log(union);
</code></pre>
<p>数组求差集：</p>
<pre><code class="lang-js"> let arr = [1, 2, 3, 4, 5, 4, 3, 2, 1];

      let arr2 = [4, 5, 6, 5, 6];
      //求差集
      let diff = [...new Set(arr)].filter(item =&gt; !new Set(arr2).has(item))
      console.log(diff);
</code></pre>
<h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p>ES6提供了Map数据结构。它类似于对象，也是键值对的集合。但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当做键。Map也实现了iterator接口，所以可以使用【拓展运算符】和for…of进行遍历，map的常见属性和方法如下：</p>
<pre><code class="lang-js">let m = new Map();

      //添加元素
      m.set(&quot;name&quot;, &quot;尚硅谷&quot;);
      m.set(&quot;change&quot;, function () &#123;
        console.log(&quot;我们可以改变你...&quot;);
      &#125;);

      let key = &#123;
        school: &quot;ATGUIGU&quot;,
      &#125;;
      m.set(key, [&quot;北京&quot;, &quot;上海&quot;, &quot;深圳&quot;]);

      //元素个数
      console.log(m.size);

      //删除
      // m.delete(&quot;name&quot;);

      //获取
      console.log(m.get(&quot;change&quot;));

      //清空
      // m.clear();
      // console.log(m);

      //遍历,获取的是数组键值对
      for (let item of m) &#123;
        console.log(item);
      &#125;
</code></pre>
<h1 id="函数以及类的继承"><a href="#函数以及类的继承" class="headerlink" title="函数以及类的继承"></a>函数以及类的继承</h1><p>函数的继承：</p>
<pre><code class="lang-js">//ES5的继承
function Phone(brand, price) &#123;
      this.brand = brand;
      this.price = price;
    &#125;

    Phone.prototype.call = function() &#123;
      console.log(&#39;我可以打电话...&#39;);
    &#125;

    function SmartPhone(brand, price, color, size) &#123;
      //函数call方法，改变this的指向,传入参数为实参
      Phone.call(this, brand, price);
      this.color = color;
      this.size = size;
    &#125;

    //这里往原型上添加属性，相当于给SmartPhone找了个爸爸
    SmartPhone.prototype = new Phone;
    SmartPhone.prototype.constructor = SmartPhone;

    SmartPhone.prototype.photo = function() &#123;
      console.log(&#39;我可以拍照...&#39;);
    &#125;

    SmartPhone.prototype.playGame = function() &#123;
      console.log(&#39;我可以玩游戏...&#39;);
    &#125;

    const chuizi = new SmartPhone(&#39;锤子&#39;, 2499, &#39;黑色&#39;, &#39;5.5inch&#39;);

    console.log(chuizi);
</code></pre>
<p>类的继承：</p>
<pre><code class="lang-js"> class Phone &#123;
        //构造方法
        constructor(brand, price) &#123;
          this.brand = brand;
          this.price = price;
        &#125;

        //父类的成员属性
        call()&#123;
          console.log(&quot;我可以打电话...&quot;);
        &#125;
      &#125; 

      class SmartPhone extends Phone &#123;
        constructor(brand, price, color, size) &#123;
          super(brand, price);
          this.color = color;
          this.size = size;
        &#125;

        photo() &#123;
          console.log(&quot;拍照...&quot;);
        &#125;

        playGame() &#123;
          console.log(&quot;玩游戏&quot;);
        &#125;
        //可以实现方法的重写，就近一致原则
        call() &#123;
          console.log(&quot;我可以进行视频通话...&quot;);
        &#125;
      &#125;

      const xiaomi = new SmartPhone(&quot;小米&quot;, 799, &quot;黑色&quot;, &quot;4.7inch&quot;);
      console.log(xiaomi);
      xiaomi.call();
      xiaomi.photo();
      xiaomi.playGame();
</code></pre>
<h1 id="类的get和set方法"><a href="#类的get和set方法" class="headerlink" title="类的get和set方法"></a>类的get和set方法</h1><pre><code class="lang-js">//get 和 set
      class Phone &#123;
        get price() &#123;
          console.log(&quot;价格属性被读取了...&quot;);
          return &quot;i love you&quot;;
        &#125;

        set price(newVal) &#123;//必须传参数
          console.log(&quot;价格属性被修改了...&quot;);
          console.log(newVal);
        &#125;
      &#125;

      //实例化对象
      let s = new Phone();
      console.log(s.price);
      s.price = 10; //这个语句会引起set的调用, 参数newVal就是更改的值。
</code></pre>
<h1 id="数值扩展"><a href="#数值扩展" class="headerlink" title="数值扩展"></a>数值扩展</h1><pre><code class="lang-js">//JS的数值扩展
     /* Number.EPSILON是JavaScript 表示的最小精度
     当两个数的差值小于这个精度时，即可认为这两个数相等 */
      console.log(0.1 + 0.2 === 0.3); //false

      function equal(a, b) &#123;
        return (Math.abs(a - b) &lt; Number.EPSILON);
      &#125;

      console.log(equal(0.1 + 0.2, 0.3));

      //进制
      let b = 0b1010;
      console.log(b);

      let o = 0o222;
      console.log(o);

      let x = 0xff;
      console.log(x);

      //Number.isFinite 检测一个数值是否为优先数
      console.log(Number.isFinite(100));
      console.log(Number.isFinite(100 / 0));

      //其他的看Number方法
</code></pre>
<pre><code class="lang-js">//判断两个值是否为同一个值。
      console.log(Object.is(120, 120));
      console.log(Object.is(NaN, NaN)); //true
      console.log(NaN === NaN); //false

      //Object.assign 对象的合并
      const config1 = &#123;
        host: &#39;localhost&#39;,
        port: 3306,
        name: &#39;root&#39;,
        pass: &#39;root&#39;
      &#125;

      const config2 = &#123;
        host: &#39;http://atguigu.com&#39;,
        port: 33060,
        name: &#39;atguigu.com&#39;,
        pass: &#39;iloveyou&#39;
      &#125;
      //如果遇见同名的对象，后面的会把前面的覆盖掉
      console.log(Object.assign(config1, config2));

      //Object.setPrototypeOf 设置原型对象
      const school = &#123;
        name: &#39;尚硅谷&#39;
      &#125;
      const cities = &#123;
        campus: [&#39;北京&#39;, &#39;上海&#39;, &#39;深圳&#39;]
      &#125;

      //把cities加到school上的原型上
      Object.setPrototypeOf(school, cities);
      console.log(Object.getPrototypeOf(school));
      console.log(school);
</code></pre>
<h1 id="Object的一些新方法"><a href="#Object的一些新方法" class="headerlink" title="Object的一些新方法"></a>Object的一些新方法</h1><pre><code class="lang-js">//判断两个值是否为同一个值。
      console.log(Object.is(120, 120));
      console.log(Object.is(NaN, NaN)); //true
      console.log(NaN === NaN); //false

      //Object.assign 对象的合并
      const config1 = &#123;
        host: &#39;localhost&#39;,
        port: 3306,
        name: &#39;root&#39;,
        pass: &#39;root&#39;
      &#125;

      const config2 = &#123;
        host: &#39;http://atguigu.com&#39;,
        port: 33060,
        name: &#39;atguigu.com&#39;,
        pass: &#39;iloveyou&#39;
      &#125;
      //如果遇见同名的对象，后面的会把前面的覆盖掉
      console.log(Object.assign(config1, config2));

      //Object.setPrototypeOf 设置原型对象
      const school = &#123;
        name: &#39;尚硅谷&#39;
      &#125;
      const cities = &#123;
        campus: [&#39;北京&#39;, &#39;上海&#39;, &#39;深圳&#39;]
      &#125;

      //把cities加到school上的原型上dsadas
      Object.setPrototypeOf(school, cities);
      console.log(Object.getPrototypeOf(school));
      console.log(school);
</code></pre>
<h1 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h1><p>模块化是值将一个大的程序文件，拆分成许多小的文件，然后将小文件组合起来。</p>
<p>ES6模块化语法</p>
<p>模块功能主要由两个命令构成：export和import</p>
<p>export命令用于规定模块的对外接口</p>
<p>import命令用于输入其他模块提供的功能</p>
<p>export的使用方法：</p>
<pre><code class="lang-js">//统一暴露
let school = &#39;尚硅谷&#39;;

function teach() &#123;
  console.log(&quot;我们可以教给你开发技能...&quot;);
&#125;

export &#123;school, teach&#125;;

//分别暴露
export let student = &#39;张三&#39;;

export function say() &#123;
  console.log(&#39;我可以说话...&#39;);
&#125;

//默认暴露
export default &#123;
  school: &#39;atguigu&#39;,
  change: function() &#123;
    console.log(&#39;我们可以改变你的技能...&#39;);
  &#125;
&#125;
</code></pre>
<p>import的使用方法：</p>
<pre><code class="lang-js">import &#123;school, teach&#125; from &#39;./m1.js&#39;;
      //当变量名由冲突的时候，可以使用别名形式进行替代
      import &#123;school as guigu, teach as tc&#125; from &#39;xxx&#39;;

      //当时用默认暴露时，这个名称就是default，所以调用方法的时候也是x.default.xx的形式
      //解构赋值写法
      import &#123;default as m3&#125; from &#39;xxx&#39;;

      //简便形式，只能针对默认暴露
      import m3 from &#39;./m1.js&#39;
</code></pre>
<pre><code class="lang-js"> &lt;script&gt;

    &lt;/script&gt;
    //app里面集中写所有的import语句，再通过这样的方式去使用
    &lt;script type=&quot;module&quot; src=&quot;./app.js&quot;&gt;&lt;/script&gt;
</code></pre>
<h1 id="async和await"><a href="#async和await" class="headerlink" title="async和await"></a>async和await</h1><p>async和await两种语法结合可以让异步代码像同步代码一样</p>
<p>async函数：</p>
<ol>
<li>async函数的返回值为promise对象</li>
<li>promise对象的结果由async函数执行的返回值决定</li>
</ol>
<p>await表达式：</p>
<ol>
<li>await必须写在async函数里</li>
<li>await右侧的表达式一般为promise对象</li>
<li>await返回的是promise成功的值</li>
<li>await的promise失败了就会抛出异常，需要通过try…catch捕获处理</li>
</ol>
<pre><code class="lang-js">//引入fs模块
const fs = require(&#39;fs&#39;);

//读取文件
function readFile(filePath) &#123;
  return new Promise((resolve, reject) =&gt; &#123;
    fs.readFile(filePath, (err, data) =&gt; &#123;
      if (err) &#123;
        reject(err);
      &#125;
      resolve(data)
    &#125;)
  &#125;)
&#125;

async function main() &#123;
  try &#123;
    let data = await readFile(&#39;./gushi.md&#39;);
    console.log(data.toString());
  &#125; catch (error) &#123;
    console.log(error);
  &#125;
&#125;

main();
</code></pre>
<h1 id="正则扩展"><a href="#正则扩展" class="headerlink" title="正则扩展"></a>正则扩展</h1><p>正则表达式命名分组：</p>
<pre><code class="lang-js">let str = &#39;&lt;a href=&quot;http://www.atguigu.com&quot;&gt;尚硅谷&lt;/a&gt;&#39;;

      const reg = /&lt;a href=&quot;(?&lt;url&gt;.*)&quot;&gt;(?&lt;text&gt;.*)&lt;\/a&gt;/;

      const result = reg.exec(str);
      console.log(result);
      console.log(result.groups.url);
</code></pre>
<p>正则拓展-dotAll模式-模式修正符</p>
<pre><code class="lang-js">// . 除换行符以外的任意单个字符
      let str = `
        &lt;ul&gt;
        &lt;li&gt;
          &lt;a&gt;肖生克的救赎&lt;/a&gt;
          &lt;p&gt;上映时间：1994-09-10&lt;/p&gt;
        &lt;/li&gt;
        &lt;li&gt;
          &lt;a&gt;阿甘正传&lt;/a&gt;
          &lt;p&gt;上映时间：1994-07-06&lt;/p&gt;
        &lt;/li&gt;
      &lt;/ul&gt;`;

      //声明正则
      // const reg = /&lt;li&gt;\s+&lt;a&gt;(.*?)&lt;\/a&gt;\s+&lt;p&gt;(.*?)&lt;\/p&gt;/g;
      //加上这个s，表示模式修正符，可以使.能匹配任意字符
      const reg2 = /&lt;li&gt;.*?&lt;a&gt;(.*?)&lt;\/a&gt;.*?&lt;p&gt;(.*?)&lt;\/p&gt;/gs;
      let res;
      let data = [];
      while ((res = reg2.exec(str))) &#123;
        data.push(&#123; title: res[1], time: res[2] &#125;);
      &#125;
      console.log(data);
</code></pre>
<h1 id="Object-fromEntries"><a href="#Object-fromEntries" class="headerlink" title="Object.fromEntries"></a>Object.fromEntries</h1><pre><code class="lang-js"> //二维数组
     //fromEntries方法可以把二维数组转成对象
     const res = Object.fromEntries([
       [&#39;name&#39;, &#39;尚硅谷&#39;],
       [&#39;subject&#39;, &#39;Java，大数据，前端，云计算&#39;]
     ])
     console.log(res);
     //Map
     const m = new Map();
     m.set(&#39;name&#39;, &#39;atguigu&#39;);
     const res2 = Object.fromEntries(m);
     console.log(res2);

     //Object.entries 这个方法是将对象转成数组的
     const arr = Object.entries(&#123;
       name: &#39;尚硅谷&#39;
     &#125;)
     console.log(arr);
</code></pre>
<h1 id="私有属性"><a href="#私有属性" class="headerlink" title="私有属性"></a>私有属性</h1><pre><code class="lang-js">class Person &#123;
        name;
        //前面加#表示它是私有的
        #age;
        #wight;
        constructor(name, age, wight) &#123;
          this.name = name;
          this.#age = age;
          this.#wight = wight;
        &#125;

        toString() &#123;
          console.log(this.name, this.#age, this.#wight);
        &#125;
      &#125;

      let girl = new Person(&#39;小红&#39;, 18, &#39;45kg&#39;);
      girl.toString();
</code></pre>
<h1 id="可选链操作符"><a href="#可选链操作符" class="headerlink" title="可选链操作符"></a>可选链操作符</h1><pre><code class="lang-js">function main(config) &#123;
        //判断的时候写整个链得挨个去写，ES11多了可选链操作符做了简化
        // const dbHost = config &amp;&amp; config.db &amp;&amp; config.db.host;
        const dbHost = config?.db?.host;
        console.log(dbHost);
      &#125;

      main(&#123;
        db: &#123;
          host: &#39;192.168.1.100&#39;,
          username: &#39;root&#39;
        &#125;,
        cache: &#123;
          host: &#39;192.168.1.200&#39;,
          username: &#39;admin&#39;
        &#125;
      &#125;)
</code></pre>
<h1 id="动态import"><a href="#动态import" class="headerlink" title="动态import"></a>动态import</h1><p>在需要Import的时候在按需引入</p>
<pre><code class="lang-js">const btn = document.getElementById(&#39;btn&#39;);

//then函数的形参就是引入的那个文件，可以调用相关的方法
btn.onclick = function() &#123;
    import(&#39;./xxx&#39;).then(module =&gt; &#123;
        module.hello();
    &#125;)
&#125;
</code></pre>
<h1 id="大整型"><a href="#大整型" class="headerlink" title="大整型"></a>大整型</h1><pre><code class="lang-js"> //声明
      let n = 520n;
      console.log(n, typeof(n));

      //函数,将普通整型转成
      let n2 = 123;
      console.log(BigInt(n2));

      //JS的最大安全整型
      let max = Number.MAX_SAFE_INTEGER;
      console.log(max);

      //需要将这个数转成大整型进行运算，但是大整型只能和大整型进行运算
      console.log(BigInt(max));
      console.log(BigInt(max) + BigInt(2));
</code></pre>

</div>


    <div class="post-guide">
        <div class="item left">
            
        </div>
        <div class="item right">
            
              <a href="/2021/08/25/%E5%89%8D%E7%AB%AF/JS%E7%BB%86%E8%8A%82/">
                JS细节
                <i class="fa fa-angle-right" aria-hidden="true"></i>
              </a>
            
        </div>
    </div>




<script>
	
	
</script>
	</div>
	<div id="footer">
	<p>
	©2019-<span id="footerYear"></span> 
	<a href="/">Regular</a> 
	
	
		|
		<span id="busuanzi_container_site_pv">
			pv
			<span id="busuanzi_value_site_pv"></span>
		</span>
		|
		<span id="busuanzi_container_site_uv"> 
			uv
			<span id="busuanzi_value_site_uv"></span>
		</span>
	
	<br>
	Theme <a href="//github.com/wujun234/hexo-theme-tree" target="_blank">Tree</a>
	by <a href="//github.com/wujun234" target="_blank">WuJun</a>
	Powered by <a href="//hexo.io" target="_blank">Hexo</a>
	</p>
</div>
<script type="text/javascript"> 
	document.getElementById('footerYear').innerHTML = new Date().getFullYear() + '';
</script>
	<button id="totop-toggle" class="toggle"><i class="fa fa-angle-double-up" aria-hidden="true"></i></button>
</body>
</html>