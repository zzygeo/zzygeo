<!DOCTYPE html>
<html lang="en">

<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8">
	<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
	
	<!-- title -->
	
	<title>
	
		面向对象高级部分 | 
	 
	Callme🍉
	</title>
	
	<!-- keywords,description -->
	 

	<!-- favicon -->
	
	<link rel="shortcut icon" href="/favicon.ico">
	


	<!-- search -->
	<script>
		var searchEngine = "https://www.google.com/search?q=";
		if(typeof searchEngine == "undefined" || searchEngine == null || searchEngine == ""){
			searchEngine = "https://www.google.com/search?q=";
		}
		var homeHost = "zzygeo.cn";
		if(typeof homeHost == "undefined" || homeHost == null || homeHost == ""){
			homeHost = window.location.host;
		}
	</script>


	
<link rel="stylesheet" href="/css/main.css">

	
<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css">

	
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.17.1/build/styles/darcula.min.css">

	
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">


	
<script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>

	
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>

	
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.17.1/build/highlight.min.js"></script>

	
<script src="https://cdn.jsdelivr.net/npm/jquery-pjax@2.0.1/jquery.pjax.min.js"></script>

	
<script src="/js/main.js"></script>

	
		
<script src="https://cdn.jsdelivr.net/npm/leancloud-storage/dist/av-min.js"></script>

		
<script src="https://cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js"></script>

	
	
		<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	
<meta name="generator" content="Hexo 5.2.0"><link rel="alternate" href="/atom.xml" title="Callme🍉" type="application/atom+xml">
</head>

<body>
	<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?3efe99c287df5a1d6f0d02d187e403c1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

<header id="header">
    <a id="title" href="/" class="logo">Callme🍉</a>

	<ul id="menu">
		<li class="menu-item">
			<a href="/about" class="menu-item-link">ABOUT</a>
		</li>
	

	
		<li class="menu-item">
			<a href="/categories" class="menu-item-link">分类</a>
		</li>
	

		<li class="menu-item">
			<a href="https://github.com/wujun234/uid-generator-spring-boot-starter" class="menu-item-link" target="_blank">
				UidGenerator
			</a>
		</li>
		<li class="menu-item">
			<a href="https://github.com/zzygeo" class="menu-item-link" target="_blank">
				<i class="fa fa-github fa-2x"></i>
			</a>
		</li>
	</ul>
</header>

	
<div id="sidebar">
	<button id="sidebar-toggle" class="toggle" ><i class="fa fa-arrow-right " aria-hidden="true"></i></button>
	
	<div id="site-toc">
		<input id="search-input" class="search-input" type="search" placeholder="按回车全站搜索">
		<div id="tree">
			

			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										Hexo
									</a>
									
							<ul>
								<li class="file">
									<a href="/2021/01/20/Hexo/github%E8%AE%BE%E7%BD%AE%E8%87%AA%E5%B7%B1%E7%9A%84%E5%9F%9F%E5%90%8D/">
										github设置自己的域名
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/10/02/Hexo/hexo-d-%E5%87%BA%E7%8E%B0%E9%94%99%E8%AF%AF%E7%9A%84%E7%94%A8%E6%88%B7%E5%90%8D%E5%92%8C%E5%AF%86%E7%A0%81%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/">
										hexo-d-出现错误的用户名和密码的解决办法
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/09/24/Hexo/markdown%E8%AF%AD%E6%B3%95/">
										markdown语法
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/10/02/Hexo/%E6%96%B0%E7%94%B5%E8%84%91%E4%B8%8A%E9%83%A8%E7%BD%B2hexo/">
										新电脑上部署hexo
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										Java基础
									</a>
									
							<ul>
								<li class="file">
									<a href="/2021/05/24/Java%E5%9F%BA%E7%A1%80/IDEA%E5%BF%AB%E6%8D%B7%E9%94%AE/">
										IDEA快捷键
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file active">
									<a href="/2021/05/24/Java%E5%9F%BA%E7%A1%80/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/">
										面向对象高级部分
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										PCL
									</a>
									
							<ul>
								<li class="file">
									<a href="/2020/10/04/PCL/PCL-1-11-Visual-Studio-2019-%E9%85%8D%E7%BD%AE/">
										PCL-1-11-Visual-Studio-2019-配置
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/12/27/PCL/pcl-vs-cmake%E7%BC%96%E8%AF%91/">
										pcl-vs-cmake编译
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										Ubuntu
									</a>
									
							<ul>
								<li class="file">
									<a href="/2021/03/14/Ubuntu/Ubuntu%E6%9B%B4%E6%8D%A2%E6%BA%90%E6%95%99%E7%A8%8B/">
										Ubuntu更换源教程
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/10/23/Ubuntu/Unable-to-access-https-gitee-com-%E8%87%AA%E5%B7%B1%E7%9A%84%E9%A1%B9%E7%9B%AE-Could-not-resolve-host-gitee-com%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3/">
										Unable-to-access-https-gitee-com-自己的项目-Could-not-resolve-host-gitee-com问题的解决
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2021/03/14/Ubuntu/dpkg%E8%A2%AB%E4%B8%AD%E6%96%AD%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/">
										dpkg被中断的解决办法
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2021/03/14/Ubuntu/ubuntu%E4%B8%8B%E7%9A%84firefox%E6%97%A0%E6%B3%95%E6%92%AD%E6%94%BE%E8%A7%86%E9%A2%91%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">
										ubuntu下的firefox无法播放视频解决方案
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2021/03/14/Ubuntu/ubuntu%E4%B8%8B%E8%A7%A3%E5%86%B3wps2019%E7%BC%BA%E5%B0%91%E5%AD%97%E4%BD%93%E9%97%AE%E9%A2%98/">
										ubuntu下解决wps2019缺少字体问题
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2021/03/14/Ubuntu/ubuntu%E5%AE%89%E8%A3%85gcc%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB%E6%8A%A5%E9%94%99/">
										ubuntu安装gcc依赖关系报错
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2021/03/14/Ubuntu/ubuntu%E5%AE%89%E8%A3%85vim%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB%E6%8A%A5%E9%94%99/">
										ubuntu安装vim依赖关系报错
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2021/03/14/Ubuntu/ubuntu%E9%85%8D%E7%BD%AEC-C-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/">
										ubuntu配置C-C-开发环境
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2021/03/14/Ubuntu/%E5%AE%89%E8%A3%85snap/">
										安装snap
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										其他
									</a>
									
							<ul>
								<li class="file">
									<a href="/2020/09/26/%E5%85%B6%E4%BB%96/%E6%88%91%E7%9A%84Office%E6%BF%80%E6%B4%BB%E7%A0%81/">
										我的Office激活码
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/10/04/%E5%85%B6%E4%BB%96/%E8%B5%84%E6%BA%90/">
										资源
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
		</div>
	</div>
</div>

	<!-- 引入正文 -->
	<div id="content">
		<h1 id="article-title">

	面向对象高级部分
</h1>
<div class="article-meta">
	
	<span>Regular</span>
	<span>2021-05-24 10:49:32</span>
		<div id="article-categories">
    
		<span>Categories：</span>
            
                
                    <span>
                        <i class="fa fa-folder" aria-hidden="true">
                        <a href="/categories/Java基础/">Java基础</a>
                        </i>
                      
                    </span>
                
            
    

    
		<span>Tags：</span>
            
    
		</div>

</div>

<div id="article-content">
	<h1 id="1-类变量和类方法"><a href="#1-类变量和类方法" class="headerlink" title="1.类变量和类方法"></a>1.类变量和类方法</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><img src="https://raw.githubusercontent.com/zzygeo/images/master/image-20210512202025523.5b1j2jak19s0.png" alt="image-20210512202025523"></p>
<p>==类变量可以通过类名直接来访问==</p>
<p>==堆区 or 静态域==，需要看jdk的版本</p>
<p><img src="https://raw.githubusercontent.com/zzygeo/images/master/image-20210512203343915.2grguwvuy960.png" alt="image-20210512203343915"></p>
<p>==不管static变量在哪里，共识（1）static变量是同一个类所有对象共享 （2）static类变量，在类加载的时候就生成了==</p>
<pre><code class="lang-java">package com.zzy.static_;

public class VisitStatic &#123;
    public static void main(String[] args) &#123;
        //类变量是随着类的加载创建的,不创建对象实例也可以访问
        System.out.println(A.name);
    &#125;
&#125;

class A&#123;
    public static String name = &quot;韩顺平教育&quot;;

&#125;
</code></pre>
<p>==加上static称为类变量或静态变量，否则称为实例变量/普通变量/非静态变量==</p>
<p>==类方法也可以通过类名进行访问==</p>
<h2 id="类方法的使用场景"><a href="#类方法的使用场景" class="headerlink" title="类方法的使用场景"></a>类方法的使用场景</h2><p><img src="https://raw.githubusercontent.com/zzygeo/images/master/image-20210512210404632.1v296c255aw0.png" alt="image-20210512210404632"></p>
<h2 id="类方法的细节"><a href="#类方法的细节" class="headerlink" title="类方法的细节"></a>类方法的细节</h2><p><img src="https://raw.githubusercontent.com/zzygeo/images/master/image-20210512210636540.46e97zs0p440.png" alt="image-20210512210636540"></p>
<p><img src="https://raw.githubusercontent.com/zzygeo/images/master/image-20210512210908683.46g10ymx9a00.png" alt="image-20210512210908683"></p>
<p>==根据加载的时间来的，类在创建的时候，类变量和类方法就已经有了==，而普通变量和普通方法是在类实例的时候才出现</p>
<h1 id="2-理解main方法语法"><a href="#2-理解main方法语法" class="headerlink" title="2.理解main方法语法"></a>2.理解main方法语法</h1><p><img src="https://raw.githubusercontent.com/zzygeo/images/master/image-20210512213729148.5ze5kknxs200.png" alt="image-20210512213729148"></p>
<p><img src="https://raw.githubusercontent.com/zzygeo/images/master/image-20210512213846089.6jjxl371zzw0.png" alt="image-20210512213846089"></p>
<p>如果想在idea中也给args字符串数组传入字符串，需要在以下的窗口去传入</p>
<p><img src="https://raw.githubusercontent.com/zzygeo/images/master/image-20210512214659162.478kzo8tjtw0.png" alt="image-20210512214659162"></p>
<h1 id="3-代码块"><a href="#3-代码块" class="headerlink" title="3.代码块"></a>3.代码块</h1><h2 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h2><p><img src="https://raw.githubusercontent.com/zzygeo/images/master/image-20210512215021484.7ems24jyeeo0.png" alt="image-20210512215021484"></p>
<p><img src="https://raw.githubusercontent.com/zzygeo/images/master/image-20210512215117763.74f7ofaugik0.png" alt="image-20210512215117763"></p>
<pre><code class="lang-java">package com.zzy.codeblock_;

public class CodeBlock01 &#123;
    public static void main(String[] args) &#123;
        Movie movie1 = new Movie(&quot;你好，李焕英&quot;);
    &#125;
&#125;

class Movie&#123;
    private String name;
    private double price;
    private String director;
    //3个构造器，函数重载
    //3个构造器都有相同的语句，代码看起来比较冗余
    //可以将相同的语句放入代码块中,不管调用哪个构造器创建对象，都会先调用代码块的内容
    //代码块调用的顺序优先于构造器
    &#123;
        System.out.println(&quot;电影屏幕打开...&quot;);
        System.out.println(&quot;广告开始...&quot;);
        System.out.println(&quot;电影正式开始...&quot;);
    &#125;
    public Movie(String name) &#123;
        System.out.println(&quot;Movie(String name)构造器被调用&quot;);
        this.name = name;
    &#125;

    public Movie(double price, String director) &#123;
        this.price = price;
        this.director = director;
    &#125;

    public Movie(String name, double price, String director) &#123;
        this.name = name;
        this.price = price;
        this.director = director;
    &#125;
&#125;
</code></pre>
<p>输出结果</p>
<p><img src="https://raw.githubusercontent.com/zzygeo/images/master/image-20210512220748122.4iqixdml1fu0.png" alt="image-20210512220748122"></p>
<h2 id="代码块使用注意事项"><a href="#代码块使用注意事项" class="headerlink" title="代码块使用注意事项"></a>代码块使用注意事项</h2><p>（1）static代码块也叫静态代码块，作用就是对类进行初始化，==而且它随着类的加载而执行，并且只会执行一次。如果是普通代码块，每创建一个对象，就执行。==</p>
<p>（2）类什么时候被加载（重要）</p>
<ol>
<li>==创建对象实例时（new）==</li>
<li>==创建子类对象实例，父类也被会加载,父类先被加载，子类后被加载==</li>
<li>==使用类的静态成员时（静态属性，静态方法）==</li>
</ol>
<p>创建一个对象时，在一个类调用的顺序是：</p>
<ol>
<li>==调用静态代码块和静态属性初始化（静态代码块和静态属性初始化调用的优先级一样，如果有多个静态代码块和多个静态变量初始化，则按他们定义的顺序调用）==</li>
<li>==调用普通代码块和普通属性的初始化（普通代码块和普通属性初始化调用的优先级一样，如果有多个普通代码块和多个普通属性初始化，则按定义顺序调用）==</li>
<li>==调用构造方法==</li>
<li>==构造器的最前面其实隐含了super()和调用普通代码块==</li>
<li>当创建一个子类对象时（继承关系），他们的静态代码块，静态属性初始化，普通代码块，普通属性初始化，构造方法的调用顺序如下：</li>
</ol>
<ul>
<li>==父类的静态代码块和静态属性（优先级一样，按定义顺序执行）==</li>
<li>==子类的静态代码块和静态属性（优先级一样，按定义顺序执行）==</li>
<li>==父类的普通代码块和普通属性初始化（优先级一样，按定义顺序执行）==</li>
<li>==父类的构造方法==</li>
<li>==子类的普通代码块和普通属性初始化（优先级一样，按定义顺序执行）==</li>
<li>==子类的构造方法==</li>
</ul>
<pre><code class="lang-java">package com.zzy.codeblock_;

public class CodeBlockDetail03 &#123;
    public static void main(String[] args) &#123;
        B b = new B();
    &#125;
&#125;


class A&#123;
    public A()&#123;
        System.out.println(&quot;A的无参构造器调用&quot;); //6
    &#125;
    public static int n1 = getN1();

    public static int getN1()&#123;
        System.out.println(&quot;A的静态属性的调用&quot;); //1
        return 100;
    &#125;

    static &#123;
        System.out.println(&quot;A类的静态代码块的调用&quot;); //2
    &#125;
    &#123;
        System.out.println(&quot;A类的普通代码块调用&quot;); //5
    &#125;
&#125;

class B extends A&#123;
    public B()&#123;
        System.out.println(&quot;B类的无参构造器&quot;); //8
    &#125;
    public static int N2 = getN2();
    public static int getN2()&#123;
        System.out.println(&quot;B类的静态属性调用&quot;); //3
        return 200;
    &#125;

    static &#123;
        System.out.println(&quot;B类的静态代码块调用&quot;); //4
    &#125;

    &#123;
        System.out.println(&quot;B类的普通代码块调用&quot;); //7
    &#125;

&#125;
</code></pre>
<h1 id="4-设计模式"><a href="#4-设计模式" class="headerlink" title="4.设计模式"></a>4.设计模式</h1><h2 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h2><p>静态方法和属性的经典使用</p>
<p>设计模式是在大量的实践中总结和理论化之后优选的代码结构、编程风格、以及解决问题的思考方式。设计模式就像是经典的棋谱，不同的棋局，我们用不同的棋谱，免去我们自己再思考和摸索。</p>
<p>单例模式</p>
<p>1.所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能==存在一个对象实例==，并且该类==只提供一个取得其对象实例==的方法</p>
<p>2.单例模式有两种 1）饿汉式 2）懒汉式</p>
<h2 id="饿汉式的单例模式"><a href="#饿汉式的单例模式" class="headerlink" title="饿汉式的单例模式"></a>饿汉式的单例模式</h2><p>步骤如下:</p>
<p>1)构造器私有化 =》防止直接new</p>
<p>2)类的内部创建对象</p>
<p>3)向外暴露一个静态的公共方法</p>
<p>4)代码实现</p>
<pre><code class="lang-java">package com.zzy.Single_;

public class SingleTon01 &#123;
    public static void main(String[] args) &#123;
        GirlFriend instance1 = GirlFriend.getInstance();
        System.out.println(instance1);
        GirlFriend instance2 = GirlFriend.getInstance();
        System.out.println(instance2);
    &#125;
&#125;


//只能有一个女朋友

class GirlFriend&#123;
    private String name;
    //内部创建一个私有的
    private static GirlFriend girl = new GirlFriend(&quot;小红&quot;);
    //如何防止只能创建一个女朋友
    private GirlFriend(String name)&#123;
        this.name = name;
    &#125;
    public static GirlFriend getInstance()&#123;
        return girl;
    &#125;

    @Override
    public String toString() &#123;
        return &quot;GirlFriend&#123;&quot; +
                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +
                &#39;&#125;&#39;;
    &#125;
&#125;
</code></pre>
<h2 id="懒汉式的单例模式"><a href="#懒汉式的单例模式" class="headerlink" title="懒汉式的单例模式"></a>懒汉式的单例模式</h2><p>1)仍然构造器私有化</p>
<p>2)定义一个静态属性对象</p>
<p>3)提供一个public的static方法，可以返回一个Cat对象</p>
<p>4)只有当用户使用getInstance时，才返回cat对象，后面再次调用时，会返回上次创建的cat对象</p>
<p>饿汉式VS懒汉式</p>
<ol>
<li>二者最主要的区别在于创建对象的时机不同：饿汉式是在类加载就创建了对象实例，而懒汉式是在使用时（调用instance）才创建。</li>
<li>饿汉式不存在线程安全的问题，懒汉式存在线程安全的问题（后面学习线程后，在进行完善）</li>
<li>饿汉式存在浪费资源的可能。因为如果一个程序员一个对象实例都没有使用，那么饿汉式创建的对象就浪费了，懒汉式是使用时才创建，不存在这个问题。</li>
<li>在javaSE标准中, java.lang.Runtime就是经典的单例模式</li>
</ol>
<h1 id="5-final关键字"><a href="#5-final关键字" class="headerlink" title="5.final关键字"></a>5.final关键字</h1><h2 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h2><p>final可以修饰类、属性、方法和局部变量</p>
<p>在某些情况下，程序员可能有以下需求，就会使用到final：</p>
<p>1)当==不希望类被继承==时，可以用final修饰</p>
<p>2)当==不希望父类的某个方法被子类覆盖/重写==时，可以使用final关键字修饰。</p>
<p>3)当==不希望类的某个属性的值被修改==，可以用final修饰</p>
<p>4)当==不希望某个局部变量被修改==（比如函数里），可以使用final修饰</p>
<h2 id="final的使用细节"><a href="#final的使用细节" class="headerlink" title="final的使用细节"></a>final的使用细节</h2><p>1）final修饰的属性又叫常量，一般用XX_XX_XX来命名</p>
<p>2）final修饰的属性==在定义时，必须赋初值==，并且==以后不能再修改==，赋值可以加在如下位置之一【选择一个位置赋初值即可】</p>
<ul>
<li>==定义时==，如 public final double TAX_RATE = 0.08;</li>
<li>==在构造器中==</li>
<li>==在代码块中==</li>
</ul>
<p>3）如果==final修饰的属性是静态的==，则初始化的位置只能是 ==1. 定义时 2. 在静态代码块== 而不能在构造器中赋值(==参考类加载的先后顺序==)。</p>
<p>4）==final类不能继承，但是可以实例化对象==</p>
<p>5）如果类不是final类，但是含有final方法，则该方法虽然不可以重写，但是可以被继承。</p>
<pre><code class="lang-java">package com.zzy.final_;

public class Final01 &#123;
    public static void main(String[] args) &#123;
        //final不可以继承，但是可以实例化对象
        System.out.println(Test02.num);
        //final方法虽然不能被重写，但是可以被继承
        Test04 test04 = new Test04();
        test04.say();
    &#125;
&#125;

class Test01&#123;
    public final double TAX_RATE = 0.08; //1.在定义时赋值
    public final double TAX_RATE1;
    public final double TAX_RATE2;
    public static final double TAX_RATE3 = 0.01; //修饰静态属性，可以在定义时赋值
    public static final double TAX_RATE4; //修饰静态属性，可以在定义时赋值

    public Test01()&#123;//2.在构造器中赋值
        TAX_RATE1 = 0.8;
    &#125;
    static&#123;
        TAX_RATE4 = 0.04; //在静态代码块中可行
    &#125;

    &#123;
        //3.在代码块中赋值
        TAX_RATE2 = 0.1;
    &#125;
&#125;

final class Test02&#123;
    public static int num = 5;
&#125;

class Test03&#123;
    public final void say()&#123;
        System.out.println(&quot;Test03类的say方法&quot;);
    &#125;
&#125;

class Test04 extends Test03&#123;
    public double val = 5.0;
&#125;
</code></pre>
<p>5）一般来说，如果==一个类已经是final类了，就没有必要再将方法修饰成final==方法。</p>
<p>6）==final不能修饰构造器==</p>
<p>7）==final和static往往搭配使用==，效率更高，不会导致类加载，底层编译器做了优化处理</p>
<p>8）包装类（Integer,Double，Float, Boolean等都是final），String也是final方法</p>
<pre><code class="lang-java">package com.zzy.final_;

public class Final &#123;
    public static void main(String[] args) &#123;
        //不会导致类加载
        System.out.println(Test05.num);
    &#125;
&#125;

class Test05&#123;
    public final static int num = 5;
    static&#123;
        System.out.println(&quot;Test05的静态代码块&quot;);
    &#125;
&#125;
</code></pre>
<h1 id="6-抽象类"><a href="#6-抽象类" class="headerlink" title="6.抽象类"></a>6.抽象类</h1><h2 id="介绍-4"><a href="#介绍-4" class="headerlink" title="介绍"></a>介绍</h2><p>当父类的一些方法不能确定时，可以用abstract关键字来修饰该方法，这个方法就是抽象方法，用abstract来修饰该类就是抽象类</p>
<p>1）用abstract关键字来修饰一个类时，这个类就叫抽象类</p>
<p>2）用abstract关键字来修饰一个方法时，这个方法就是抽象方法</p>
<p>访问修饰符 abstract 返回类型 方法名(参数列表)； //没有方法体</p>
<p>3）==抽象类的价值更多作用是在于设计，是设计者设计好后，让子类继承并实现抽象类==</p>
<p>4）抽象类，是面试比较爱问的知识点，在框架和设计模式使用较多</p>
<h2 id="抽象类的细节"><a href="#抽象类的细节" class="headerlink" title="抽象类的细节"></a>抽象类的细节</h2><p>1）抽象类==不能被实例化==</p>
<p>2）抽象类不一定要包含abstract方法。也就是说，抽象类可以没有abstract方法</p>
<p>3）一旦类==包含了abstract方法，则这个类必须声明为abstract==</p>
<p>4）abstract==只能修饰类和方法，不能修饰属性和其他的==</p>
<p>5）抽象类可以由任意成员【因为抽象类还是类】，比如：非抽象方法，构造器，静态属性等</p>
<p>6）==抽象方法不能有主体==，即不能实现</p>
<p>7）如果==一个类继承了抽象类，则它必须实现抽象类的所有抽象方法==，==除非它自己也声明为abstract类==。</p>
<p>8）抽象方法不能使用private、final、static来修饰，因为这些关键字都是和重写违背的</p>
<pre><code class="lang-java">package com.zzy.Animal;

public class AbstractDetails &#123;
    public static void main(String[] args) &#123;
        //抽象类，不能被初始化
        //new A();
    &#125;
&#125;

abstract class A&#123;//抽象类的方法可以不抽象化
    public void hi()&#123;
        System.out.println(&quot;hi&quot;);
    &#125;
&#125;

//一旦类包含了abstract方法，则这个类必须声明为abstract
abstract class B&#123;
    public abstract void hi();
&#125;

class C&#123;
    //abstract只能修饰类和方法，不能修饰其他的
    //public abstract int n1 = 5;
&#125;
</code></pre>
<pre><code class="lang-java">package com.zzy.Animal;

public class AbstractDetails01 &#123;
    public static void main(String[] args) &#123;

    &#125;
&#125;

abstract class E&#123;
    public abstract void hi();
&#125;

abstract class F extends E&#123;
    //除非自己也声明为abstract类
&#125;

class G extends E&#123;
    @Override
    public void hi() &#123;//这里相当于重写父类E的抽象方法
        System.out.println(&quot;话不投机，说你妈逼&quot;);
    &#125;
&#125;
</code></pre>
<h2 id="抽象类最佳实践-模板设计模式"><a href="#抽象类最佳实践-模板设计模式" class="headerlink" title="抽象类最佳实践-模板设计模式"></a>抽象类最佳实践-模板设计模式</h2><p>需求</p>
<p>1）有多个类，完成不同的任务job</p>
<p>2）要求能够得到各自完成任务的时间</p>
<p>感情的自然流露</p>
<ol>
<li>先用最容易想到的方法</li>
<li>分析问题，提出使用模板设计模式</li>
</ol>
<p>父类</p>
<pre><code class="lang-java">package com.zzy.Animal;

abstract public class Template &#123;

    public abstract void job();

    public void calculateTime()&#123;
        long start = System.currentTimeMillis();
        job(); //这里涉及到动态绑定机制
        long end = System.currentTimeMillis();
        System.out.println(&quot;任务运行时间为：&quot; + (end - start));
    &#125;
&#125;
</code></pre>
<p>父类AA</p>
<pre><code class="lang-java">package com.zzy.Animal;

public class AA extends Template&#123;
    //计算任务
    //从1加到10000

    public void job()&#123;
        long num = 0;
        for (long i = 1; i &lt;= 800000; i++) &#123;
            num += i;
        &#125;
    &#125;
&#125;
</code></pre>
<p>子类BB</p>
<pre><code class="lang-java">package com.zzy.Animal;

public class BB extends Template&#123;

    public void job()&#123;
        long num = 0;
        for (long i = 1; i &lt;= 80000; i++) &#123;
            num *= i;
        &#125;
    &#125;
&#125;
</code></pre>
<p>测试类</p>
<pre><code class="lang-java">package com.zzy.Animal;

public class TestTemplate &#123;
    public static void main(String[] args) &#123;
        AA aa = new AA();
        aa.calculateTime();

        BB bb = new BB();
        bb.calculateTime();
    &#125;
&#125;
</code></pre>
<h1 id="7-接口"><a href="#7-接口" class="headerlink" title="7.接口"></a>7.接口</h1><h2 id="介绍-5"><a href="#介绍-5" class="headerlink" title="介绍"></a>介绍</h2><p><img src="https://raw.githubusercontent.com/zzygeo/images/master/1621823722.5mjdgmqmdco0.jpg" alt="1621823722"></p>
<h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><p>1）接口不能被实例化</p>
<p>2）接口中的所有方法是public方法，接口中抽象方法，可以不用abstract修饰</p>
<p>3）一个普通类实现接口，就必须将该接口的所有方法都实现</p>
<p>4）抽象了实现接口，可以不用实现接口的方法</p>
<p>5）一个类同时可以实现多个接口</p>
<p>6）接口中的属性，只能是final的，而且是public static final 修饰符，因此必须初始化</p>
<p>7）接口中属性的访问形式：接口名.属性名</p>
<p>8）接口不能继承其他的类，但是可以继承多个别的接口</p>
<p>9）接口的修饰符只能是public和默认，这一点和类的修饰符是一样的</p>
<p>接口和继承解决的问题不同</p>
<p>继承的价值主要在于：解决代码的复用性和可维护性</p>
<p>接口的价值主要在于：设计，设计好各种规范，让其他类去实现这些方法。即更加的灵活</p>
<p>接口比继承更加灵活</p>
<p>接口比继承更加灵活，继承是满足is -a的关系, 而接口只 需满足 like -a的关系</p>
<p>接口在一定程度上实现代码解耦（即：接口规范性+动态绑定机制）</p>
<h2 id="接口的多态特性"><a href="#接口的多态特性" class="headerlink" title="接口的多态特性"></a>接口的多态特性</h2><p>接口既可以接受A对象，又可以接受相机对象，就体现了接口，多态</p>
<p>一个接口的数组里，既可以存放A对象，也可以存放B对象，也体现了多态特性，这里还设计到向上转型和向下转型</p>
<p>接口存在多态传递现象</p>

</div>


    <div class="post-guide">
        <div class="item left">
            
        </div>
        <div class="item right">
            
              <a href="/2021/05/24/Java%E5%9F%BA%E7%A1%80/IDEA%E5%BF%AB%E6%8D%B7%E9%94%AE/">
                IDEA快捷键
                <i class="fa fa-angle-right" aria-hidden="true"></i>
              </a>
            
        </div>
    </div>




<script>
	
	
</script>
	</div>
	<div id="footer">
	<p>
	©2019-<span id="footerYear"></span> 
	<a href="/">Regular</a> 
	
	
		|
		<span id="busuanzi_container_site_pv">
			pv
			<span id="busuanzi_value_site_pv"></span>
		</span>
		|
		<span id="busuanzi_container_site_uv"> 
			uv
			<span id="busuanzi_value_site_uv"></span>
		</span>
	
	<br>
	Theme <a href="//github.com/wujun234/hexo-theme-tree" target="_blank">Tree</a>
	by <a href="//github.com/wujun234" target="_blank">WuJun</a>
	Powered by <a href="//hexo.io" target="_blank">Hexo</a>
	</p>
</div>
<script type="text/javascript"> 
	document.getElementById('footerYear').innerHTML = new Date().getFullYear() + '';
</script>
	<button id="totop-toggle" class="toggle"><i class="fa fa-angle-double-up" aria-hidden="true"></i></button>
</body>
</html>