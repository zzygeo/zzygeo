<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>github设置自己的域名</title>
    <url>/2021/01/20/Hexo/github%E8%AE%BE%E7%BD%AE%E8%87%AA%E5%B7%B1%E7%9A%84%E5%9F%9F%E5%90%8D/</url>
    <content><![CDATA[<p>哈哈，上次整了一晚上的没整明白，今天两下就整好了，看来真的进步不错哈哈，至少看东西，解决问题更有耐心也更能看懂了。<br><a id="more"></a></p>
<h1 id="1-购买域名"><a href="#1-购买域名" class="headerlink" title="1.购买域名"></a>1.购买域名</h1><p>我是买的阿里云的域名，如下图：<br><img src="/blog_img/github设置自己的域名/1.jpg" alt="域名"><br>域名解析如下：<br><img src="/blog_img/github设置自己的域名/2.jpg" alt="域名解析"></p>
<h1 id="2-github仓库设置域名地址"><a href="#2-github仓库设置域名地址" class="headerlink" title="2.github仓库设置域名地址"></a>2.github仓库设置域名地址</h1><p>在blog目录下的source文件下，创一个叫CNAME的无后缀文件，里面填入你的域名，比如我的   zzygeo.cn    如下图：<br><img src="/blog_img/github设置自己的域名/4.jpg" alt=""><br>如下图，主要是要设置博客上传分支的目录，以及更改你自己的域名（创建CNAME后自动生成），采用https加密。<br><img src="/blog_img/github设置自己的域名/3.jpg" alt=""></p>
<p>到此就设置完成了！</p>
<hr>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title>markdown语法</title>
    <url>/2020/09/24/Hexo/markdown%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1 id="1-标题"><a href="#1-标题" class="headerlink" title="1.标题"></a>1.标题</h1><a id="more"></a>
<pre><code># 一级标题
## 二级标题
### 三级标题
#### 四级标题
##### 五级标题
###### 六级标题 
</code></pre><p>注：# 和「标题文字」之间建议保留一个字符的空格，这是最标准的 Markdown 写法。</p>
<hr>
<h1 id="2-粗体、斜体、删除线"><a href="#2-粗体、斜体、删除线" class="headerlink" title="2. 粗体、斜体、删除线"></a>2. 粗体、斜体、删除线</h1><pre><code>*我是斜体*
**我是粗体**
***我是粗斜体***
~~我是删除线~~
</code></pre><p>显示效果：<br><em>我是斜体</em><br><strong>我是粗体</strong><br><strong><em>我是粗斜体</em></strong><br><del>我是删除线</del></p>
<hr>
<h1 id="3-表格"><a href="#3-表格" class="headerlink" title="3. 表格"></a>3. 表格</h1><pre><code>| 学号 | 姓名 | 分数|
| :- | -: | :-: |
| 小明 | 男 | 75 |
| 小红 | 女 | 79 |
| 小陆 | 男 | 92 |
</code></pre><p>显示效果：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">学号</th>
<th style="text-align:right">姓名</th>
<th style="text-align:center">分数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">小明</td>
<td style="text-align:right">男</td>
<td style="text-align:center">75</td>
</tr>
<tr>
<td style="text-align:left">小红</td>
<td style="text-align:right">女</td>
<td style="text-align:center">79</td>
</tr>
<tr>
<td style="text-align:left">小陆</td>
<td style="text-align:right">男</td>
<td style="text-align:center">92</td>
</tr>
</tbody>
</table>
</div>
<hr>
<h1 id="4-有序列表"><a href="#4-有序列表" class="headerlink" title="4. 有序列表"></a>4. 有序列表</h1><pre><code>1. 文本1
2. 文本2
3. 文本3
</code></pre><p>显示效果：  </p>
<ol>
<li>文本1</li>
<li>文本2</li>
<li>文本3</li>
</ol>
<hr>
<h1 id="5-无序列表"><a href="#5-无序列表" class="headerlink" title="5. 无序列表"></a>5. 无序列表</h1><pre><code>- 文本1
- 文本2
- 文本3
</code></pre><p>显示效果：  </p>
<ul>
<li>文本1</li>
<li>文本2</li>
<li>文本3</li>
</ul>
<hr>
<h1 id="6-行内代码块"><a href="#6-行内代码块" class="headerlink" title="6. 行内代码块"></a>6. 行内代码块</h1><pre><code>C语言里的函数 `scanf()` 怎么使用？
</code></pre><p>显示效果：<br>C语言里的函数 <code>scanf()</code> 怎么使用？</p>
<hr>
<h1 id="7-分割线"><a href="#7-分割线" class="headerlink" title="7. 分割线"></a>7. 分割线</h1><h2 id="可以在一行中用三个以上的减号、底线来建立一个分隔线，行内不能有其他内容。"><a href="#可以在一行中用三个以上的减号、底线来建立一个分隔线，行内不能有其他内容。" class="headerlink" title="可以在一行中用三个以上的减号、底线来建立一个分隔线，行内不能有其他内容。  "></a>可以在一行中用三个以上的减号、底线来建立一个分隔线，行内不能有其他内容。  </h2><pre><code>___
</code></pre><h2 id="显示效果："><a href="#显示效果：" class="headerlink" title="显示效果："></a>显示效果：</h2><hr>
<hr>
<h1 id="8-超链接"><a href="#8-超链接" class="headerlink" title="8. 超链接"></a>8. 超链接</h1><p>语法格式为<a href="链接地址" title="链接标题">链接文字</a>，[]里写链接文字，()里写链接地址, ()中的”“中可以为链接指定title属性，title属性为可选。title属性的效果是鼠标悬停在链接上会出现指定的title文字。链接地址与链接标题前有一个空格。<br>    欢迎来到<a href="http://blog.csdn.net/china_jeffery" title="zzygeo">多加香菜的博客</a></p>
<p>显示效果：<br>欢迎来到<a href="http://blog.csdn.net/china_jeffery" title="zzygeo">多加香菜的博客</a></p>
<hr>
<h1 id="9-图片"><a href="#9-图片" class="headerlink" title="9. 图片"></a>9. 图片</h1><p>语法格式为<img src="图片地址" alt="图片Alt" title="图片Title">，图片Alt的意思是如果图片因为某些原因不能显示，就用定义的图片Alt文字来代替图片。 图片Title则和超链接中的链接标题一样，表示鼠标悬停与图片上时出现的文字。 图片Alt 和 图片Titlee 都是可选的。</p>
<hr>
<h1 id="10-引用"><a href="#10-引用" class="headerlink" title="10. 引用"></a>10. 引用</h1><pre><code>&gt; 一级引用
&gt;&gt; 二级引用
&gt;&gt;&gt; 三级引用
&gt;&gt;&gt;&gt; 四级引用
</code></pre><p>显示效果：</p>
<blockquote>
<p>一级引用</p>
<blockquote>
<p>二级引用</p>
<blockquote>
<p>三级引用</p>
<blockquote>
<p>四级引用</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<hr>
<h1 id="11-空格"><a href="#11-空格" class="headerlink" title="11. 空格"></a>11. 空格</h1><pre><code>你好&amp;nbsp;&amp;nbsp;&amp;nbsp;jeffery
</code></pre><p>显示效果<br>你好&nbsp;&nbsp;&nbsp;zzy</p>
<hr>
<h1 id="12-字体、字号、颜色"><a href="#12-字体、字号、颜色" class="headerlink" title="12. 字体、字号、颜色"></a>12. 字体、字号、颜色</h1><pre><code>&lt;font face=&quot;黑体&quot;&gt;我是黑体字&lt;/font&gt;
&lt;font face=&quot;微软雅黑&quot;&gt;我是微软雅黑&lt;/font&gt;
&lt;font color=#0099ff size=23 face=&quot;黑体&quot;&gt;我是黑体，颜色#0099ff 字号23&lt;/font&gt;
</code></pre><p><font face="黑体">我是黑体字</font>  </p>
<p><font face="微软雅黑">我是微软雅黑</font>  </p>
<p><font color=#00 size=23 face="黑体">我是黑体，颜色#0099ff 字号23</font>&lt;/p&gt;</p>
<hr>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title>新电脑上部署hexo</title>
    <url>/2020/10/02/Hexo/%E6%96%B0%E7%94%B5%E8%84%91%E4%B8%8A%E9%83%A8%E7%BD%B2hexo/</url>
    <content><![CDATA[<h1 id="1-安装必要软件"><a href="#1-安装必要软件" class="headerlink" title="1. 安装必要软件"></a>1. 安装必要软件</h1><p>安装 Git 客户端<br>安装 node JS</p>
<a id="more"></a>
<hr>
<h1 id="2-拷贝源文件"><a href="#2-拷贝源文件" class="headerlink" title="2. 拷贝源文件"></a>2. 拷贝源文件</h1><p>将初始电脑上个人博客文件夹下这几个文件夹拷到当前新电脑的准备设置的博客路径下。</p>
<pre><code>_config.yml
package.json
scaffolds/
source/
themes/
</code></pre><hr>
<h1 id="3-安装hexo"><a href="#3-安装hexo" class="headerlink" title="3. 安装hexo"></a>3. 安装hexo</h1><p>在 cmd 下输入下面指令安装 hexo:</p>
<pre><code>npm install -g hexo
</code></pre><hr>
<h1 id="4-在新博客路径下，安装三方依赖库"><a href="#4-在新博客路径下，安装三方依赖库" class="headerlink" title="4. 在新博客路径下，安装三方依赖库"></a>4. 在新博客路径下，安装三方依赖库</h1><pre><code>npm install
npm install hexo-deployer-git --save //文章部署到 git 的模块
npm install 主题需要的插件
</code></pre><p><strong>千万别hxeo init</strong>，不然你就拉在裤子里了！！！</p>
<hr>
<h1 id="5-GITHUB-gitee-添加-SSH-KEYS"><a href="#5-GITHUB-gitee-添加-SSH-KEYS" class="headerlink" title="5. GITHUB/gitee 添加 SSH KEYS"></a>5. GITHUB/gitee 添加 SSH KEYS</h1><p>在GitHub/gitee的ssh keys那里再添加一个当前电脑的环境生成的key，但是可别把原来的电脑删掉了啊。<br>首先在本地创建 SSH Keys:</p>
<pre><code>ssh-keygen -t rsa -C “xxxx@xxxx.com“
</code></pre><p>后面的邮箱即为 github/gitee注册邮箱，也是你登录Github的邮箱（其实无关紧要，只是为了辨识生成的用户名），之后会要求确认路径和输入密码，一路回车就行。<br>成功的话会在git bash页面下看到生成的 .ssh文件夹路径，进去，打开 id_rsa.pub，复制里面的key（全选）即可。然后拷贝到 Github/gitee 的 SSH Keys(这里要添加一个新的)<br>然后在终端中，我们再次测试下公钥有没有添加成功：</p>
<pre><code>ssh -T git@gitee.com 
</code></pre><p>会弹出确认命令，输入yes,会弹出你的名字等等，会出现：</p>
<pre><code>Hi username! You&#39;ve successfully authenticated, but GitHub does not provide shell access.
</code></pre><p>然后：</p>
<pre><code>hexo g
hexo s
hexo d
</code></pre><hr>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title>hexo d 出现错误的用户名和密码的解决办法</title>
    <url>/2020/10/02/Hexo/hexo-d-%E5%87%BA%E7%8E%B0%E9%94%99%E8%AF%AF%E7%9A%84%E7%94%A8%E6%88%B7%E5%90%8D%E5%92%8C%E5%AF%86%E7%A0%81%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    <content><![CDATA[<p>在windows搜索栏输入：控制面板<a id="more"></a>)<br><img src="/blog_img/hexo d时错误用户名和密码解决办法/1.png" alt=""><br>然后点击：<br><img src="/blog_img/hexo d时错误用户名和密码解决办法/2.png" alt=""><br><img src="/blog_img/hexo d时错误用户名和密码解决办法/3.png" alt=""><br><img src="/blog_img/hexo d时错误用户名和密码解决办法/4.png" alt=""></p>
<p>点进去就可以更改用户名和密码了</p>
<hr>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title>pcl+vs+cmake编译</title>
    <url>/2020/12/27/PCL/pcl-vs-cmake%E7%BC%96%E8%AF%91/</url>
    <content><![CDATA[<p>上一篇写的配置可能是最基础的，也是很麻烦，其实可以用cmake来偷个懒，这样就不用附加依赖性已经加入库目录和包含目录了。<br><a id="more"></a></p>
<h1 id="1-软件准备"><a href="#1-软件准备" class="headerlink" title="1.软件准备"></a>1.软件准备</h1><p>1.All in one 安装包。</p>
<p>2.获取All in one 包对应得PDB文件包，用于后期单步调试。</p>
<p>3.安装Visual studio 2019编译器</p>
<p>4.cmake<br><img src="/blog_img/PCL配置/17.png" alt="示意图"><br><img src="/blog_img/PCL配置/1.jpg" alt="示意图"></p>
<p>其实源码包用不上，懒得改了，最复杂的方式就是源代码加第三方库进行配置，等我配置好了也会再一篇关于源码方式的配置。</p>
<hr>
<h1 id="2-链接"><a href="#2-链接" class="headerlink" title="2.链接"></a>2.链接</h1><p><a href="https://github.com/PointCloudLibrary/pcl/releases">pcl下载地址</a><br><a href="https://visualstudio.microsoft.com/zh-hans/downloads/">visual studio下载地址</a><br><a href="https://cmake.org/download/">cmake下载地址</a></p>
<hr>
<h1 id="3-安装事项"><a href="#3-安装事项" class="headerlink" title="3.安装事项"></a>3.安装事项</h1><p>为了方便配置，pcl安装目录尽量默认，不默认后续添加目录需要选择对应的位置。</p>
<p>pcl安装请一定选择创建系统路径，visual studio和cmake安装位置随意，其他选项默认即可。</p>
<p>pcl安装完成后，请把下载的pcd文件解压，如下图：<br><img src="/blog_img/PCL配置/2.jpg" alt=""></p>
<p>将所有文件复制，安装到pcl下的BIN文件下<br><img src="/blog_img/PCL配置/3.jpg" alt=""></p>
<p>检查pcl安装目录下的 3rdParty-OpenNI2是否只有一个安装包（我的是这样），这可能是事先安装过SDK的原因，请卸载了重新安装在OpenNI2下，安装完成如下图：<br><img src="/blog_img/PCL配置/4.jpg" alt=""></p>
<p>cmake 安装请选择添加到系统路径，没选的话也可以自己手动添加，添加的方式为cmake目录下bin文件  比如C:\APP\Cmake\bin这样的形式。</p>
<hr>
<h1 id="4-关于Visual-studio安装项目"><a href="#4-关于Visual-studio安装项目" class="headerlink" title="4.关于Visual studio安装项目"></a>4.关于Visual studio安装项目</h1><p>我安装了这些负载</p>
<p><img src="/blog_img/PCL配置/5.png" alt=""></p>
<hr>
<h1 id="5-环境配置"><a href="#5-环境配置" class="headerlink" title="5.环境配置"></a>5.环境配置</h1><p>右键我的电脑——高级系统设置-环境变量，在path选项下新建如下几项，根据你pcl安装的位置来：<br><img src="/blog_img/PCL配置/6.jpg" alt=""></p>
<p>比如我的：<br>C:\Program Files\PCL 1.11.0\bin<br>C:\Program Files\PCL 1.11.0\3rdParty\FLANN\bin<br>C:\Program Files\PCL 1.11.0\3rdParty\Qhull\bin<br>C:\Program Files\PCL 1.11.0\3rdParty\VTK\bin<br>C:\Program Files\PCL 1.11.0\3rdParty\OpenNI2\Tools<br>C:\Program Files\PCL 1.11.0\3rdParty\OpenNI2\Redist</p>
<p>在系统变量下，配置如下图：<br><img src="/blog_img/PCL配置/6.png" alt=""><br>比如我的：<br>C:\Program Files\PCL 1.11.0\3rdParty\FLANN\bin<br>C:\Program Files\PCL 1.11.0\3rdParty\OpenNI2\Tools<br>C:\Program Files\PCL 1.11.0\3rdParty\Qhull\bin<br>C:\Program Files\PCL 1.11.0\3rdParty\VTK\bin<br>C:\Program Files\PCL 1.11.0\bin</p>
<hr>
<h1 id="6-cmake编译"><a href="#6-cmake编译" class="headerlink" title="6.cmake编译"></a>6.cmake编译</h1><p>以管理员身份运行cmake-gui<br>在你想要的文件下创建一个名为example的文件夹，然后在此目录下创建一个source和cmake_bin文件，比如我的：</p>
<p><img src="/blog_img/PCL配置/18.png" alt=""></p>
<p>在source里面创建一个cpp文件和CMakeLists.txt文件。<br>CmakeLists.txt里写入以下内容：</p>
<pre><code>cmake_minimum_required(VERSION 2.6 FATAL_ERROR)
project(test)
find_package(PCL 1.4 REQUIRED)
include_directories($&#123;PCL_INCLUDE_DIRS&#125;)
link_directories($&#123;PCL_LIBRARY_DIRS&#125;)  
add_definitions($&#123;PCL_DEFINITIONS&#125;)
add_executable (test test.cpp)
target_link_libraries (test $&#123;PCL_LIBRARIES&#125;)
</code></pre><p>其中这个test就是你创建的测试代码的名字，请保持一致，如果你换别的名字，请把txt文件的名字也一起改了。我的如下：<br><img src="/blog_img/PCL配置/19.png" alt=""></p>
<p>测试代码请网上去找，我用的是上一篇文件里的（里面有个D盘文件的读取可能会报错，但只要能出彩色的那个图就算配置成功了）。</p>
<p>跟着步骤添加<br><img src="/blog_img/PCL配置/20.png" alt=""></p>
<p>点击Configure，选x64<br><img src="/blog_img/PCL配置/21.jpg" alt=""></p>
<p>再点击一次configure<br><img src="/blog_img/PCL配置/22.jpg" alt=""></p>
<p>点击Generate,出现Generating done.<br><img src="/blog_img/PCL配置/23.png" alt=""></p>
<p>找到cmake_bin底下的test_sln 打开。<br><img src="/blog_img/PCL配置/24.jpg" alt=""></p>
<p>将test设置为启动项，并调试。<br><img src="/blog_img/PCL配置/25.png" alt=""></p>
<p><img src="/blog_img/PCL配置/26.jpg" alt=""></p>
<hr>
]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
  </entry>
  <entry>
    <title>Ubuntu更换源教程</title>
    <url>/2021/03/14/Ubuntu/Ubuntu%E6%9B%B4%E6%8D%A2%E6%BA%90%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p>参考<a href="https://blog.csdn.net/weixin_43876206/article/details/100924378">博客</a><br><a id="more"></a></p>
<h1 id="1-备份源列表"><a href="#1-备份源列表" class="headerlink" title="1.备份源列表"></a>1.备份源列表</h1><pre><code>sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak
</code></pre><h1 id="2-打开sources-list文件"><a href="#2-打开sources-list文件" class="headerlink" title="2.打开sources.list文件"></a>2.打开sources.list文件</h1><pre><code>sudo gedit /etc/apt/sources.list
</code></pre><h1 id="3-修改sources-list文件"><a href="#3-修改sources-list文件" class="headerlink" title="3.修改sources.list文件"></a>3.修改sources.list文件</h1><pre><code>#  阿里镜像源

deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse

deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse

deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse

deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse

deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse
</code></pre><h1 id="4-更新并升级"><a href="#4-更新并升级" class="headerlink" title="4.更新并升级"></a>4.更新并升级</h1><pre><code>sudo apt-get update &amp;&amp; sudo apt-get upgrade
</code></pre><h1 id="5-恢复源列表"><a href="#5-恢复源列表" class="headerlink" title="5.恢复源列表"></a>5.恢复源列表</h1><pre><code>sudo cp /etc/apt/sources.list.bak /etc/apt/sources.list
</code></pre><hr>
<p>其他的源请自己搜索，这里只放了阿里云的。</p>
<hr>
]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
  </entry>
  <entry>
    <title>PCL-1-11-Visual-Studio-2019-配置</title>
    <url>/2020/10/04/PCL/PCL-1-11-Visual-Studio-2019-%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="1-软件准备"><a href="#1-软件准备" class="headerlink" title="1.软件准备"></a>1.软件准备</h1><p>1.All in one 安装包。</p>
<p>2.获取All in one 包对应得PDB文件包，用于后期单步调试。<br><a id="more"></a><br>3.获取PCL源码包</p>
<p>4.安装Visual studio 2019编译器</p>
<p><img src="/blog_img/PCL配置/1.jpg" alt="示意图"></p>
<hr>
<h1 id="2-链接"><a href="#2-链接" class="headerlink" title="2.链接"></a>2.链接</h1><p><a href="https://github.com/PointCloudLibrary/pcl/releases">pcl下载地址</a><br><a href="https://visualstudio.microsoft.com/zh-hans/downloads/">visual studio下载地址</a></p>
<hr>
<h1 id="3-安装事项"><a href="#3-安装事项" class="headerlink" title="3.安装事项"></a>3.安装事项</h1><p>为了方便配置，pcl安装目录尽量默认，不默认后续添加目录需要选择对应的位置。</p>
<p>pcl安装请一定选择创建系统路径，visual studio和cmake安装位置随意，其他选项默认即可。</p>
<p>pcl安装完成后，请把下载的pcd文件解压，如下图：<br><img src="/blog_img/PCL配置/2.jpg" alt=""></p>
<p>将所有文件复制，安装到pcl下的BIN文件下<br><img src="/blog_img/PCL配置/3.jpg" alt=""></p>
<p>检查pcl安装目录下的 3rdParty-OpenNI2是否只有一个安装包（我的是这样），这可能是事先安装过SDK的原因，请卸载了重新安装在OpenNI2下，安装完成如下图：<br><img src="/blog_img/PCL配置/4.jpg" alt=""></p>
<hr>
<h1 id="4-关于Visual-studio安装项目"><a href="#4-关于Visual-studio安装项目" class="headerlink" title="4.关于Visual studio安装项目"></a>4.关于Visual studio安装项目</h1><p>我安装了这些负载</p>
<p><img src="/blog_img/PCL配置/5.png" alt=""></p>
<hr>
<h1 id="5-环境配置"><a href="#5-环境配置" class="headerlink" title="5.环境配置"></a>5.环境配置</h1><p>右键我的电脑——高级系统设置-环境变量，在path选项下新建如下几项，根据你pcl安装的位置来：<br><img src="/blog_img/PCL配置/6.jpg" alt=""></p>
<p>比如我的：<br>C:\Program Files\PCL 1.11.0\bin<br>C:\Program Files\PCL 1.11.0\3rdParty\FLANN\bin<br>C:\Program Files\PCL 1.11.0\3rdParty\Qhull\bin<br>C:\Program Files\PCL 1.11.0\3rdParty\VTK\bin<br>C:\Program Files\PCL 1.11.0\3rdParty\OpenNI2\Tools<br>C:\Program Files\PCL 1.11.0\3rdParty\OpenNI2\Redist</p>
<p>在系统变量下，配置如下图：<br><img src="/blog_img/PCL配置/6.png" alt=""><br>比如我的：<br>C:\Program Files\PCL 1.11.0\3rdParty\FLANN\bin<br>C:\Program Files\PCL 1.11.0\3rdParty\OpenNI2\Tools<br>C:\Program Files\PCL 1.11.0\3rdParty\Qhull\bin<br>C:\Program Files\PCL 1.11.0\3rdParty\VTK\bin<br>C:\Program Files\PCL 1.11.0\bin</p>
<hr>
<h1 id="6-配置"><a href="#6-配置" class="headerlink" title="6.配置"></a>6.配置</h1><p>打开visual studio，新建一个空项目如图：<br><img src="/blog_img/PCL配置/7.jpg" alt=""></p>
<p>在release下创建属性表（如果是DEBUG版本请在DEBUG下创建）<br><img src="/blog_img/PCL配置/8.png" alt=""></p>
<p>切换到解决方案资源管理器，右键-添加-新建项<br><img src="/blog_img/PCL配置/9.png" alt=""></p>
<p>添加C++文件<br><img src="/blog_img/PCL配置/10.png" alt=""></p>
<p>接下来配置：<br><img src="/blog_img/PCL配置/11.png" alt=""></p>
<p>包含目录下添加，建议手点：<br>C:\Program Files\PCL 1.11.0\include\pcl-1.11<br>C:\Program Files\PCL 1.11.0\3rdParty\Boost\include\boost-1_73<br>C:\Program Files\PCL 1.11.0\3rdParty\Eigen\eigen3<br>C:\Program Files\PCL 1.11.0\3rdParty\FLANN\include<br>C:\Program Files\PCL 1.11.0\3rdParty\Qhull\include<br>C:\Program Files\PCL 1.11.0\3rdParty\VTK\include\vtk-8.2<br>C:\Program Files\PCL 1.11.0\3rdParty\OpenNI2\Include</p>
<p>库目录添加：<br>C:\Program Files\PCL 1.11.0\lib<br>C:\Program Files\PCL 1.11.0\3rdParty\Boost\lib<br>C:\Program Files\PCL 1.11.0\3rdParty\FLANN\lib<br>C:\Program Files\PCL 1.11.0\3rdParty\Qhull\lib<br>C:\Program Files\PCL 1.11.0\3rdParty\VTK\lib<br>C:\Program Files\PCL 1.11.0\3rdParty\OpenNI2\Lib</p>
<p>接下来配置：<br><img src="/blog_img/PCL配置/12.jpg" alt=""></p>
<p>在预处理器定义处添加：<br>BOOST_USE_WINDOWS_H<br>NOMINMAX<br>_CRT_SECURE_NO_DEPRECATE</p>
<p>在项目属性表（Project_one）和release下创建得属性表（test_one）中把所有选项里得SDL检查全改成否，如下图：</p>
<p><img src="/blog_img/PCL配置/13.jpg" alt=""></p>
<p><img src="/blog_img/PCL配置/14.jpg" alt=""></p>
<hr>
<h1 id="7-附加依赖项"><a href="#7-附加依赖项" class="headerlink" title="7.附加依赖项"></a>7.附加依赖项</h1><p>将PCL 1.11.0\3rdParty\VTK\lib和PCL 1.11.0\lib这两个文件夹下的lib文件的release版本添加到附加依赖项中（DEBUG版本添加DEBUG类型文件）</p>
<p><img src="/blog_img/PCL配置/15.png" alt=""></p>
<p>文件名称我已经归类好了</p>
<p>release版本：</p>
<p>pcl_common.lib<br>pcl_features.lib<br>pcl_filters.lib<br>pcl_io.lib<br>pcl_io_ply.lib<br>pcl_kdtree.lib<br>pcl_keypoints.lib<br>pcl_ml.lib<br>pcl_octree.lib<br>pcl_outofcore.lib<br>pcl_people.lib<br>pcl_recognition.lib<br>pcl_registration.lib<br>pcl_sample_consensus.lib<br>pcl_search.lib<br>pcl_segmentation.lib<br>pcl_stereo.lib<br>pcl_surface.lib<br>pcl_tracking.lib<br>pcl_visualization.lib<br>vtkChartsCore-8.2.lib<br>vtkCommonColor-8.2.lib<br>vtkCommonComputationalGeometry-8.2.lib<br>vtkCommonCore-8.2.lib<br>vtkCommonDataModel-8.2.lib<br>vtkCommonExecutionModel-8.2.lib<br>vtkCommonMath-8.2.lib<br>vtkCommonMisc-8.2.lib<br>vtkCommonSystem-8.2.lib<br>vtkCommonTransforms-8.2.lib<br>vtkDICOMParser-8.2.lib<br>vtkDomainsChemistry-8.2.lib<br>vtkDomainsChemistryOpenGL2-8.2.lib<br>vtkdoubleconversion-8.2.lib<br>vtkexodusII-8.2.lib<br>vtkexpat-8.2.lib<br>vtkFiltersAMR-8.2.lib<br>vtkFiltersCore-8.2.lib<br>vtkFiltersExtraction-8.2.lib<br>vtkFiltersFlowPaths-8.2.lib<br>vtkFiltersGeneral-8.2.lib<br>vtkFiltersGeneric-8.2.lib<br>vtkFiltersGeometry-8.2.lib<br>vtkFiltersHybrid-8.2.lib<br>vtkFiltersHyperTree-8.2.lib<br>vtkFiltersImaging-8.2.lib<br>vtkFiltersModeling-8.2.lib<br>vtkFiltersParallel-8.2.lib<br>vtkFiltersParallelImaging-8.2.lib<br>vtkFiltersPoints-8.2.lib<br>vtkFiltersProgrammable-8.2.lib<br>vtkFiltersSelection-8.2.lib<br>vtkFiltersSMP-8.2.lib<br>vtkFiltersSources-8.2.lib<br>vtkFiltersStatistics-8.2.lib<br>vtkFiltersTexture-8.2.lib<br>vtkFiltersTopology-8.2.lib<br>vtkFiltersVerdict-8.2.lib<br>vtkfreetype-8.2.lib<br>vtkGeovisCore-8.2.lib<br>vtkgl2ps-8.2.lib<br>vtkglew-8.2.lib<br>vtkGUISupportMFC-8.2.lib<br>vtkhdf5_hl-8.2.lib<br>vtkhdf5-8.2.lib<br>vtkImagingColor-8.2.lib<br>vtkImagingCore-8.2.lib<br>vtkImagingFourier-8.2.lib<br>vtkImagingGeneral-8.2.lib<br>vtkImagingHybrid-8.2.lib<br>vtkImagingMath-8.2.lib<br>vtkImagingMorphological-8.2.lib<br>vtkImagingSources-8.2.lib<br>vtkImagingStatistics-8.2.lib<br>vtkImagingStencil-8.2.lib<br>vtkInfovisCore-8.2.lib<br>vtkInfovisLayout-8.2.lib<br>vtkInteractionImage-8.2.lib<br>vtkInteractionStyle-8.2.lib<br>vtkInteractionWidgets-8.2.lib<br>vtkIOAMR-8.2.lib<br>vtkIOAsynchronous-8.2.lib<br>vtkIOCityGML-8.2.lib<br>vtkIOCore-8.2.lib<br>vtkIOEnSight-8.2.lib<br>vtkIOExodus-8.2.lib<br>vtkIOExport-8.2.lib<br>vtkIOExportOpenGL2-8.2.lib<br>vtkIOExportPDF-8.2.lib<br>vtkIOGeometry-8.2.lib<br>vtkIOImage-8.2.lib<br>vtkIOImport-8.2.lib<br>vtkIOInfovis-8.2.lib<br>vtkIOLegacy-8.2.lib<br>vtkIOLSDyna-8.2.lib<br>vtkIOMINC-8.2.lib<br>vtkIOMovie-8.2.lib<br>vtkIONetCDF-8.2.lib<br>vtkIOParallel-8.2.lib<br>vtkIOParallelXML-8.2.lib<br>vtkIOPLY-8.2.lib<br>vtkIOSegY-8.2.lib<br>vtkIOSQL-8.2.lib<br>vtkIOTecplotTable-8.2.lib<br>vtkIOVeraOut-8.2.lib<br>vtkIOVideo-8.2.lib<br>vtkIOXML-8.2.lib<br>vtkIOXMLParser-8.2.lib<br>vtkjpeg-8.2.lib<br>vtkjsoncpp-8.2.lib<br>vtklibharu-8.2.lib<br>vtklibxml2-8.2.lib<br>vtklz4-8.2.lib<br>vtklzma-8.2.lib<br>vtkmetaio-8.2.lib<br>vtkNetCDF-8.2.lib<br>vtkogg-8.2.lib<br>vtkParallelCore-8.2.lib<br>vtkpng-8.2.lib<br>vtkproj-8.2.lib<br>vtkpugixml-8.2.lib<br>vtkRenderingAnnotation-8.2.lib<br>vtkRenderingContext2D-8.2.lib<br>vtkRenderingContextOpenGL2-8.2.lib<br>vtkRenderingCore-8.2.lib<br>vtkRenderingExternal-8.2.lib<br>vtkRenderingFreeType-8.2.lib<br>vtkRenderingGL2PSOpenGL2-8.2.lib<br>vtkRenderingImage-8.2.lib<br>vtkRenderingLabel-8.2.lib<br>vtkRenderingLOD-8.2.lib<br>vtkRenderingOpenGL2-8.2.lib<br>vtkRenderingVolume-8.2.lib<br>vtkRenderingVolumeOpenGL2-8.2.lib<br>vtksqlite-8.2.lib<br>vtksys-8.2.lib<br>vtktheora-8.2.lib<br>vtktiff-8.2.lib<br>vtkverdict-8.2.lib<br>vtkViewsContext2D-8.2.lib<br>vtkViewsCore-8.2.lib<br>vtkViewsInfovis-8.2.lib<br>vtkzlib-8.2.lib</p>
<p>DEBUG版本：</p>
<p>pcl_commond.lib<br>pcl_featuresd.lib<br>pcl_filtersd.lib<br>pcl_io_plyd.lib<br>pcl_iod.lib<br>pcl_kdtreed.lib<br>pcl_keypointsd.lib<br>pcl_mld.lib<br>pcl_octreed.lib<br>pcl_outofcored.lib<br>pcl_peopled.lib<br>pcl_recognitiond.lib<br>pcl_registrationd.lib<br>pcl_sample_consensusd.lib<br>pcl_searchd.lib<br>pcl_segmentationd.lib<br>pcl_stereod.lib<br>pcl_surfaced.lib<br>pcl_trackingd.lib<br>pcl_visualizationd.lib<br>vtkChartsCore-8.2-gd.lib<br>vtkCommonColor-8.2-gd.lib<br>vtkCommonComputationalGeometry-8.2-gd.lib<br>vtkCommonCore-8.2-gd.lib<br>vtkCommonDataModel-8.2-gd.lib<br>vtkCommonExecutionModel-8.2-gd.lib<br>vtkCommonMath-8.2-gd.lib<br>vtkCommonMisc-8.2-gd.lib<br>vtkCommonSystem-8.2-gd.lib<br>vtkCommonTransforms-8.2-gd.lib<br>vtkDICOMParser-8.2-gd.lib<br>vtkDomainsChemistry-8.2-gd.lib<br>vtkDomainsChemistryOpenGL2-8.2-gd.lib<br>vtkdoubleconversion-8.2-gd.lib<br>vtkexodusII-8.2-gd.lib<br>vtkexpat-8.2-gd.lib<br>vtkFiltersAMR-8.2-gd.lib<br>vtkFiltersCore-8.2-gd.lib<br>vtkFiltersExtraction-8.2-gd.lib<br>vtkFiltersFlowPaths-8.2-gd.lib<br>vtkFiltersGeneral-8.2-gd.lib<br>vtkFiltersGeneric-8.2-gd.lib<br>vtkFiltersGeometry-8.2-gd.lib<br>vtkFiltersHybrid-8.2-gd.lib<br>vtkFiltersHyperTree-8.2-gd.lib<br>vtkFiltersImaging-8.2-gd.lib<br>vtkFiltersModeling-8.2-gd.lib<br>vtkFiltersParallel-8.2-gd.lib<br>vtkFiltersParallelImaging-8.2-gd.lib<br>vtkFiltersPoints-8.2-gd.lib<br>vtkFiltersProgrammable-8.2-gd.lib<br>vtkFiltersSelection-8.2-gd.lib<br>vtkFiltersSMP-8.2-gd.lib<br>vtkFiltersSources-8.2-gd.lib<br>vtkFiltersStatistics-8.2-gd.lib<br>vtkFiltersTexture-8.2-gd.lib<br>vtkFiltersTopology-8.2-gd.lib<br>vtkFiltersVerdict-8.2-gd.lib<br>vtkfreetype-8.2-gd.lib<br>vtkGeovisCore-8.2-gd.lib<br>vtkgl2ps-8.2-gd.lib<br>vtkglew-8.2-gd.lib<br>vtkGUISupportMFC-8.2-gd.lib<br>vtkhdf5_hl-8.2-gd.lib<br>vtkhdf5-8.2-gd.lib<br>vtkImagingColor-8.2-gd.lib<br>vtkImagingCore-8.2-gd.lib<br>vtkImagingFourier-8.2-gd.lib<br>vtkImagingGeneral-8.2-gd.lib<br>vtkImagingHybrid-8.2-gd.lib<br>vtkImagingMath-8.2-gd.lib<br>vtkImagingMorphological-8.2-gd.lib<br>vtkImagingSources-8.2-gd.lib<br>vtkImagingStatistics-8.2-gd.lib<br>vtkImagingStencil-8.2-gd.lib<br>vtkInfovisCore-8.2-gd.lib<br>vtkInfovisLayout-8.2-gd.lib<br>vtkInteractionImage-8.2-gd.lib<br>vtkInteractionStyle-8.2-gd.lib<br>vtkInteractionWidgets-8.2-gd.lib<br>vtkIOAMR-8.2-gd.lib<br>vtkIOAsynchronous-8.2-gd.lib<br>vtkIOCityGML-8.2-gd.lib<br>vtkIOCore-8.2-gd.lib<br>vtkIOEnSight-8.2-gd.lib<br>vtkIOExodus-8.2-gd.lib<br>vtkIOExport-8.2-gd.lib<br>vtkIOExportOpenGL2-8.2-gd.lib<br>vtkIOExportPDF-8.2-gd.lib<br>vtkIOGeometry-8.2-gd.lib<br>vtkIOImage-8.2-gd.lib<br>vtkIOImport-8.2-gd.lib<br>vtkIOInfovis-8.2-gd.lib<br>vtkIOLegacy-8.2-gd.lib<br>vtkIOLSDyna-8.2-gd.lib<br>vtkIOMINC-8.2-gd.lib<br>vtkIOMovie-8.2-gd.lib<br>vtkIONetCDF-8.2-gd.lib<br>vtkIOParallel-8.2-gd.lib<br>vtkIOParallelXML-8.2-gd.lib<br>vtkIOPLY-8.2-gd.lib<br>vtkIOSegY-8.2-gd.lib<br>vtkIOSQL-8.2-gd.lib<br>vtkIOTecplotTable-8.2-gd.lib<br>vtkIOVeraOut-8.2-gd.lib<br>vtkIOVideo-8.2-gd.lib<br>vtkIOXML-8.2-gd.lib<br>vtkIOXMLParser-8.2-gd.lib<br>vtkjpeg-8.2-gd.lib<br>vtkjsoncpp-8.2-gd.lib<br>vtklibharu-8.2-gd.lib<br>vtklibxml2-8.2-gd.lib<br>vtklz4-8.2-gd.lib<br>vtklzma-8.2-gd.lib<br>vtkmetaio-8.2-gd.lib<br>vtkNetCDF-8.2-gd.lib<br>vtkogg-8.2-gd.lib<br>vtkParallelCore-8.2-gd.lib<br>vtkpng-8.2-gd.lib<br>vtkproj-8.2-gd.lib<br>vtkpugixml-8.2-gd.lib<br>vtkRenderingAnnotation-8.2-gd.lib<br>vtkRenderingContext2D-8.2-gd.lib<br>vtkRenderingContextOpenGL2-8.2-gd.lib<br>vtkRenderingCore-8.2-gd.lib<br>vtkRenderingExternal-8.2-gd.lib<br>vtkRenderingFreeType-8.2-gd.lib<br>vtkRenderingGL2PSOpenGL2-8.2-gd.lib<br>vtkRenderingImage-8.2-gd.lib<br>vtkRenderingLabel-8.2-gd.lib<br>vtkRenderingLOD-8.2-gd.lib<br>vtkRenderingOpenGL2-8.2-gd.lib<br>vtkRenderingVolume-8.2-gd.lib<br>vtkRenderingVolumeOpenGL2-8.2-gd.lib<br>vtksqlite-8.2-gd.lib<br>vtksys-8.2-gd.lib<br>vtktheora-8.2-gd.lib<br>vtktiff-8.2-gd.lib<br>vtkverdict-8.2-gd.lib<br>vtkViewsContext2D-8.2-gd.lib<br>vtkViewsCore-8.2-gd.lib<br>vtkViewsInfovis-8.2-gd.lib<br>vtkzlib-8.2-gd.lib</p>
<h1 id="8-程序测试"><a href="#8-程序测试" class="headerlink" title="8.程序测试"></a>8.程序测试</h1><pre><code>#include &lt;pcl/visualization/cloud_viewer.h&gt;  
#include &lt;iostream&gt;  
#include &lt;pcl/io/io.h&gt;  
#include &lt;pcl/io/pcd_io.h&gt;  
int user_data;
void viewerOneOff(pcl::visualization::PCLVisualizer&amp; viewer)
&#123;
    viewer.setBackgroundColor(1.0, 0.5, 1.0);
    pcl::PointXYZ o;
    o.x = 1.0;
    o.y = 0;
    o.z = 0;
    viewer.addSphere(o, 0.25, &quot;sphere&quot;, 0);
    std::cout &lt;&lt; &quot;i only run once&quot; &lt;&lt; std::endl;
&#125;
void viewerPsycho(pcl::visualization::PCLVisualizer&amp; viewer)
&#123;
    static unsigned count = 0;
    std::stringstream ss;
    ss &lt;&lt; &quot;Once per viewer loop: &quot; &lt;&lt; count++;
    viewer.removeShape(&quot;text&quot;, 0);
    viewer.addText(ss.str(), 200, 300, &quot;text&quot;, 0);
    //FIXME: possible race condition here:  
    user_data++;
&#125;
int main()
&#123;
    pcl::PointCloud&lt;pcl::PointXYZRGBA&gt;::Ptr cloud(new pcl::PointCloud&lt;pcl::PointXYZRGBA&gt;);
    pcl::io::loadPCDFile(&quot;D:\\Microsoft Visual Studio 10.0\\Projects\\pcl\\pcl\\my_point_cloud.pcd&quot;, *cloud);
    pcl::visualization::CloudViewer viewer(&quot;Cloud Viewer&quot;);
    //blocks until the cloud is actually rendered  
    viewer.showCloud(cloud);
    //use the following functions to get access to the underlying more advanced/powerful  
    //PCLVisualizer  
    //This will only get called once  
    viewer.runOnVisualizationThreadOnce(viewerOneOff);
    //This will get called once per visualization iteration  
    viewer.runOnVisualizationThread(viewerPsycho);
    while (!viewer.wasStopped())
    &#123;
        //you can also do cool processing here  
        //FIXME: Note that this is running in a separate thread from viewerPsycho  
        //and you should guard against race conditions yourself...  
        user_data++;
    &#125;
    return 0;
&#125;
</code></pre><p>测试结果：</p>
<p><img src="/blog_img/PCL配置/16.png" alt=""></p>
<hr>
]]></content>
      <categories>
        <category>PCL</category>
      </categories>
  </entry>
  <entry>
    <title>Unable to access &#39;https://gitee.com/自己的项目/&#39;: Could not resolve host: gitee.com问题的解决</title>
    <url>/2020/10/23/Ubuntu/Unable-to-access-https-gitee-com-%E8%87%AA%E5%B7%B1%E7%9A%84%E9%A1%B9%E7%9B%AE-Could-not-resolve-host-gitee-com%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<p>果然玩hexo报错是在所难免，就好像我已经长大，读研以后乃至以后得日子，可能总是繁琐常伴。今天在hexo d推到GITEE上时，报了错。<br><a id="more"></a><br>原因是由于爬梯子代理网络的问题，其实折腾了下。具体哪个步骤解决了这个问题，我也不是很清楚，这次做好记录方便以后继续更新把。</p>
<p>首先我是从这篇<a href="https://blog.csdn.net/weixin_37166398/article/details/101422239?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param">博客</a>里查到了我的ip，然后ping了查到的ip，然后在system32\drives\etc\hosts里添加了   </p>
<pre><code>IP gitee.com
</code></pre><p>然而这并没有继续运行成功。<br>然后我有尝试<br>1.管理员身份运行cmd<br>2.输入 </p>
<pre><code>netsh winsock reset
</code></pre><p>3.重启</p>
<p>还有尝试命令行输入  </p>
<pre><code>git config --global --unset http.proxy 
git config --global --unset https.proxy
</code></pre><p>最后发现还是不行，结果我把第一步添加的IP gitee.com删了居然好了。</p>
<p>所以我觉得问题在以下原因，第一个是我没有在打开代理下hexo d,平时确实是没有注意这个问题，但关闭代理下好像有时候也成功过，但这个问题确实出在了代理的问题上。<br>另外就是我的代理导致了无法上传上去，上述的两个操作我也不知道哪个解决了这个问题，毕竟我先添加了IP，然后再试了这两种清楚的。如果下次再出现这个问题，有了结果再继续补充。</p>
<p>2020/11/17<br>他妈个头的，翻墙今天又部署不上去了，前面的用了也不好使，又试了一下这个更改DNS的方法成功了，<a href="https://blog.csdn.net/weixin_42476786/article/details/82691934?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.add_param_isCf&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.add_param_isCf">链接</a>在这</p>
<hr>
]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
  </entry>
  <entry>
    <title>ubuntu下的firefox无法播放视频解决方案</title>
    <url>/2021/03/14/Ubuntu/ubuntu%E4%B8%8B%E7%9A%84firefox%E6%97%A0%E6%B3%95%E6%92%AD%E6%94%BE%E8%A7%86%E9%A2%91%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h1 id="1-下载flash的tar-gz文件"><a href="#1-下载flash的tar-gz文件" class="headerlink" title="1.下载flash的tar.gz文件"></a>1.下载flash的tar.gz文件</h1><p>直接去<a href="https://www.flash.cn/">官网链接</a>下载<br><a id="more"></a></p>
<h1 id="2-解压tar-gz文件"><a href="#2-解压tar-gz文件" class="headerlink" title="2.解压tar.gz文件"></a>2.解压tar.gz文件</h1><pre><code>tar -zxvf filename.tar.gz
</code></pre><p>注意filename.tar.gz就是你下载的文件的名字，可以直接复制下载包名字。</p>
<h1 id="3-移动解压文件夹"><a href="#3-移动解压文件夹" class="headerlink" title="3.移动解压文件夹"></a>3.移动解压文件夹</h1><p>先进入安装包目录下,然后</p>
<pre><code>sudo cp libflashplayer.so /usr/lib/firefox/browser/plugins
sudo cp -r usr/* /usr
</code></pre><h1 id="4-缺少依赖报错解决"><a href="#4-缺少依赖报错解决" class="headerlink" title="4.缺少依赖报错解决"></a>4.缺少依赖报错解决</h1><pre><code>sudo apt-get install ffmpeg  //ffmpeg支持H.264解码
</code></pre><hr>
]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
  </entry>
  <entry>
    <title>dpkg被中断的解决办法</title>
    <url>/2021/03/14/Ubuntu/dpkg%E8%A2%AB%E4%B8%AD%E6%96%AD%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    <content><![CDATA[<p>linux系统安装软件是有时会碰到“dpkg 被中断,您必须手工运行 sudo dpkg –configure -a解决此问题”，然而按照提示运行却并没能很好的解决问题。其实导致这个问题的主要原因是因为/var/lib/dpkg/updates文件下的文件有问题，可能是其他软件安装过程或是其他原因导致的，这里删除掉然后重建即可。<br><a id="more"></a></p>
<pre><code>sudo rm /var/lib/dpkg/updates/*
sudo apt-get update
sudo apt-get upgrade
</code></pre><p>解释：[<em>]sudo apt-get update指令会重新建立这些资料，所以不必担心删除后会出问题；<br>[</em>]sudo apt-get upgrade会更新你的电脑里面已安装的软件的明细，根据软件的明细更新软件到最新版。<br>PS：“dpkg ”是“Debian Packager ”的简写。为 “Debian” 专门开发的套件管理系统，方便软件的安装、更新及移除。所有源自“Debian”的“Linux ”发行版都使用 “dpkg”</p>
<p>参考<a href="https://blog.csdn.net/coolcooljob/article/details/79964812">博客</a></p>
<hr>
]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
  </entry>
  <entry>
    <title>ubuntu安装gcc依赖关系报错</title>
    <url>/2021/03/14/Ubuntu/ubuntu%E5%AE%89%E8%A3%85gcc%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB%E6%8A%A5%E9%94%99/</url>
    <content><![CDATA[<p>使用aptitude包依赖管理工具替代apt处理，看其他的博客说这个得慎用，不过用来安装gcc倒是没啥问题。<br><a id="more"></a></p>
<pre><code>sudo apt-get install aptitude
sudo aptitude install gcc g++
</code></pre><p>解决方案里选择no,yes,yes.<br>参考<a href="https://blog.csdn.net/CLZHIT/article/details/104508894">博客</a></p>
<hr>
]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
  </entry>
  <entry>
    <title>ubuntu下解决wps2019缺少字体问题</title>
    <url>/2021/03/14/Ubuntu/ubuntu%E4%B8%8B%E8%A7%A3%E5%86%B3wps2019%E7%BC%BA%E5%B0%91%E5%AD%97%E4%BD%93%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>主要参考<a href="https://blog.csdn.net/sunmengke1101/article/details/103436997">博客</a><br><a id="more"></a></p>
<h1 id="1-准备字体包"><a href="#1-准备字体包" class="headerlink" title="1.准备字体包"></a>1.准备字体包</h1><p><a href="https://wws.lanzous.com/iBIiqmwnvve">下载链接</a></p>
<h1 id="2-解压到指定目录下"><a href="#2-解压到指定目录下" class="headerlink" title="2.解压到指定目录下"></a>2.解压到指定目录下</h1><pre><code>sudo unzip wps_symbol_fonts.zip -d /home/&lt;user&gt;/usr/share/fonts
</code></pre><h1 id="3-到解压的根目录下安装"><a href="#3-到解压的根目录下安装" class="headerlink" title="3.到解压的根目录下安装"></a>3.到解压的根目录下安装</h1><p>依次打开每个文件并点击安装即可</p>
<hr>
]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
  </entry>
  <entry>
    <title>ubuntu安装vim依赖关系报错</title>
    <url>/2021/03/14/Ubuntu/ubuntu%E5%AE%89%E8%A3%85vim%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB%E6%8A%A5%E9%94%99/</url>
    <content><![CDATA[<p>按如下步骤进行就可：<br><a id="more"></a></p>
<pre><code>sudo apt-get purge vim-common
sudo apt-get update
sudo apt-get upgrade
sudo apt-get install vim
</code></pre><hr>
]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
  </entry>
  <entry>
    <title>安装snap以及常用命令</title>
    <url>/2021/03/14/Ubuntu/%E5%AE%89%E8%A3%85snap/</url>
    <content><![CDATA[<h1 id="1-安装snap"><a href="#1-安装snap" class="headerlink" title="1.安装snap"></a>1.安装snap</h1><a id="more"></a>
<pre><code>sudo apt-get install snapd
sudo apt-get install snapcraft
</code></pre><h1 id="2-常用命令"><a href="#2-常用命令" class="headerlink" title="2.常用命令"></a>2.常用命令</h1><pre><code>//列出已经安装的snap包
sudo snap list

//搜索要安装的snap包
sudo snap find &lt;text to search&gt;

//安装一个snap包
sudo snap install &lt;snap name&gt;

//更新一个snap包，如果你后面不加包的名字的话那就是更新所有的snap包
sudo snap refresh &lt;snap name&gt;

//把一个包还原到以前安装的版本
sudo snap revert &lt;snap name&gt;

//删除一个snap包
sudo snap remove &lt;snap name&gt;
</code></pre><hr>
]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
  </entry>
  <entry>
    <title>我的Office激活码</title>
    <url>/2020/09/26/%E5%85%B6%E4%BB%96/%E6%88%91%E7%9A%84Office%E6%BF%80%E6%B4%BB%E7%A0%81/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">Enter password to read.</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="8896adb0b14435a87dfca3d6aa0b0f714c095a6dc8bb149b363b64dc1c09a4ce">a40b706f3ef3cecdee82bde9ce2bd4514c0daefd2ecc9a0471c6dd32fb89c21dd33d989c9838561713a671711864b0b1a1a4480b4508e9ff8837f455c5dce0fe5f300a44bdd7e4e87f4cf4ad6a977b3a2e1fb4941673530eba42a436b7ddbc2a833161220ce856a9c50b0f0a00948c6120e291cacc8235d9112cea2d0ff237ff547ad3c0557cede69bb6e0acac70ff7e8dfd7357b4b0819f29e0b32a89991ff85dbb291e5440a99f3e89272087d1a7bad163b67007c9db378d5b7519efb4bc6adfc98224fb4ce577a17143fe36acb2235be6db2fbdd89c6784c0966f78aecbf7df789c5ac3fbdc42aad6b3332ae1ff1e862ad8340e40571113b1a0f03023896f1f4e9d0282ddc48e33f8992ebced357dfafab8477f1b7ddb0c479b4ef223cd7aa6c3b47bac939edf42c2ea6eeb5976a6c37e76ad4ac9a7c25cf6e5f0161cbe474b844f9f5aac68420cd9c0d2772ee879fa77d13cf4e12c6ca9abee8f00f04f8e744939f178fec537b3aa17a80c606fb7</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <tags>
        <tag>-office</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu配置C/C++开发环境</title>
    <url>/2021/03/14/Ubuntu/ubuntu%E9%85%8D%E7%BD%AEC-C-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<h1 id="1-在代码文件夹下建立两个文件"><a href="#1-在代码文件夹下建立两个文件" class="headerlink" title="1.在代码文件夹下建立两个文件"></a>1.在代码文件夹下建立两个文件</h1><p>launch.json 以及 tasks.json<br><a id="more"></a></p>
<h1 id="2-给这个两个文件配置文件"><a href="#2-给这个两个文件配置文件" class="headerlink" title="2.给这个两个文件配置文件"></a>2.给这个两个文件配置文件</h1><p>launch.json:</p>
<pre><code>&#123;    // Use IntelliSense to learn about possible attributes.
    // Hover to view descriptions of existing attributes.
    // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387
    &quot;version&quot;: &quot;0.2.0&quot;,
    &quot;configurations&quot;: [
        &#123;
            &quot;name&quot;: &quot;(gdb) Launch&quot;,
            &quot;type&quot;: &quot;cppdbg&quot;,
            &quot;request&quot;: &quot;launch&quot;,
            &quot;program&quot;: &quot;$&#123;workspaceFolder&#125;/$&#123;fileBasenameNoExtension&#125;.out&quot;,
            &quot;args&quot;: [],
            &quot;stopAtEntry&quot;: false,
            &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;&quot;,
            &quot;environment&quot;: [],
            &quot;externalConsole&quot;: true,    //如果不要窗口弹出，在ide中显示，就设置成 false
            &quot;MIMode&quot;: &quot;gdb&quot;,
            &quot;preLaunchTask&quot;: &quot;build&quot;,   //表示预先生成一个中间文件，用于g++运行
            &quot;setupCommands&quot;: [
                &#123;
                    &quot;description&quot;: &quot;Enable pretty-printing for gdb&quot;,
                    &quot;text&quot;: &quot;-enable-pretty-printing&quot;,
                    &quot;ignoreFailures&quot;: true
                &#125;
            ]
        &#125;
    ]
&#125;
</code></pre><p>tasks.json:</p>
<pre><code>&#123;
    // See https://go.microsoft.com/fwlink/?LinkId=733558
    // for the documentation about the tasks.json format
    &quot;version&quot;: &quot;2.0.0&quot;,
    &quot;tasks&quot;: [
        &#123;
            &quot;label&quot;: &quot;build&quot;,
            &quot;type&quot;: &quot;shell&quot;,
            &quot;command&quot;: &quot;g++&quot;,
            &quot;args&quot;: [&quot;-g&quot;, &quot;$&#123;file&#125;&quot;, &quot;-std=c++11&quot;, &quot;-o&quot;, &quot;$&#123;fileBasenameNoExtension&#125;.out&quot;]    //相当于 g++ -g main.cpp -std=c++11 -o main.out
        &#125;
    ]
&#125;
</code></pre><p>参考<a href="https://blog.csdn.net/suiyueruge1314/article/details/106125949">博客</a></p>
<hr>
]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
  </entry>
  <entry>
    <title>资源</title>
    <url>/2020/10/04/%E5%85%B6%E4%BB%96/%E8%B5%84%E6%BA%90/</url>
    <content><![CDATA[<p>准备把一些资源都放在这个博客下，持续更新，有需要得自取。</p>
<h1 id="1-Linux学习笔记"><a href="#1-Linux学习笔记" class="headerlink" title="1.Linux学习笔记"></a>1.Linux学习笔记</h1><p><a href="https://wws.lanzous.com/iKIZfh7eeuh">链接</a></p>
<a id="more"></a>
<h1 id="2-cloud-compare中文版使用手册"><a href="#2-cloud-compare中文版使用手册" class="headerlink" title="2.cloud compare中文版使用手册"></a>2.cloud compare中文版使用手册</h1><p><a href="https://wws.lanzous.com/imyXlh3nide">链接</a></p>
<hr>
<h1 id="3-深度学习"><a href="#3-深度学习" class="headerlink" title="3.深度学习"></a>3.深度学习</h1><p><a href="https://www.bilibili.com/video/BV164411m79z?from=search&amp;seid=8194466955642792600">吴恩达深度学习课程</a></p>
<p><a href="https://www.kesci.com/home/project/5e20243e2823a10036b542da">吴恩达课程配套科目</a></p>
<p><a href="http://www.ai-start.com/dl2017/">吴恩达深度学习笔记</a></p>
<hr>
<h1 id="4-壁纸"><a href="#4-壁纸" class="headerlink" title="4.壁纸"></a>4.壁纸</h1><p><a href="https://wallhaven.cc/">地址</a></p>
<h1 id="5-1080p下载"><a href="#5-1080p下载" class="headerlink" title="5.1080p下载"></a>5.1080p下载</h1><p><a href="https://www.y2mate.com/en60/">下载地址</a></p>
<hr>
<h1 id="6-视频字幕下载"><a href="#6-视频字幕下载" class="headerlink" title="6.视频字幕下载"></a>6.视频字幕下载</h1><p><a href="https://www.findyoutube.net/">下载地址</a><br>版权限制，目前下载为VTT格式，需要在Subtitle Edit里将VTT转为SRT格式。</p>
<hr>
<h1 id="7-Subtitle-Edit-vvt-srt"><a href="#7-Subtitle-Edit-vvt-srt" class="headerlink" title="7.Subtitle Edit(vvt-srt)"></a>7.Subtitle Edit(vvt-srt)</h1><p><a href="https://www.nikse.dk/subtitleedit/">下载地址</a><br>可以VTT2SRT SRT2VTT,有强大的字幕编辑功能。</p>
<hr>
<h1 id="8-Arctime-制作内嵌字幕视频"><a href="#8-Arctime-制作内嵌字幕视频" class="headerlink" title="8.Arctime(制作内嵌字幕视频)"></a>8.Arctime(制作内嵌字幕视频)</h1><p><a href="https://arctime.org/">下载地址</a></p>
<h1 id="9-Snipaste"><a href="#9-Snipaste" class="headerlink" title="9.Snipaste"></a>9.Snipaste</h1><p>微软商店免费下载，可以截图、取图、可以取色。</p>
]]></content>
      <categories>
        <category>资源</category>
      </categories>
  </entry>
  <entry>
    <title>IDEA快捷键</title>
    <url>/2021/05/24/Java%E5%9F%BA%E7%A1%80/IDEA%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<p>查看类的结构：ctrl+f12</p>
<p>查看类的继承图：ctrl+alt+shift+u</p>
<p>查看函数参数：ctrl+p</p>
<p>查看函数介绍：ctrl+q</p>
<p>格式化代码：ctrl+shift+l</p>
<p>代码补全：alt+/</p>
<p>提示关键字：alt+shift+/</p>
<p>万能结错/生成返回值变量：alt+enter</p>
<p>查看继承结构：ctrl+h</p>
<p>反撤销：ctrl+shift+z</p>
<p>大小写转换：ctrl+shift+u</p>
<p>收起所有的方法：ctrl+shift+-</p>
<p>打开所有的方法：ctrl+shfit++</p>
<p>重命名：shift+f6</p>
<p>打开文件所在位置：ctrl+shift+x</p>
<p>生成try-catch等：ctrl+alt+t</p>
<p>局部变量抽取为成员变量：ctrl+alt+f</p>
<p>添加到收藏夹：alt+shift+f</p>
<p>搜索类中的错误：f2</p>
<p>复制选取：ctrl+shift+v</p>
<p>显示方法在哪调用过：ctrl+shift+h</p>
<p>快写构造函数：alt+insert</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title>C++知识点</title>
    <url>/2021/05/31/C++/C++%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<h1 id="1-cin-clear"><a href="#1-cin-clear" class="headerlink" title="1. cin.clear()"></a>1. cin.clear()</h1><p>是用来更改cin的状态标示符的。</p>
<p>cin.sync（）是用来清除缓存区的数据流的。<br>如果标示符没有改变那么即使清除了数据流也无法输入。所以两个要联合起来使用。</p>
<p>我们定义要输入到的变量是整型,但如果我们输入了英文字母或者汉字,那就会发生错误,cin里有个方法能检测这个错误,就是cin.rdstate(); 当cin.rdstate()返回0(即ios::goodbit)时表示无错误,可以继续输入或者操作,若返回4则发生非致命错误即ios::failbit,则不能继续输入或操作.而cin.clear则可以控制我们此时cin里对这个问题的一个标识.语发如下: cin.clear(标识符); 标识符号为:</p>
<p>goodbit 无错误<br>Eofbit 已到达文件尾<br>failbit 非致命的输入/输出错误，可挽回<br>badbit　致命的输入/输出错误,无法挽回 若在输入输出类里.需要加ios::标识符号<br>通过cin.clear,我们能确认它的内部标识符,如果输入错误则能重新输入.结合真正的清空数据流方法cin.sync(),请看下例:</p>
<pre><code class="lang-c++">include &lt;iostream&gt;
using namespace std; 
int main()  
&#123;         
    int a;         
    while(1)         
    &#123;                 
        cin&gt;&gt;a;                 
        if(!cin)            //条件可改写为cin.fail()                 
        &#123;                         
            cout&lt;&lt;&quot;输入有错!请重新输入&quot;&lt;&lt;endl;                         
            cin.clear();                          
            cin.sync();   //清空流                 
        &#125;                 
        else                 
        &#123;                         
            cout&lt;&lt;a;                         
            break;                 
        &#125;         
    &#125;         
    system(&quot;pause&quot;); 
&#125;
</code></pre>
<p>上面的cin.clear()默认参数为0,即无错误,正常操作.当我们输入英文字母’k’时,它的状态标识改为fail,即错误,用cout对用户输出信息,再用cin.clear让错误标识改回为0,让我们可以继续输入,再清空流数据继续输入.如果我们没有了cin.clear,则会进入死循环,其过程为我们输入了英文字母,它的状态标识便为fail,当运行到条件判断时,便总是回到错误的条件表示里,并且我们再也没办法输入,因为错误的表示关闭了cin,所以会进入死循环.</p>
<h1 id="2-常量指针和指针常量"><a href="#2-常量指针和指针常量" class="headerlink" title="2. 常量指针和指针常量"></a>2. 常量指针和指针常量</h1><p>在第一次听黑马C++的时候，是按老师的说法自己记忆的，而在回顾C++ primer plus时，对这个的理解才更加深刻，先看两者的声明。</p>
<pre><code class="lang-c++">int sloth =3;
const int* ps = &amp;sloth;        // a pointer to const int
int* const finger = &amp;sloth;    // a const pointer to int
</code></pre>
<p>根据英文的理解比中文好的多， a pointer to const int 代表这个指针指向的常量是不可以改变的，但是这个指针是指向却是可以改变的。</p>
<p>第二个表明这个指针它是一个常量，它是没法改变的，但是他指向的值却是可以改变的，记住这个英文的注解就可以了。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>JavaScript基础</title>
    <url>/2021/06/10/Cesium/Cesiun%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="1-Cesium下载及安装"><a href="#1-Cesium下载及安装" class="headerlink" title="1. Cesium下载及安装"></a>1. Cesium下载及安装</h1><p>先会用到node和git两个软件.</p>
<p>在运行以下代码之前，先安装gulp.</p>
<p><a href="https://www.gulpjs.com.cn/">gulp</a></p>
<pre><code class="lang-bash">git clone https://github.com/CesiumGS/cesium.git    //源码下载
npm install    //安装cesium所需的一些依赖
npm run release    //会把所有的东西封装成一个文件
</code></pre>
<h1 id="2-cesiumWidget"><a href="#2-cesiumWidget" class="headerlink" title="2. cesiumWidget"></a>2. cesiumWidget</h1><p>CesiumWidget内部创建的对象主要有以下几个部分：</p>
<pre><code class="lang-mermaid">graph LR
A[Cesium]--&gt;B[cesiumWidget]
B--&gt;C[clock]
B--&gt;D[container]
B--&gt;E[canvas]
B--&gt;F[screenSpaceEvenHandler]
B--&gt;G[scene]
G--&gt;H[global]--&gt;I[_surface]
G--&gt;J[primitives]
G--&gt;K[groundPrimitives]
G--&gt;Y[环境对象]
Y--&gt;a[skyBox]
Y--&gt;b[skyAtmosphere]
Y--&gt;c[sun]
Y--&gt;d[sunBloom]
Y--&gt;e[moon]
Y--&gt;f[background]
</code></pre>
<p>clock用来记录时间，毕竟三维场景需要进行动态展示，需要通过时间来确定某一帧的绘制内容。container则是构造函数的参数，也就是传入的div。canvas则是在container上构建的Canvas的对象，可以据此获取WebGL绘制的比划。screenSpaceEventHandler则是对Canvas对象上各种鼠标的交互时间的封装，方便传递给三维场景。三维场景干之后可以据此改变相机姿态等。scene最重要，它承载着整个三维场景中的对象。</p>
<p>Scene中装载了所有的三维对象</p>
<p>Scene中有一些==内置==的图元对象：地球（Global）、skyBox（天空盒）、sun、moon等，另外还有两个用来由用户自行控制存放对象的数组：primitives和groundPrimitives, ==scene里本身是没有时间的概念的==</p>
<h1 id="3-cesium搭建发布环境"><a href="#3-cesium搭建发布环境" class="headerlink" title="3. cesium搭建发布环境"></a>3. cesium搭建发布环境</h1><p>先安装express</p>
<pre><code class="lang-bash">npm install express
</code></pre>
<p>创建server.js文件</p>
<pre><code class="lang-javascript">var http = require(&quot;http&quot;);
var express = require(&quot;express&quot;);
const path = require(&#39;path&#39;);

var app = express();
app.use(express.static(path.join(__dirname, &#39;&#39;)));

app.listen(4111, () =&gt; &#123;
  console.log(`http://localhost:4111`)
&#125;)
</code></pre>
]]></content>
      <categories>
        <category>Cesiun</category>
      </categories>
  </entry>
  <entry>
    <title>C++知识点</title>
    <url>/2021/06/21/C++/Visual%20Studio%E6%B7%BB%E5%8A%A0%E5%BA%93/</url>
    <content><![CDATA[<p>为了==识别dll文件==，需要将其文件目录位置放入系统变量里</p>
<p>项目属性-》VC++Directions里Include Directions里加入==库所在文件夹==以及==头文件所在文件夹== </p>
<p>项目属性-》VC++Directions里Library Directions里加入存放==lib文件夹目录==：</p>
<p>项目属性-》Linker-》Input里加入==lib文件的名称==：</p>
<p>lib和dll简介:</p>
<p>(1)lib是编译时需要的，dll是运行时需要的。<br>如果要完成源代码的编译，有lib就够了。<br>如果也使动态连接的程序运行起来，有dll就够了。<br>在开发和调试阶段，当然最好都有。<br>(2)一般的动态库程序有lib文件和dll文件。lib文件是必须在编译期就连接到应用程序中的，而dll文件是运行期才会被调用的。如果有dll文件，那么对应的lib文件一般是一些索引信息，具体的实现在dll文件中。如果只有lib文件，那么这个lib文件是静态编译出来的，索引和实现都在其中。静态编译的lib文件有好处：给用户安装时就不需要再挂动态库了。但也有缺点，就是导致应用程序比较大，而且失去了动态库的灵活性，在版本升级时，同时要发布新的应用程序才行。<br>(3)在动态库的情况下，有两个文件，一个是引入库（.LIB）文件，一个是dll文件，引入库文件包含被DLL导出的函数的名称和位置，DLL包含实际的函数和数据，应用程序使用LIB文件链接到所需要使用的DLL文件，库中的函数和数据并不复制到可执行文件中，因此在应用程序的可执行文件中，存放的不是被调用的函数代码，而是DLL中所要调用的函数的内存地址，这样当一个或多个应用程序运行是再把程序代码和被调用的函数代码链接起来，从而节省了内存资源。从上面的说明可以看出，DLL和.LIB文件必须随应用程序一起发行，否则应用程序将会产生错误。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>摄影测量</title>
    <url>/2021/06/29/C++/%E6%91%84%E5%BD%B1%E6%B5%8B%E9%87%8F/</url>
    <content><![CDATA[<h1 id="三方库"><a href="#三方库" class="headerlink" title="三方库"></a>三方库</h1><p>Eigen、Ceres Solver、opencv等</p>
<h1 id="main-cpp"><a href="#main-cpp" class="headerlink" title="main.cpp"></a>main.cpp</h1><pre><code class="lang-c++">#include &quot;image.h&quot;;
#include &quot;file_io.h&quot;
#include &quot;space_resection.h&quot;
#include &quot;feature_matching.h&quot;
#include &quot;image_orientation.h&quot;
#include &quot;forward_intersection.h&quot;

int main() &#123;
    /*Image img;
    vector&lt;Vector3d&gt; Pts;
    vector&lt;Vector2d&gt; pts;
    readImageInfoFromTxt(&quot;D:\\documents\\Photogrammetry\\task1\\Practice\\ImgInfo_example.txt&quot;, img, Pts, pts);
    img.print();

    SpaceResection resection;
    //resection.EulerAngleMethod(img, Pts, pts);
    resection.useCeres(img, Pts, pts);*/

    Image imgL;
    if (!imgL.readImgData(&quot;D:\\documents\\Photogrammetry\\task1\\images\\_MG_1813.JPG&quot;)) &#123;
        return 0;
    &#125;

    FeatureDetection fdetection;
    vector&lt;KeyPoint&gt; keypoints1;
    Mat description1;
    clock_t time0 = clock();

    //fdetection.Harris(imgL.mat_, keypoints1, description1, 2, 3, 0.05, 0.85);
    //fdetection.Sift(imgL.mat_, keypoints1, description1);
    fdetection.Surf(imgL.mat_, keypoints1, description1, 400);

    clock_t time1 = clock();
    cout &lt;&lt; &quot;Totally &quot; &lt;&lt; keypoints1.size() &lt;&lt; &quot; key points detected.\n&quot;;
    cout &lt;&lt; &quot;Feature detection takes time: &quot; &lt;&lt; (time1 - time0) / 1000.0 &lt;&lt; &quot; s.\n&quot;;

    fdetection.showFeature(imgL.mat_, keypoints1);
    cv::waitKey(0);

    /*Image imgR;
    if (!imgR.readImgData(&quot;D:\\documents\\Photogrammetry\\task1\\images\\_MG_1814.JPG&quot;)) &#123;
        return 0;
    &#125;

    IO io;
    io.focal_ = 51.6962;
    io.cx_ = 4312.66;
    io.cy_ = 2911.24;
    io.k1_ = -0.168583;
    io.k2_ = 0.316329;
    io.k3_ = 0.434715;
    io.p1_ = -0.00030953;
    io.p2_ = 0.000414809;
    imgL.io_ = imgR.io_ = io;
    imgL.pixel_size_ = imgR.pixel_size_ = 0.00414;
    FeatureDetection fdetection;
    vector&lt;KeyPoint&gt; keypoints1, keypoints2;
    Mat description1, description2;
    clock_t time_start = clock();

    fdetection.Surf(imgL.mat_, keypoints1, description1, 400);
    fdetection.Surf(imgR.mat_, keypoints2, description2, 400);

    FeatureMatching fmatching;
    vector&lt;DMatch&gt; matches;
    fmatching.FLANN_based(description1, description2, matches, 0.7);

    vector&lt;Vector2d&gt; pixelPtsL(matches.size()), pixelPtsR(matches.size());
    for (int i = 0; i &lt; matches.size(); i++) &#123;
        pixelPtsL[i] = Vector2d(keypoints1[matches[i].queryIdx].pt.x, keypoints1[matches[i].queryIdx].pt.y);
        pixelPtsR[i] = Vector2d(keypoints2[matches[i].trainIdx].pt.x, keypoints2[matches[i].trainIdx].pt.y);
    &#125;

    //相对定向
    RelativeOrientation ro;
    Mat rR;
    Vector3d rT;
    ro.cv(imgL, imgR, pixelPtsL, pixelPtsR, rR, rT);

    //用相对定向结果计算三维点坐标
    vector&lt;Point3d&gt; space_pts;
    Mat mask;
    Mat RcvL = (cv::Mat_&lt;double&gt;(3, 3) &lt;&lt; 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0);
    Mat TcvL = Mat::zeros(3, 1, CV_64FC1);
    Mat RcvR, TcvR;
    rR.copyTo(RcvR);
    TcvR = (cv::Mat_&lt;double&gt;(3, 1) &lt;&lt; rT.x(), rT.y(), rT.z());

    ForwardIntersection forIntersection;
    forIntersection.cv(imgL, imgR, RcvL, RcvR, TcvL, TcvR, pixelPtsL, pixelPtsR, space_pts, mask);

    string path = &quot;D:\\documents\\libraries\\3dviewer\\structure.yml&quot;;
    std::vector&lt;Mat&gt; Rs, Ts;
    Rs.push_back(RcvL);
    Rs.push_back(RcvR);
    Ts.push_back(TcvL);
    Ts.push_back(TcvR);
    save_structure(path, Rs, Ts, space_pts, mask);*/
&#125;
</code></pre>
<h1 id="file-io-h"><a href="#file-io-h" class="headerlink" title="file_io.h"></a>file_io.h</h1><pre><code class="lang-c++">#pragma once
#include &quot;image.h&quot;
#include &lt;fstream&gt;

int readImageInfoFromTxt(const string&amp; path, Image&amp; img, vector&lt;Vector3d&gt;&amp; Pts, vector&lt;Vector2d&gt;&amp; pts) &#123;
    ifstream infile(path, ios::in);
    if (!infile.is_open()) &#123;
        cout &lt;&lt; &quot;Lol,failed to open Txt!&quot;;
        return 0;
    &#125;

    while (!infile.eof()) &#123;
        string str;
        infile &gt;&gt; str;
        if (str == &quot;ImagePath&quot;) &#123;
            string img_path;
            infile &gt;&gt; img_path;
            img.path_ = img_path;
        &#125;
        else if (str == &quot;width&quot;)
            infile &gt;&gt; img.width_;
        else if (str == &quot;height&quot;)
            infile &gt;&gt; img.height_;
        else if (str == &quot;pixel_size&quot;)
            infile &gt;&gt; img.pixel_size_;
        else if (str == &quot;focal_length&quot;)
            infile &gt;&gt; img.io_.focal_;
        else if (str == &quot;principle_point&quot;)
            infile &gt;&gt; img.io_.cx_ &gt;&gt; img.io_.cy_;
        else if (str == &quot;distortions&quot;)
            infile &gt;&gt; img.io_.k1_ &gt;&gt; img.io_.k2_ &gt;&gt; img.io_.k3_ &gt;&gt; img.io_.p1_ &gt;&gt; img.io_.p2_;
        else if (str == &quot;Points&quot;) &#123;
            int num;
            infile &gt;&gt; num;
            Pts.resize(num);
            pts.resize(num);
            for (int i = 0; i &lt; num; i++)
                infile &gt;&gt; Pts[i].x() &gt;&gt; Pts[i].y() &gt;&gt; Pts[i].z() &gt;&gt; pts[i].x() &gt;&gt; pts[i].y();
            break;
        &#125;
    &#125;
    infile.close();
    return 1;
&#125;
</code></pre>
<h1 id="image-h"><a href="#image-h" class="headerlink" title="image.h"></a>image.h</h1><pre><code class="lang-c++">#pragma once
#include &lt;opencv2/core/core.hpp&gt;
#include &lt;opencv2/imgcodecs.hpp&gt;
#include &lt;opencv2/highgui.hpp&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;Eigen/Core&gt;
#include &lt;vector&gt;

using namespace Eigen;
using namespace cv;
using namespace std;

struct IO &#123;
    float focal_; //像主距
    float cx_; //像主点x,单位为像素
    float cy_; //像主点y，单位为像素
    float k1_;
    float k2_;
    float k3_;
    float p1_;
    float p2_;
&#125;;

struct EO &#123;
    MatrixXd R_;
    MatrixXd T_;
&#125;;

class Image &#123;
public:
    //无参构造函数
    Image() &#123;
        width_ = 0;
        height_ = 0;
        pixel_size_ = 0;
        io_.focal_ = 35;
        io_.cx_ = 0;
        io_.cy_ = 0;
        io_.k1_ = io_.k2_ = io_.k3_ = io_.p1_ = io_.p2_ = 0.0;
        eo_.R_ = MatrixXd::Ones(3, 3);
        eo_.T_ = MatrixXd::Ones(3, 1);
    &#125;
    //有参构造函数
    Image(const int&amp; width, const int&amp; height, const float&amp; pixel_size) &#123;
        width_ = width;
        height_ = height;
        pixel_size_ = pixel_size;
        io_.focal_ = 35;
        io_.cx_ = (width - 1) / 2;
        io_.cy_ = (height - 1) / 2;
        io_.k1_ = io_.k2_ = io_.k3_ = io_.p1_ = io_.p2_ = 0.0;
        eo_.R_ = MatrixXd::Ones(3, 3);
        eo_.T_ = MatrixXd::Ones(3, 1);
    &#125;

    //属性值
public:
    //影像文件路径
    string path_ = &quot;&quot;;

    //影像基本参数
    int width_;
    int height_;
    float pixel_size_; //单位为mm

    //内参
    IO io_;

    //外参
    EO eo_;

    Mat mat_;
public:
    void print() &#123;
        cout &lt;&lt; &quot;width: &quot; &lt;&lt; width_ &lt;&lt; endl
            &lt;&lt; &quot;height: &quot; &lt;&lt; height_ &lt;&lt; endl
            &lt;&lt; &quot;pixel size: &quot; &lt;&lt; pixel_size_ &lt;&lt; endl
            &lt;&lt; &quot;focal length: &quot; &lt;&lt; io_.focal_ &lt;&lt; endl
            &lt;&lt; &quot;principle point: &quot; &lt;&lt; io_.cx_ &lt;&lt; &quot;, &quot; &lt;&lt; io_.cy_ &lt;&lt; endl
            &lt;&lt; &quot;distortion params: &quot; &lt;&lt; io_.k1_ &lt;&lt; &quot; &quot; &lt;&lt; io_.k2_ &lt;&lt; &quot; &quot; &lt;&lt; io_.k3_ &lt;&lt; &quot; &quot; &lt;&lt; io_.p1_ &lt;&lt; &quot; &quot; &lt;&lt; io_.p2_ &lt;&lt; endl
            &lt;&lt; &quot;position: &quot; &lt;&lt; eo_.T_(0, 0) &lt;&lt; &quot; &quot; &lt;&lt; eo_.T_(1, 0) &lt;&lt; &quot; &quot; &lt;&lt; eo_.T_(2, 0) &lt;&lt; endl
            &lt;&lt; &quot;rotation: &quot; &lt;&lt; endl
            &lt;&lt; eo_.R_(0, 0) &lt;&lt; &quot; &quot; &lt;&lt; eo_.R_(0, 1) &lt;&lt; &quot; &quot; &lt;&lt; eo_.R_(0, 2) &lt;&lt; endl
            &lt;&lt; eo_.R_(1, 0) &lt;&lt; &quot; &quot; &lt;&lt; eo_.R_(1, 1) &lt;&lt; &quot; &quot; &lt;&lt; eo_.R_(1, 2) &lt;&lt; endl
            &lt;&lt; eo_.R_(2, 0) &lt;&lt; &quot; &quot; &lt;&lt; eo_.R_(2, 1) &lt;&lt; &quot; &quot; &lt;&lt; eo_.R_(2, 2) &lt;&lt; endl;
    &#125;
    //将像点由像素坐标转换为像平面坐标
    void pixelpoints2imagepoints(const vector&lt;Vector2d&gt;&amp; pixelPts, vector&lt;Vector2d&gt;&amp; imgPts);

    MatrixXd getRotationfromAngles(const double&amp; phi, const double&amp; omega, const double&amp; kappa);

    int readImgData(const string&amp; filepath) &#123;
        mat_ = imread(filepath); //读文件
        if (mat_.data == NULL) &#123;//测试影像是否打开
            cout &lt;&lt; &quot;Failed to read the image file.\n&quot;;
            return 0;
        &#125;
        path_ = filepath;
        width_ = mat_.cols;
        height_ = mat_.rows;
    &#125;

    void showImg() &#123;
        if (mat_.data == NULL) &#123;
            cout &lt;&lt; &quot;No image data.\n&quot;;
            return;
        &#125;
        Mat img_show;
        mat_.copyTo(img_show);
        namedWindow(path_, CV_WINDOW_NORMAL);
        resizeWindow(path_, 960, int(height_ * 960.0 / width_));
        moveWindow(path_, 100, 100);
        imshow(path_, img_show);
    &#125;

&#125;;

int save_structure(
    const string&amp; savepath,
    const std::vector&lt;Mat&gt;&amp; Rs,
    const std::vector&lt;Mat&gt;&amp; Ts,
    const std::vector&lt;Point3d&gt;&amp; points,
    const Mat&amp; mask
);
</code></pre>
<h1 id="image-cpp"><a href="#image-cpp" class="headerlink" title="image.cpp"></a>image.cpp</h1><pre><code class="lang-c++">#include &quot;image.h&quot;
#include &lt;vector&gt;

void Image::pixelpoints2imagepoints(const vector&lt;Vector2d&gt;&amp; pixelPts, vector&lt;Vector2d&gt;&amp; imgPts) &#123;
    double pix_size = pixel_size_ / 1000.0;
    imgPts.resize(pixelPts.size());
    for (int i = 0; i &lt; pixelPts.size(); i++) &#123;
        double u = pixelPts[i].x();
        double v = pixelPts[i].y();
        double x = (u - io_.cx_) * pix_size;
        double y = -(v - io_.cy_) * pix_size;
        double r2 = x * x + y * y;
        double r4 = r2 * r2;
        double r6 = r2 * r4;
        imgPts[i].x() = x + x * (io_.k1_ * r2 + io_.k2_ * r4 + io_.k3_ * r6) + io_.p1_ * (r2 + 2 * x * x) + 2 * io_.p2_ * x * y;
        imgPts[i].y() = y + y * (io_.k1_ * r2 + io_.k2_ * r4 + io_.k3_ * r6) + io_.p1_ * (r2 + 2 * y * y) + 2 * io_.p2_ * x * y;
    &#125;
&#125;

MatrixXd Image::getRotationfromAngles(const double&amp; phi, const double&amp; omega, const double&amp; kappa) &#123;
    eo_.R_(0, 0) = cos(phi) * cos(kappa) - sin(phi) * sin(omega) * sin(kappa);
    eo_.R_(0, 1) = -cos(phi) * sin(kappa) - sin(phi) * sin(omega) * cos(kappa);
    eo_.R_(0, 2) = -sin(phi) * cos(omega);
    eo_.R_(1, 0) = cos(omega) * sin(kappa);
    eo_.R_(1, 1) = cos(omega) * cos(kappa);
    eo_.R_(1, 2) = -sin(omega);
    eo_.R_(2, 0) = sin(phi) * cos(kappa) + cos(phi) * sin(omega) * sin(kappa);
    eo_.R_(2, 1) = -sin(phi) * sin(kappa) + cos(phi) * sin(omega) * cos(kappa);
    eo_.R_(2, 2) = cos(phi) * cos(omega);

    return eo_.R_;
&#125;

int save_structure(
    const string&amp; savepath,
    const std::vector&lt;Mat&gt;&amp; Rs,
    const std::vector&lt;Mat&gt;&amp; Ts,
    const std::vector&lt;Point3d&gt;&amp; points,
    const Mat&amp; mask
) &#123;
    int n = (int)Rs.size();

    FileStorage fs(savepath, FileStorage::WRITE);
    if (!fs.isOpened())
        return 0;

    fs &lt;&lt; &quot;Camera Count&quot; &lt;&lt; n;
    fs &lt;&lt; &quot;Point Count&quot; &lt;&lt; (int)points.size();

    fs &lt;&lt; &quot;Rotations&quot; &lt;&lt; &quot;[&quot;;
    for (size_t i = 0; i &lt; n; ++i) &#123;
        if (Rs[i].empty())
            fs &lt;&lt; cv::Mat::zeros(3, 3, CV_64FC1);
        else
            //fs &lt;&lt; Rs[i].inv();
            fs &lt;&lt; Rs[i];
    &#125;
    fs &lt;&lt; &quot;]&quot;;

    fs &lt;&lt; &quot;Motions&quot; &lt;&lt; &quot;[&quot;;
    for (size_t i = 0; i &lt; n; ++i)
    &#123;
        if (Ts[i].empty() || Rs[i].empty())
            fs &lt;&lt; cv::Mat::zeros(3, 1, CV_64FC1);
        else
            //fs &lt;&lt; -Rs[i].inv() * Ts[i];
            fs &lt;&lt; Ts[i];
    &#125;
    fs &lt;&lt; &quot;]&quot;;

    fs &lt;&lt; &quot;Points&quot; &lt;&lt; &quot;[&quot;;
    for (size_t i = 0; i &lt; points.size(); ++i)
    &#123;
        fs &lt;&lt; points[i];
    &#125;
    fs &lt;&lt; &quot;]&quot;;

    fs &lt;&lt; &quot;Colors&quot; &lt;&lt; &quot;[&quot;;
    for (size_t i = 0; i &lt; points.size(); ++i)
    &#123;
        if (mask.at&lt;uchar&gt;(i) &gt; 0)
            fs &lt;&lt; Vec3b(255, 255, 0);
        else
            fs &lt;&lt; Vec3b(0, 0, 255);
    &#125;
    fs &lt;&lt; &quot;]&quot;;

    fs.release();
    return 1;

&#125;
</code></pre>
<h1 id="space-resection-h"><a href="#space-resection-h" class="headerlink" title="space_resection.h"></a>space_resection.h</h1><pre><code class="lang-c++">#pragma once
#include &quot;image.h&quot;

class SpaceResection &#123;

public:
    int EulerAngleMethod(Image img, const vector&lt;Vector3d&gt;&amp; Pts, const vector&lt;Vector2d&gt;&amp; pts);

    int useCeres(Image&amp; img, const vector&lt;Vector3d&gt;&amp; Pts, const vector&lt;Vector2d&gt;&amp; pts);
&#125;;
</code></pre>
<h1 id="space-resection-cpp"><a href="#space-resection-cpp" class="headerlink" title="space_resection.cpp"></a>space_resection.cpp</h1><pre><code class="lang-c++">#include &quot;space_Resection.h&quot;
#include&lt;cmath&gt;
#include&lt;Eigen/LU&gt;
#include &lt;ceres/ceres.h&gt;
#include &lt;glog/logging.h&gt;

#ifdef max
#undef max
#endif //max

#ifdef min
#undef min
#endif //min

constexpr auto G_ERROR = 1e-3;        //平移坐标改正值阈值
constexpr auto A_ERROR = 1e-7;        //旋转角改正值阈值

static double f_ = 50;
struct EulerAngleBackCrossResidual
&#123;
    /*
    X,Y,Z,x,y分别为观测值
    */
    EulerAngleBackCrossResidual(double X, double Y, double Z, double x, double y)
        : X_(X), Y_(Y), Z_(Z), x_(x), y_(y) &#123;&#125;;

    template &lt;class T&gt;
    bool operator()(const T* const pBackCrossParameters, T* residual) const &#123;
        T dXs = pBackCrossParameters[0];
        T dYs = pBackCrossParameters[1];
        T dZs = pBackCrossParameters[2];
        T dPhi = pBackCrossParameters[3];
        T dOmega = pBackCrossParameters[4];
        T dKappa = pBackCrossParameters[5];

        T a1 = ceres::cos(dPhi) * ceres::cos(dKappa) - ceres::sin(dPhi) * ceres::sin(dOmega) * ceres::sin(dKappa);
        T a2 = -ceres::cos(dPhi) * ceres::sin(dKappa) - ceres::sin(dPhi) * ceres::sin(dOmega) * ceres::cos(dKappa);
        T a3 = -ceres::sin(dPhi) * ceres::cos(dOmega);
        T b1 = ceres::cos(dOmega) * ceres::sin(dKappa);
        T b2 = ceres::cos(dOmega) * ceres::cos(dKappa);
        T b3 = -ceres::sin(dOmega);
        T c1 = ceres::sin(dPhi) * ceres::cos(dKappa) + ceres::cos(dPhi) * ceres::sin(dOmega) * ceres::sin(dKappa);
        T c2 = -ceres::sin(dPhi) * ceres::sin(dKappa) + ceres::cos(dPhi) * ceres::sin(dOmega) * ceres::cos(dKappa);
        T c3 = ceres::cos(dPhi) * ceres::cos(dOmega);

        T XX = a1 * (X_ - dXs) + b1 * (Y_ - dYs) + c1 * (Z_ - dZs);
        T YY = a2 * (X_ - dXs) + b2 * (Y_ - dYs) + c2 * (Z_ - dZs);
        T ZZ = a3 * (X_ - dXs) + b3 * (Y_ - dYs) + c3 * (Z_ - dZs);

        //有两个残差
        residual[0] = T(x_) + T(f_) * XX / ZZ;
        residual[1] = T(y_) + T(f_) * YY / ZZ;

        return true;
    &#125;
private:
    const double X_;
    const double Y_;
    const double Z_;
    const double x_;
    const double y_;
&#125;;


int SpaceResection::EulerAngleMethod(Image img, const vector&lt;Vector3d&gt;&amp; Pts, const vector&lt;Vector2d&gt;&amp; pts) &#123;
    //计算外方位元素初始值
    int Num = max(3.0, pts.size() / 2.0);//用一般的点进行空间后方交会计算，另一半进行精度验证

    vector&lt;Vector2d&gt; imgPts;

    img.pixelpoints2imagepoints(pts, imgPts);

    double f = img.io_.focal_ / 1000.0;

    //估算摄影比例尺
    double GS = 0, SS = 0;
    for (int i = 0; i &lt; Num - 1; i++) &#123;
        GS += (Pts[i] - Pts[i + 1]).norm();
        SS += (imgPts[i] - imgPts[i + 1]).norm();
    &#125;
    double lfScale = GS / SS;

    //估算外方位元素初始值
    double Xs = 0, Ys = 0, Zs = 0, phi = 0, omega = 0, kappa = 0;
    for (int i = 0; i &lt; Num; i++) &#123;
        Xs += Pts[i].x();
        Ys += Pts[i].y();
        Zs += Pts[i].z();
    &#125;
    Xs /= Num;
    Ys /= Num;
    Zs /= Num;
    Zs += f * lfScale;

    double fSANGLE = atan2((imgPts[1] - imgPts[0]).y(), (imgPts[1] - imgPts[0]).x());
    double fGANGLE = atan2((Pts[1] - Pts[0]).y(), (Pts[1] - Pts[0]).x());
    kappa = fSANGLE - fGANGLE;


    MatrixXd B = MatrixXd(2 * Num, 6);
    MatrixXd L = MatrixXd(2 * Num, 1);
    MatrixXd Delta = MatrixXd::Ones(6, 1);
    int iterationNum = 0;
    do &#123;
        //误差方程
        MatrixXd R = img.getRotationfromAngles(phi, omega, kappa);
        for (int i = 0; i &lt; Num; i++) &#123;
            MatrixXd P = MatrixXd(3, 1);
            P(0, 0) = Pts[i].x() - Xs;
            P(1, 0) = Pts[i].y() - Ys;
            P(2, 0) = Pts[i].z() - Zs;
            MatrixXd PP = R.transpose() * P;
            double x = imgPts[i].x();
            double y = imgPts[i].y();

            //double x = -f * PP(0,0) / PP(2, 0)
            //double y = -f * PP(1, 0) / PP(2,0)

            double b11 = (R(0, 0) * f + R(0, 2) * x) / PP(2, 0);
            double b12 = (R(1, 0) * f + R(1, 2) * x) / PP(2, 0);
            double b13 = (R(2, 0) * f + R(2, 2) * x) / PP(2, 0);
            double b14 = y * sin(omega) - (x / f * (x * cos(kappa) - y * sin(kappa)) + f * cos(kappa)) * cos(omega);
            double b15 = -f * sin(kappa) - x / f * (x * sin(kappa) + y * cos(kappa));
            double b16 = y;

            double b21 = (R(0, 1) * f + R(0, 2) * y) / PP(2, 0);
            double b22 = (R(1, 1) * f + R(1, 2) * y) / PP(2, 0);
            double b23 = (R(2, 1) * f + R(2, 2) * y) / PP(2, 0);
            double b24 = -x * sin(omega) - (y / f * (x * cos(kappa) - y * sin(kappa)) - f * sin(kappa)) * cos(omega);
            double b25 = -f * cos(kappa) - y / f * (x * sin(kappa) + y * cos(kappa));
            double b26 = -x;

            double xx = -f * PP(0, 0) / PP(2, 0);
            double yy = -f * PP(1, 0) / PP(2, 0);

            B(i * 2 + 0, 0) = b11; B(i * 2 + 0, 1) = b12; B(i * 2 + 0, 2) = b13;
            B(i * 2 + 0, 3) = b14; B(i * 2 + 0, 4) = b15; B(i * 2 + 0, 5) = b16;
            B(i * 2 + 1, 0) = b21; B(i * 2 + 1, 1) = b22; B(i * 2 + 1, 2) = b23;
            B(i * 2 + 1, 3) = b24; B(i * 2 + 1, 4) = b25; B(i * 2 + 1, 5) = b26;
            L(i * 2 + 0, 0) = imgPts[i].x() - xx;
            L(i * 2 + 1, 0) = imgPts[i].y() - yy;
        &#125;
        cout &lt;&lt; &quot;********** iteration num:&quot; &lt;&lt; iterationNum &lt;&lt; &quot;*****************&quot; &lt;&lt; endl;
        cout &lt;&lt; &quot;B: &quot; &lt;&lt; endl &lt;&lt; B &lt;&lt; endl &lt;&lt; &quot;-----------------&quot; &lt;&lt; endl;
        cout &lt;&lt; &quot;L: &quot; &lt;&lt; endl &lt;&lt; L &lt;&lt; endl &lt;&lt; &quot;-----------------&quot; &lt;&lt; endl;
        MatrixXd BT = B.transpose();
        MatrixXd BTB = BT * B;
        MatrixXd BTBinv = BTB.inverse();
        Delta = BTBinv * (BT * L);

        cout &lt;&lt; &quot;Delta: &quot; &lt;&lt; endl &lt;&lt; Delta &lt;&lt; endl &lt;&lt; endl;

        //修正外方位元素
        Xs += Delta(0, 0);
        Ys += Delta(1, 0);
        Zs += Delta(2, 0);
        phi += Delta(3, 0);
        omega += Delta(4, 0);
        kappa += Delta(5, 0);

        iterationNum++;

    &#125; while ((fabs(Delta(0, 0)) &gt; G_ERROR || fabs(Delta(1, 0)) &gt; G_ERROR || fabs(Delta(2, 0)) &gt; G_ERROR ||
        fabs(Delta(3, 0)) &gt; A_ERROR || fabs(Delta(4, 0)) &gt; A_ERROR || fabs(Delta(5, 0)) &gt; A_ERROR)
        &amp;&amp; iterationNum &lt; 1000);

    //计算单位权中误差
    MatrixXd v = B * Delta - L;
    cout &lt;&lt; &quot;v: &quot; &lt;&lt; endl &lt;&lt; v &lt;&lt; endl &lt;&lt; &quot;--------------&quot; &lt;&lt; endl;
    MatrixXd s = v.transpose() * v;
    double m0 = sqrtf(s(0, 0) / (2 * Num - 6));
    cout &lt;&lt; &quot;--------------单位权中误差 m0= &quot; &lt;&lt; m0 &lt;&lt; &quot;--------------------&quot; &lt;&lt; endl;

    img.eo_.T_(0, 0) = Xs;
    img.eo_.T_(1, 0) = Ys;
    img.eo_.T_(2, 0) = Zs;

    //验证
    MatrixXd R = img.getRotationfromAngles(phi, omega, kappa);
    for (int i = 0; i &lt; Pts.size(); i++) &#123;
        double x = imgPts[i].x();
        double y = imgPts[i].y();
        MatrixXd P = MatrixXd(3, 1);
        P(0, 0) = Pts[i].x() - Xs;
        P(1, 0) = Pts[i].y() - Ys;
        P(2, 0) = Pts[i].z() - Zs;
        MatrixXd PP = R.transpose() * P;
        double xx = -f * PP(0, 0) / PP(2, 0);
        double yy = -f * PP(1, 0) / PP(2, 0);
        double du = (x - xx) / img.pixel_size_;
        double dv = (y - yy) / img.pixel_size_;

        if (i &gt;= Num)
            cout &lt;&lt; &quot;check points: --------------&quot; &lt;&lt; endl;
        cout &lt;&lt; &quot;point &quot; &lt;&lt; i &lt;&lt; &quot;: dx=&quot; &lt;&lt; du &lt;&lt; &quot;,  dy=&quot; &lt;&lt; dv &lt;&lt; &quot; error = &quot; &lt;&lt; sqrtf(du * du + dv * dv) &lt;&lt; &quot; pixels &quot;
            &lt;&lt; endl &lt;&lt; &quot;----------------&quot; &lt;&lt; endl;
    &#125;
    cout &lt;&lt; &quot;Position: &quot;;
    cout &lt;&lt; img.eo_.T_(0, 0) &lt;&lt; &quot;, &quot; &lt;&lt; img.eo_.T_(1, 0) &lt;&lt; &quot;, &quot; &lt;&lt; img.eo_.T_(2, 0) &lt;&lt; endl;
    cout &lt;&lt; &quot;Rotation: &quot; &lt;&lt; endl &lt;&lt; img.eo_.R_;
    return 1;
&#125;

int SpaceResection::useCeres(Image&amp; img, const vector&lt;Vector3d&gt;&amp; Pts, const vector&lt;Vector2d&gt;&amp; pts) &#123;
    //计算外方位元素初始值
    int Num = max(3.0, pts.size() / 2.0);//用一般的点进行空间后方交会计算，另一半进行精度验证

    vector&lt;Vector2d&gt; imgPts;

    img.pixelpoints2imagepoints(pts, imgPts);

    double f = img.io_.focal_ / 1000.0;

    //估算摄影比例尺 
    double GS = 0, SS = 0;
    for (int i = 0; i &lt; Num - 1; i++) &#123;
        GS += (Pts[i] - Pts[i + 1]).norm();
        SS += (imgPts[i] - imgPts[i + 1]).norm();
    &#125;
    double lfScale = GS / SS;

    //估算外方位元素初始值
    double Xs = 0, Ys = 0, Zs = 0, phi = 0, omega = 0, kappa = 0;
    for (int i = 0; i &lt; Num; i++) &#123;
        Xs += Pts[i].x();
        Ys += Pts[i].y();
        Zs += Pts[i].z();
    &#125;
    Xs /= Num;
    Ys /= Num;
    Zs /= Num;
    Zs += f * lfScale;

    double fSANGLE = atan2((imgPts[1] - imgPts[0]).y(), (imgPts[1] - imgPts[0]).x());
    double fGANGLE = atan2((Pts[1] - Pts[0]).y(), (Pts[1] - Pts[0]).x());
    kappa = fSANGLE - fGANGLE;


    MatrixXd B = MatrixXd(2 * Num, 6);
    MatrixXd L = MatrixXd(2 * Num, 1);
    MatrixXd Delta = MatrixXd::Ones(6, 1);

    //利用Ceres Solver计算外方位元素
    f_ = f;
    double dBackCrossParameters[6] = &#123; Xs, Ys, Zs, phi, omega, kappa &#125;;
    ceres::Problem problem;
    for (int i = 0; i &lt; Num; i++) &#123;
        EulerAngleBackCrossResidual* pResidual =
            new EulerAngleBackCrossResidual(Pts[i].x(), Pts[i].y(), Pts[i].z(), imgPts[i].x(), imgPts[i].y());
        problem.AddResidualBlock(
            new ceres::AutoDiffCostFunction&lt;EulerAngleBackCrossResidual, 2, 6&gt;(pResidual),
            NULL, dBackCrossParameters);
    &#125;

    ceres::Solver::Options m_options;
    ceres::Solver::Summary m_summary;
    m_options.max_num_iterations = 1000;
    m_options.linear_solver_type = ceres::DENSE_QR;
    m_options.minimizer_progress_to_stdout = true;

    ceres::Solve(m_options, &amp;problem, &amp;m_summary);

    cout &lt;&lt; &quot;-------------------------------&quot; &lt;&lt; endl;
    cout.precision(10);
    cout &lt;&lt; m_summary.BriefReport() &lt;&lt; &quot;\n&quot;;

    img.eo_.T_(0, 0) = dBackCrossParameters[0];
    img.eo_.T_(1, 0) = dBackCrossParameters[1];
    img.eo_.T_(2, 0) = dBackCrossParameters[2];

    //验证
    MatrixXd R = img.getRotationfromAngles(dBackCrossParameters[3], dBackCrossParameters[4], dBackCrossParameters[5]);
    for (int i = Num; i &lt; Pts.size(); i++) &#123;
        double x = imgPts[i].x();
        double y = imgPts[i].y();
        MatrixXd P = MatrixXd(3, 1);
        P(0, 0) = Pts[i].x() - Xs;
        P(1, 0) = Pts[i].y() - Ys;
        P(2, 0) = Pts[i].z() - Zs;
        MatrixXd PP = R.transpose() * P;
        double xx = -f * PP(0, 0) / PP(2, 0);
        double yy = -f * PP(1, 0) / PP(2, 0);
        double du = (x - xx) / img.pixel_size_;
        double dv = (y - yy) / img.pixel_size_;
        cout &lt;&lt; &quot;point &quot; &lt;&lt; i &lt;&lt; &quot;: dx=&quot; &lt;&lt; du &lt;&lt; &quot;,  dy=&quot; &lt;&lt; dv &lt;&lt; &quot; error = &quot; &lt;&lt; sqrtf(du * du + dv * dv) &lt;&lt; &quot; pixels &quot;
            &lt;&lt; endl &lt;&lt; &quot;----------------&quot; &lt;&lt; endl;

    &#125;

    cout &lt;&lt; &quot;Position: &quot;;
    cout &lt;&lt; img.eo_.T_(0, 0) &lt;&lt; &quot;, &quot; &lt;&lt; img.eo_.T_(1, 0) &lt;&lt; &quot;, &quot; &lt;&lt; img.eo_.T_(2, 0) &lt;&lt; endl;
    cout &lt;&lt; &quot;Rotation: &quot; &lt;&lt; endl &lt;&lt; img.eo_.R_;
    return 1;
&#125;
</code></pre>
<h1 id="feature-matching-h"><a href="#feature-matching-h" class="headerlink" title="feature_matching.h"></a>feature_matching.h</h1><pre><code class="lang-c++">#pragma once
#include &lt;opencv2/core.hpp&gt;

using namespace std;
using namespace cv;

class FeatureDetection &#123;
public:
    int Harris(
        const Mat&amp; img,                    //影像
        vector&lt;KeyPoint&gt;&amp; keypoints,    //影像上的特征点
        Mat&amp; description,                //特征点描述
        int blockSize = 2,                //Neighborhood size
        int apertureSize = 3,            //Aperture parameter for the Sobel operator
        double k = 0.04,                //Harris detector free parameter
        float thresh = 0.75                //threshold(0 ~ 1.0)
    );

    void showFeature(const Mat&amp; img, const vector&lt;KeyPoint&gt;&amp; keypoints);

    int Sift(
        const Mat&amp; img,                    //影像
        vector&lt;KeyPoint&gt;&amp; keypoints,    //影像上的特征点
        Mat&amp; description,                //特征点描述
        const int&amp; nfeatrues = 0,        //The number of best features to ratain
        const int&amp; nOctaveLayers = 3,    //The number of layers in each octave
        const double&amp; contrastThreshold = 0.04,    //The contrast threshold will be divided by
        const double&amp; edgeThreshold = 20,        //The threshold used to filter out edge-like features.
        const double&amp; sigma = 1.6                //The sigma if the Gaussian applied to the input image at the octave.
    );

    int Surf(
        const Mat&amp; img,                    //影像
        vector&lt;KeyPoint&gt;&amp; keypoints,    //影像上的特征点
        Mat&amp; description,                //特征点描述
        const double&amp; hessianThreshold = 100,    //Threshold for hessian keypoint detector used in Surf.
        const int&amp; nOctaves = 4,                //Number of pyramid octaves the keypoint detector will use.    
        const int&amp; nOctaveLayers = 3            //Number of octave layers within each octave.
    );
&#125;;

class FeatureMatching &#123;
public:
    int Brute_force(
        const Mat&amp; description1,        //特征点描述
        const Mat&amp; description2,        //特征点描述
        vector&lt;DMatch&gt;&amp; matched,        //匹配结果
        const float&amp; ratio_thresh = 0.7
    );

    void showMatches(
        const Mat&amp; img1,
        const vector&lt;KeyPoint&gt;&amp; keypoints1,
        const Mat&amp; img2,
        const vector&lt;KeyPoint&gt;&amp; keypoints2,
        const vector&lt;DMatch&gt;&amp; matches
    );

    int FLANN_based(
        const Mat&amp; description1,
        const Mat&amp; description2,
        vector&lt;DMatch&gt;&amp; matches,
        const float&amp; ratio_thresh = 0.7
    );
&#125;;
</code></pre>
<h1 id="feature-matching-cpp"><a href="#feature-matching-cpp" class="headerlink" title="feature_matching.cpp"></a>feature_matching.cpp</h1><pre><code class="lang-c++">#include &quot;feature_matching.h&quot;
#include &lt;opencv2/highgui.hpp&gt;
#include &lt;opencv2/imgproc.hpp&gt;
#include &lt;opencv2/features2d.hpp&gt;
#include &lt;opencv2/xfeatures2d.hpp&gt;

using namespace cv::xfeatures2d;

int FeatureDetection::Harris(
    const Mat&amp; img,
    vector&lt;KeyPoint&gt;&amp; keypoints,
    Mat&amp; description,
    int blockSize,
    int apertureSize,
    double k,
    float thresh) &#123;
    Mat img_gray;
    cvtColor(img, img_gray, COLOR_RGB2GRAY);

    //Corners 角点特征提取
    Mat dst, dst_norm;
    dst = Mat::zeros(img_gray.size(), CV_32FC1);
    cornerHarris(img_gray, dst, blockSize, apertureSize, k, BORDER_DEFAULT);

    //特征影像归一化处理
    normalize(dst, dst_norm, 0, 1.0, NORM_MINMAX, CV_32FC1, Mat());

    //提取特征点
    keypoints.resize(0);

    for (int j = 1; j &lt; dst_norm.rows - 1; j++) &#123;
        for (int i = 1; i &lt; dst_norm.cols - 1; i++) &#123;
            if (dst_norm.at&lt;float&gt;(j, i) &gt; thresh)
                keypoints.push_back(KeyPoint(i, j, 20.0));
        &#125;
    &#125;

    //将角点转换为特征描述
    //特征描述description为一个矩阵，其中矩阵的每一行对应一个Keypoints
    //每一行为一个9维的向量，向量1个值为当前特征点的灰度值，剩余8个值分别为向量像素点与当前特征点的灰度差
    description = Mat::zeros(keypoints.size(), 9, CV_32F);
    for (int i = 0; i &lt; keypoints.size(); i++) &#123;
        float v = img_gray.at&lt;uchar&gt;(keypoints[i].pt);
        description.at&lt;float&gt;(i, 0) = v;
        description.at&lt;float&gt;(i, 1) = img_gray.at&lt;uchar&gt;(keypoints[i].pt - Point2f(-1, -1)) - v;
        description.at&lt;float&gt;(i, 2) = img_gray.at&lt;uchar&gt;(keypoints[i].pt - Point2f(-1, 0)) - v;
        description.at&lt;float&gt;(i, 3) = img_gray.at&lt;uchar&gt;(keypoints[i].pt - Point2f(-1, 1)) - v;
        description.at&lt;float&gt;(i, 4) = img_gray.at&lt;uchar&gt;(keypoints[i].pt - Point2f(0, -1)) - v;
        description.at&lt;float&gt;(i, 5) = img_gray.at&lt;uchar&gt;(keypoints[i].pt - Point2f(0, 1)) - v;
        description.at&lt;float&gt;(i, 6) = img_gray.at&lt;uchar&gt;(keypoints[i].pt - Point2f(0, -1)) - v;
        description.at&lt;float&gt;(i, 7) = img_gray.at&lt;uchar&gt;(keypoints[i].pt - Point2f(0, 0)) - v;
        description.at&lt;float&gt;(i, 8) = img_gray.at&lt;uchar&gt;(keypoints[i].pt - Point2f(0, 1)) - v;
    &#125;

    return 1;
&#125;

void FeatureDetection::showFeature(const Mat&amp; img, const vector&lt;KeyPoint&gt;&amp; keypoints) &#123;
    Mat img_show;
    img.copyTo(img_show);
    if (img_show.channels() == 1) &#123;
        cvtColor(img_show, img_show, COLOR_GRAY2BGR);
    &#125;

    for (int i = 0; i &lt; keypoints.size(); i++) &#123;
        Point p = keypoints[i].pt;
        circle(img_show, p, keypoints[i].size, Scalar(0, 255, 0), 10, 8, 0);
    &#125;

    string win_str = &quot;Featured image&quot;;
    namedWindow(win_str, WINDOW_NORMAL);
    resizeWindow(win_str, 960, int(img_show.rows * 960.0 / img_show.cols));
    moveWindow(win_str, 100, 100);
    imshow(win_str, img_show);
&#125;

int FeatureDetection::Sift(
    const Mat&amp; img,
    vector&lt;KeyPoint&gt;&amp; keypoints,
    Mat&amp; description,
    const int&amp; nfeatrues, /* = 0, 保留的最佳特性的数量*/
    const int&amp; nOctaveLayers, /* = 3，高斯金字塔最小层级数，由图像自动计算出 */
    const double&amp; contrastThreshold, /* = 0.04， 对比阈值用于过滤区域中的弱特征。阈值越大，检测器产生的特征越少*/
    const double&amp; edgeThreshold, /* = 10, 用于过滤掉类似边缘特征的阈值，与对比阈值不同，即边缘阈值越大，滤出的特征越少*/
    const double&amp; sigma /* = 1.6， 高斯输入层级， 如果图像分辨率较低，则可能需要减少数值*/
) &#123;
    Mat img_gray;
    cvtColor(img, img_gray, COLOR_RGB2GRAY);

    Ptr&lt;SIFT&gt; detector = SIFT::create(nfeatrues, nOctaveLayers, contrastThreshold, edgeThreshold, sigma, CV_32F);
    detector-&gt;detectAndCompute(img_gray, Mat(), keypoints, description, false);

    return 1;
&#125;

int FeatureDetection::Surf(
    const Mat&amp; img,
    vector&lt;KeyPoint&gt;&amp; keypoints,
    Mat&amp; description,
    const double&amp; hessianThreshold,
    const int&amp; nOctaves,
    const int&amp; nOctaveLayers
) &#123;
    Mat img_gray;
    cvtColor(img, img_gray, COLOR_RGB2GRAY);

    Ptr&lt;SURF&gt; detector = SURF::create(hessianThreshold, nOctaves, nOctaveLayers);
    detector-&gt;detectAndCompute(img_gray, noArray(), keypoints, description);
    return 1;
&#125;

int FeatureMatching::Brute_force(
    const Mat&amp; description1,
    const Mat&amp; description2,
    vector&lt;DMatch&gt;&amp; matches,
    const float&amp; ratio_thresh
) &#123;
    vector&lt;vector&lt;DMatch&gt;&gt; all_matches;
    BFMatcher BF_matcher(NORM_L2);
    BF_matcher.knnMatch(description1, description2, all_matches, 2);

    float mindistance = FLT_MAX;
    for (int i = 0; i &lt; all_matches.size(); i++) &#123;
        if (all_matches[i][0].distance &gt; ratio_thresh * all_matches[i][1].distance) &#123;
            continue;
        &#125;

        float distance = all_matches[i][0].distance;
        if (distance &lt; mindistance) &#123;
            mindistance = distance;
        &#125;
    &#125;

    vector&lt;DMatch&gt; good_matches;
    for (int j = 0; j &lt; all_matches.size(); j++) &#123;
        if (all_matches[j][0].distance &gt; ratio_thresh * all_matches[j][1].distance ||
            all_matches[j][0].distance &gt; 5 * mindistance) &#123;
            continue;
        &#125;

        good_matches.push_back(all_matches[j][0]);
    &#125;
    matches = good_matches;
    return 1;
&#125;

void FeatureMatching::showMatches(
    const Mat&amp; img1,
    const vector&lt;KeyPoint&gt;&amp; keypoints1,
    const Mat&amp; img2,
    const vector&lt;KeyPoint&gt;&amp; keypoints2,
    const vector&lt;DMatch&gt;&amp; matches
) &#123;
    // Draw matches
    Mat img_matches;
    //原始图像尺寸太大，需要适当缩放
    Mat mat1, mat2;
    resize(img1, mat1, Size(), 0.15, 0.15);
    resize(img2, mat2, Size(), 0.15, 0.15);
    vector&lt;KeyPoint&gt; kpts1 = keypoints1;
    vector&lt;KeyPoint&gt; kpts2 = keypoints2;
    for (int i = 0; i &lt; kpts1.size(); i++) &#123;
        kpts1[i].pt *= 0.15;
    &#125;
    for (int i = 0; i &lt; kpts2.size(); i++) &#123;
        kpts2[i].pt *= 0.15;
    &#125;

    //生成绘制匹配结果的图像
    drawMatches(mat1, kpts1, mat2, kpts2, matches, img_matches, Scalar::all(-1),
        Scalar::all(-1), vector&lt;char&gt;(), DrawMatchesFlags::NOT_DRAW_SINGLE_POINTS);

    //Show detected matches
    string win_str = &quot;Matches&quot;;
    namedWindow(win_str, WINDOW_NORMAL);
    resizeWindow(win_str, img_matches.cols, img_matches.rows);
    imshow(&quot;Matches&quot;, img_matches);
&#125;

int FeatureMatching::FLANN_based(
    const Mat&amp; description1,
    const Mat&amp; description2,
    vector&lt;DMatch&gt;&amp; matches,
    const float&amp; ratio_thresh
) &#123;
    vector &lt;vector&lt;DMatch&gt;&gt; all_matches;
    Ptr&lt;DescriptorMatcher&gt; FB_matcher = DescriptorMatcher::create(DescriptorMatcher::FLANNBASED);
    FB_matcher-&gt;knnMatch(description1, description2, all_matches, 2);

    float mindistance = FLT_MAX;
    for (int i = 0; i &lt; all_matches.size(); i++) &#123;
        if (all_matches[i][0].distance &gt; ratio_thresh * all_matches[i][1].distance) &#123;
            continue;
        &#125;

        float distance = all_matches[i][0].distance;
        if (distance &lt; mindistance) &#123;
            mindistance = distance;
        &#125;
    &#125;

    vector&lt;DMatch&gt; good_matches;
    for (int j = 0; j &lt; all_matches.size(); j++) &#123;
        if (all_matches[j][0].distance &gt; ratio_thresh * all_matches[j][1].distance ||
            all_matches[j][0].distance &gt; 5 * mindistance) &#123;
            continue;
        &#125;

        good_matches.push_back(all_matches[j][0]);
    &#125;
    matches = good_matches;
    return 1;
&#125;
</code></pre>
<h1 id="image-orientation-h"><a href="#image-orientation-h" class="headerlink" title="image_orientation.h"></a>image_orientation.h</h1><pre><code class="lang-c++">#pragma once

#include &quot;image.h&quot;

class RelativeOrientation &#123;

public:
    int ContinuousMethod(
        const Image&amp; imgL,                    //左像
        const Image&amp; imgR,                    //右像
        const vector&lt;Vector2d&gt;&amp; pixelPtsL,    //左像上的特征点
        const vector&lt;Vector2d&gt;&amp; pixelPtsR,    //右像上的特征点
        Mat&amp; rR,                            //右像相对于左像的旋转矩阵
        Vector3d&amp; rT                        //右像相对于左像的平移参数
    );

    int IndependentMethod(
        const Image&amp; imgL,                    //左像
        const Image&amp; imgR,                    //右像
        const vector&lt;Vector2d&gt;&amp; pixelPtsL,    //左像上的特征点
        const vector&lt;Vector2d&gt;&amp; pixelPtsR,    //右像上的特征点
        Mat&amp; rR,                            //右像相对于左像的旋转矩阵
        Vector3d&amp; rT                        //右像相对于左像的平移参数
    );

    int cv(
        const Image&amp; imgL,
        const Image&amp; imgR,
        const vector&lt;Vector2d&gt;&amp; pixelPtsL,
        const vector&lt;Vector2d&gt;&amp; pixelPtsR,
        Mat&amp; rR,
        Vector3d&amp; rT
    );
&#125;;
</code></pre>
<h1 id="image-orientation-cpp"><a href="#image-orientation-cpp" class="headerlink" title="image_orientation.cpp"></a>image_orientation.cpp</h1><pre><code class="lang-c++">#include &quot;image_orientation.h&quot;
#include &lt;opencv2/calib3d.hpp&gt;

int RelativeOrientation::cv(
    const Image&amp; imgL,
    const Image&amp; imgR,
    const vector&lt;Vector2d&gt;&amp; pixelPtsL,
    const vector&lt;Vector2d&gt;&amp; pixelPtsR,
    Mat&amp; rR,
    Vector3d&amp; rT
) &#123;
    if (pixelPtsL.size() != pixelPtsR.size()) &#123;
        return 0;
    &#125;

    //假设左右影像为同一传感器拍摄的影像，即具有相同的内参
    double focal_length = imgL.io_.focal_ / imgL.pixel_size_;
    Point2d principle_point = Point2d(imgL.io_.cx_, imgL.io_.cy_);

    vector&lt;Point2d&gt; pts1(pixelPtsL.size()), pts2(pixelPtsR.size());
    for (int i = 0; i &lt; pixelPtsL.size(); i++) &#123;
        pts1[i] = Point2d(pixelPtsL[i].x(), pixelPtsL[i].y());
        pts2[i] = Point2d(pixelPtsR[i].x(), pixelPtsR[i].y());
    &#125;

    //计算本征矩阵
    Mat mask;
    Mat E = cv::findEssentialMat(pts1, pts2, focal_length, principle_point,
        RANSAC, 0.9999, 1.0, mask);
    if (E.empty()) &#123;
        return 0;
    &#125;

    double feasible_count = cv::countNonZero(mask);
    //对于RANSAC来说，outlier的数量大于50%时，结果是不可靠的
    if (feasible_count / pixelPtsL.size() &lt; 0.5) &#123;
        return 0;
    &#125;

    //分解本征矩阵，获取相对变换
    Mat R, t;
    int pass_count = cv::recoverPose(E, pts1, pts2, R, t, focal_length, principle_point, mask);
    //同时，位于两个相机前方的点数量要足够大
    if (((double)pass_count) / feasible_count &lt; 0.7) &#123;
        return 0;
    &#125;

    R.copyTo(rR);
    rT = Vector3d(t.at&lt;double&gt;(0, 0), t.at&lt;double&gt;(1, 0), t.at&lt;double&gt;(2, 0));

    //这里的rR和rT满足CV里的坐标转换关系，即
    //            | x2 |            | x1 |
    //            | y2 |    = R *    | y1 | + t
    //            | z2 |            | z1 |     
    return 1;
&#125;
</code></pre>
<h1 id="forword-intersection-h"><a href="#forword-intersection-h" class="headerlink" title="forword_intersection.h"></a>forword_intersection.h</h1><pre><code class="lang-c++">#pragma once

#include &quot;image.h&quot;

class ForwardIntersection
&#123;
public:
    ForwardIntersection() &#123;&#125;;
    ~ForwardIntersection() &#123;&#125;;

private:
    Mat_&lt;double&gt; LinearLSTriangulation(
        Point3d u,
        Matx34d P,
        Point3d u1,
        Matx34d P1)
    &#123;
        //build matrix A for homogenous equation system Ax = 0
        //assume X = (x,y,z,1), for Linear-LS method
        //which turns it into a AX = B system, where A is 4x3, X is 3x1 and B is 4x1
        Matx43d A(u.x * P(2, 0) - P(0, 0), u.x * P(2, 1) - P(0, 1), u.x * P(2, 2) - P(0, 2),
            u.y * P(2, 0) - P(1, 0), u.y * P(2, 1) - P(1, 1), u.y * P(2, 2) - P(1, 2),
            u1.x * P1(2, 0) - P1(0, 0), u1.x * P1(2, 1) - P1(0, 1), u1.x * P1(2, 2) - P1(0, 2),
            u1.y * P1(2, 0) - P1(1, 0), u1.y * P1(2, 1) - P1(1, 1), u1.y * P1(2, 2) - P1(1, 2)
        );
        Mat_&lt;double&gt; B = (Mat_&lt;double&gt;(4, 1) &lt;&lt; -(u.x * P(2, 3) - P(0, 3)),
            -(u.y * P(2, 3) - P(1, 3)),
            -(u1.x * P1(2, 3) - P1(0, 3)),
            -(u1.y * P1(2, 3) - P1(1, 3)));

        Mat_&lt;double&gt; X;
        solve(A, B, X, DECOMP_SVD);

        return X;
    &#125;

    Mat_&lt;double&gt; IterativeLinearLSTriangulation(
        Point3d u,
        Matx34d P,
        Point3d u1,
        Matx34d P1)
    &#123;

        double wi = 1, wi1 = 1;
        Mat_&lt;double&gt; X(4, 1);

        for (int i = 0; i &lt; 10; i++)
        &#123;
            //Hartley suggests 10 iterations at most
            Mat_&lt;double&gt; X_ = LinearLSTriangulation(u, P, u1, P1);
            X(0) = X_(0); X(1) = X_(1); X(2) = X_(2); X(3) = 1.0;

            //recalculate weights
            double p2x = Mat_&lt;double&gt;(Mat_&lt;double&gt;(P).row(2) * X)(0);
            double p2x1 = Mat_&lt;double&gt;(Mat_&lt;double&gt;(P1).row(2) * X)(0);

            //breaking point
            if (fabsf(wi - p2x) &lt;= 0.000001 &amp;&amp; fabsf(wi1 - p2x1) &lt;= 0.000001) break;

            wi = p2x;
            wi1 = p2x1;

            //reweight equations and solve
            Matx43d A((u.x * P(2, 0) - P(0, 0)) / wi, (u.x * P(2, 1) - P(0, 1)) / wi, (u.x * P(2, 2) - P(0, 2)) / wi,
                (u.y * P(2, 0) - P(1, 0)) / wi, (u.y * P(2, 1) - P(1, 1)) / wi, (u.y * P(2, 2) - P(1, 2)) / wi,
                (u1.x * P1(2, 0) - P1(0, 0)) / wi1, (u1.x * P1(2, 1) - P1(0, 1)) / wi1, (u1.x * P1(2, 2) - P1(0, 2)) / wi1,
                (u1.y * P1(2, 0) - P1(1, 0)) / wi1, (u1.y * P1(2, 1) - P1(1, 1)) / wi1, (u1.y * P1(2, 2) - P1(1, 2)) / wi1
            );
            Mat_&lt;double&gt; B = (Mat_&lt;double&gt;(4, 1) &lt;&lt; -(u.x * P(2, 3) - P(0, 3)) / wi,
                -(u.y * P(2, 3) - P(1, 3)) / wi,
                -(u1.x * P1(2, 3) - P1(0, 3)) / wi1,
                -(u1.y * P1(2, 3) - P1(1, 3)) / wi1
                );

            solve(A, B, X_, DECOMP_SVD);
            X(0) = X_(0); X(1) = X_(1); X(2) = X_(2); X(3) = 1.0;
        &#125;

        return X;
    &#125;
public:
    int cv(
        const Image&amp; imgL,
        const Image&amp; imgR,
        const Mat&amp; RcvL,
        const Mat&amp; RcvR,
        const Mat&amp; TcvL,
        const Mat&amp; TcvR,
        const vector&lt;Vector2d&gt;&amp; pixelPtsL,
        const vector&lt;Vector2d&gt;&amp; pixelPtsR,
        vector&lt;Point3d&gt;&amp; space_pts,
        Mat&amp; mask
    )
    &#123;
        Mat proj1(3, 4, CV_64FC1);
        Mat proj2(3, 4, CV_64FC1);
        double fx = imgL.io_.focal_ / imgL.pixel_size_;
        double fy = fx;
        double cx = imgL.io_.cx_;
        double cy = imgL.io_.cy_;
        Mat K = (cv::Mat_&lt;double&gt;(3, 3) &lt;&lt; fx, 0, cx, 0, fy, cy, 0, 0, 1);

        RcvL.convertTo(proj1(Range(0, 3), Range(0, 3)), CV_64FC1);
        proj1.at&lt;double&gt;(0, 3) = TcvL.at&lt;double&gt;(0);
        proj1.at&lt;double&gt;(1, 3) = TcvL.at&lt;double&gt;(1);
        proj1.at&lt;double&gt;(2, 3) = TcvL.at&lt;double&gt;(2);

        RcvR.convertTo(proj2(Range(0, 3), Range(0, 3)), CV_64FC1);
        proj2.at&lt;double&gt;(0, 3) = TcvR.at&lt;double&gt;(0);
        proj2.at&lt;double&gt;(1, 3) = TcvR.at&lt;double&gt;(1);
        proj2.at&lt;double&gt;(2, 3) = TcvR.at&lt;double&gt;(2);

        // triangulate points
        int pts_size = pixelPtsL.size();
        space_pts.resize(pixelPtsL.size());
        for (int i = 0; i &lt; pts_size; i++)
        &#123;
            Point2f kp = Point2f(pixelPtsL[i].x(), pixelPtsL[i].y());
            Point3d u1(kp.x, kp.y, 1.0);
            Mat_&lt;double&gt; um1 = K.inv() * Mat_&lt;double&gt;(u1);
            u1 = Point3d(um1.at&lt;double&gt;(0), um1.at&lt;double&gt;(1), um1.at&lt;double&gt;(2));
            Point2f kp1 = Point2f(pixelPtsR[i].x(), pixelPtsR[i].y());
            Point3d u2(kp1.x, kp1.y, 1.0);
            Mat_&lt;double&gt; um2 = K.inv() * Mat_&lt;double&gt;(u2);
            u2 = Point3d(um2.at&lt;double&gt;(0), um2.at&lt;double&gt;(1), um2.at&lt;double&gt;(2));

            Mat_&lt;double&gt; X = IterativeLinearLSTriangulation(u1, proj1, u2, proj2);
            space_pts[i] = Point3d(X(0), X(1), X(2));
        &#125;

        int fail_count = 0;
        mask = cv::Mat::ones(1, space_pts.size(), CV_8UC1);
        for (int i = 0; i &lt; space_pts.size(); i++)
        &#123;
            Mat P = (Mat_&lt;double&gt;(4, 1) &lt;&lt; space_pts[i].x, space_pts[i].y, space_pts[i].z, 1);
            Mat pix1 = K * proj1 * P;
            pix1 /= pix1.at&lt;double&gt;(2);

            Mat pix2 = K * proj2 * P;
            pix2 /= pix2.at&lt;double&gt;(2);

            double d1 = (pix1.at&lt;double&gt;(0) - pixelPtsL[i].x()) * (pix1.at&lt;double&gt;(0) - pixelPtsL[i].x()) + (pix1.at&lt;double&gt;(1) - pixelPtsL[i].y()) * (pix1.at&lt;double&gt;(1) - pixelPtsL[i].y());
            double d2 = (pix2.at&lt;double&gt;(0) - pixelPtsR[i].x()) * (pix2.at&lt;double&gt;(0) - pixelPtsR[i].x()) + (pix2.at&lt;double&gt;(1) - pixelPtsR[i].y()) * (pix2.at&lt;double&gt;(1) - pixelPtsR[i].y());

            if (d1 &gt; 2 || d2 &gt; 2) //若反投影到影像上与像点的距离大于2个像素，则判断为失配点
            &#123;
                mask.at&lt;uchar&gt;(i) = 0;
                fail_count++;
            &#125;
        &#125;
        if (fail_count &gt; space_pts.size() * 0.8) //80%以上都失败 返回0
            return 0;

        return 1;
    &#125;
&#125;;
</code></pre>
]]></content>
      <categories>
        <category>摄影测量</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/2021/07/12/Java%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="1-单例模式"><a href="#1-单例模式" class="headerlink" title="1.单例模式"></a>1.单例模式</h1><p>饿汉式：</p>
<pre><code class="lang-java">package com.zzy.singel;

public class Single01 &#123;
    public static void main(String[] args) &#123;
//        通过方法可以直接获取对象
        GirlFriend instance01 = GirlFriend.getInstance();
        System.out.println(instance01);
    &#125;
&#125;

class GirlFriend &#123;
    private String name;
//为了能够在静态方法中，返回gf对象，需要将其设置为static
    private  static GirlFriend gf = new GirlFriend(&quot;小红&quot;);
//    设计模式--&gt;单例模式[饿汉式]
//    如何只new一个girlfriend
//    1.将构造器私有化
//    2.在类的内部直接创建
//    3.提供一个公共的static方法，返回gf对象
//    这种对象一般都是重量级的对象，饿汉式可能造成资源浪费
    private GirlFriend(String name) &#123;
        this.name = name;
    &#125;

    public static GirlFriend getInstance() &#123;
        return gf;
    &#125;

    @Override
    public String toString() &#123;
        return &quot;GirlFriend&#123;&quot; +
                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +
                &#39;&#125;&#39;;
    &#125;
&#125;
</code></pre>
<p>饱汉式：</p>
<pre><code class="lang-java">package com.zzy.singel;

public class single02 &#123;
    public static void main(String[] args) &#123;
        Cat cat = Cat.getInstance();
        System.out.println(cat);
    &#125;
&#125;

//希望在程序运行中，只能创建一个Cat对象
//饱汉式的方法在调用类的属性的时候，不会创建对象，只有调用instance的时候才会创建对象
class Cat &#123;
    private String name;
//  1.仍然将构造器私有化
//  2.定义一个static静态属性对象
//  3.提供一个public的static方法，可以返回一个Cat对象
    private Cat(String name) &#123;
        this.name = name;
    &#125;

    private static Cat cat;

    public static Cat getInstance() &#123;
        if (cat == null) &#123;
            cat = new Cat(&quot;小白&quot;);
        &#125;
        return cat;
    &#125;

    @Override
    public String toString() &#123;
        return &quot;Cat&#123;&quot; +
                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +
                &#39;&#125;&#39;;
    &#125;
&#125;
</code></pre>
<p>饿汉式VS饱汉式</p>
<p>1.二者最重要的区别在于创建对象的时机不同：饿汉式是在类加载的时候就创建了对象实例，而懒汉式是在使用时才创建。</p>
<p>2.饿汉式不存在线程安全问题，懒汉式存在线程安全问题。</p>
<p>3.饿汉式存在浪费资源的可能。如果程序员没有使用对象实例，那么饿汉式就会造成资源浪费，懒汉式是使用时才创建，不会存在这个问题。</p>
<p>4.在javaSE标准类中，java.lang.Runtime就是经典的单例模式。</p>
<h1 id="2-模板设计模式"><a href="#2-模板设计模式" class="headerlink" title="2.模板设计模式"></a>2.模板设计模式</h1><pre><code class="lang-java">package com.zzy.abstract_;

public class TestTemplate &#123;
    public static void main(String[] args) &#123;
        AA aa = new AA();
        aa.calculateTime();
        BB bb = new BB();
        bb.calculateTime();
    &#125;
&#125;
</code></pre>
<p>父类</p>
<pre><code class="lang-java">package com.zzy.abstract_;

abstract public class Template &#123;//抽象类-模板设计模式
    public abstract void job();

    public void calculateTime() &#123;
        long start = System.currentTimeMillis();
        job();//动态绑定机制
        long end = System.currentTimeMillis();
        System.out.println(&quot;执行时间 &quot; + (end - start));
    &#125;
&#125;
</code></pre>
<p>子类AA</p>
<pre><code class="lang-java">package com.zzy.abstract_;

public class AA extends Template &#123;
    @Override
    public void job() &#123;//实现了父类的抽象方法
        int num = 0;
        for (int i = 0; i &lt; 800000; i++) &#123;
            num += i;
        &#125;
    &#125;
&#125;
</code></pre>
<p>子类BB</p>
<pre><code class="lang-java">package com.zzy.abstract_;

public class BB extends Template &#123;
    @Override
    public void job() &#123;//这个类也重写了父类的方法
        int num = 0;
        for (int i = 1; i &lt; 80000 ; i++) &#123;
            num *= i;
        &#125;
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Java知识点</title>
    <url>/2021/07/13/Java%E5%9F%BA%E7%A1%80/Java%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<h1 id="Java面向对象"><a href="#Java面向对象" class="headerlink" title="Java面向对象"></a>Java面向对象</h1><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口就是制定规范，给出一些没有实现的方法，封装到一起，到某个类要使用的时候，在根据具体情况把这些方法写出来。</p>
<p>在JDK8.0以后，接口可以有静态方法，默认方法。</p>
<p>但是在默认方法前面必须加default关键字</p>
<p>接口细节：</p>
<p>1.接口不可以被实例化</p>
<p>2.接口中的所有方法是public方法，接口中抽象方法，可以不用abstract修饰</p>
<p>3.一个普通类实现接口，就必须将该接口的所有方法都实现</p>
<p>4.抽象类去实现接口时，可以不实现接口的抽象方法</p>
<p>5.一个类同时可以实现多个接口</p>
<p>6.接口中的==属性==，只能是final的，而且是public static final修饰的，如int a =1;实际上是 public static final int a =1;</p>
<p>7.接口不能继承其他的类，但是可以继承多个别的接口</p>
<p>8.接口的修饰符，只能是public和默认，这点和类的修饰符是一样的</p>
<p>接口和类的比较</p>
<p>接口可以理解为是Java对单继承机制的补充</p>
<p>一个先天，一个后天</p>
<pre><code class="lang-java">package com.zzy.interface_;

public class Interface02 &#123;
    public static void main(String[] args) &#123;
        LittleMonkey littleMonkey = new LittleMonkey(&quot;小悟空&quot;);
        littleMonkey.climbing();
        littleMonkey.swimming();
        littleMonkey.flying();
    &#125;
&#125;

class Money &#123;
    private String name;

    public Money(String name) &#123;
        this.name = name;
    &#125;

    public String getName() &#123;
        return name;
    &#125;

    public void climbing() &#123;
        System.out.println( name + &quot;会爬树...&quot;);
    &#125;
&#125;

interface Fishable &#123;
    void swimming();
&#125;

interface Birdable &#123;
    void flying();
&#125;
//继承父类
class LittleMonkey extends Money implements Fishable, Birdable&#123;
    public LittleMonkey(String name) &#123;
        super(name);
    &#125;

    @Override
    public void swimming() &#123;
        System.out.println(getName() + &quot;通过学习，学会了游泳...&quot;);
    &#125;

    @Override
    public void flying() &#123;
        System.out.println(getName() + &quot;通过学习，学会了飞行...&quot;);
    &#125;
&#125;
</code></pre>
<p>接口的动态绑定机制案例</p>
<pre><code class="lang-java">package com.zzy.interface_;

public class InterfaceExercise &#123;
    public static void main(String[] args) &#123;
        Usb_[] usb = new Usb_[2];
        usb[0] = new Iphone_();
        usb[1] = new Camera_();
        for (int i = 0; i &lt; usb.length; i++) &#123;
            if (usb[i] instanceof Iphone_) &#123;
                ((Iphone_) usb[i]).call();
            &#125;
            usb[i].work();
        &#125;
    &#125;
&#125;

interface Usb_ &#123;
    void work();
&#125;

class Iphone_ implements Usb_ &#123;
    @Override
    public void work() &#123;
        System.out.println(&quot;手机开始工作...&quot;);
    &#125;

    public void call() &#123;
        System.out.println(&quot;手机可以打电话...&quot;);
    &#125;
&#125;

class Camera_ implements Usb_ &#123;
    @Override
    public void work() &#123;
        System.out.println(&quot;相机开始工作&quot;);
    &#125;
&#125;
</code></pre>
<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>内部类最大的特点就是可以直接访问私有属性，并且可以体现类与类之间的包含关系</p>
<p>内部类的分类，有4种。</p>
<p>定义在外部类局部位置上（比如方法内）：</p>
<p>1.局部内部类（有类名）</p>
<p>2.匿名内部类（没有类名，重点）</p>
<p>定义在外部类的成员位置上：</p>
<p>1.成员内部类</p>
<p>2.静态内部类</p>
<h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><pre><code class="lang-java">package com.zzy.InnerClass;

public class LocalInnerClass &#123;
    public static void main(String[] args) &#123;
        //演示
        Outer02 outer02 = new Outer02();
        outer02.m1();
        System.out.println(&quot;Outer02的hashcode&quot; + outer02);
    &#125;
&#125;

class Outer02 &#123;
    private int n1 = 100;
    public void m2()&#123;
        System.out.println(&quot;m2()...&quot;);
    &#125;;
    public void m1() &#123;
        //局部内部类是定义在外部类的局部位置，通常在方法
        //不能添加访问修饰符，但是可以使用final修饰，因为局部变量也可以使用final修饰
        //作用域：仅仅在定义它的方法或代码块中
        final class Inner02 &#123;//局部内部类
            //可以直接访问外部类的所有成员，包含私有的
            private int n1 = 800;
            public void f1() &#123;
                //局部内部类可以直接访问外部类的成员
                //如果外部类和局部内部类重名时，默认遵循就近原则，如果想访问外部类的成员
                // 则可以使用外部类名.this.成员
                //这里的Outer02.this就可以理解为对象，谁调用了这个方法，他就代表那个对象
                System.out.println(&quot;n1 = &quot; + n1 + &quot; 外部类的n1 = &quot; + Outer02.this.n1);
                //证明一下这个Outer02.this的地址
                System.out.println(&quot;Outer02.this hashcode = &quot; + Outer02.this);
                m2();
            &#125;
        &#125;

        //外部类在方法中，可以创建Inner02对象，然后调用方法调用
        Inner02 inner02 = new Inner02();
        inner02.f1();
    &#125;
&#125;
</code></pre>
<h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>本质还是类，还是定义在内部的，它是匿名的，系统会给他分配名字，它同时还是一个对象</p>
<pre><code class="lang-java">package com.zzy.InnerClass;

public class AnonymousInnerClass &#123;
    public static void main(String[] args) &#123;
        //1.接口的匿名内部类
        //原因：当只调用对象一次时，进行接口实现，若存在多个，则会造成多个对象创建，浪费资源
        //因此需要用匿名内部类进行简化。
        //编译类型看左边：A     运行类型其实是匿名内部类,为外部类$1(系统分配)
        //jdk底层在创建匿名内部类时，立马就创建了其实例，并把地址返回给 tiger
        //匿名内部类使用一次，就不能再使用
        A tiger = new A() &#123;
            @Override
            public void cry() &#123;
                System.out.println(&quot;老虎在叫唤...&quot;);
            &#125;
        &#125;;
        //输出其运行类型采用getclass()方法
        System.out.println(&quot;tiger的运行类型为&quot; + tiger.getClass());
        tiger.cry();


        //2.基于类的匿名内部类
        //编译类型：Father，运行类型是匿名内部类
        //同时也返回了匿名内部类的对象
        //这里的Jack会传给father的构造器
        Father father = new Father(&quot;Jack&quot;) &#123;
            @Override
            public void test() &#123;
                System.out.println(&quot;匿名内部类重写了test方法...&quot;);
            &#125;
        &#125;;
        System.out.println(&quot;father对象的运行类型为 &quot; + father.getClass());
        father.test();
    &#125;
&#125;

class Outer03 &#123;
    private int n1 =10;

    public void method() &#123;
    &#125;

&#125;

interface A &#123;
    //基于接口的匿名内部类
    public void cry();
&#125;

class Father &#123;
    //基于类的匿名内部类
    public Father(String name) &#123;

    &#125;

    public void test() &#123;

    &#125;
&#125;
</code></pre>
<p>匿名内部类的两种创建方法及细节</p>
<pre><code class="lang-java">package com.zzy.InnerClass;

public class AnonymousInnerClass01 &#123;
    public static void main(String[] args) &#123;
        Outer04 outer04 = new Outer04();
        outer04.f1();
        System.out.println(&quot;外部的hashcode = &quot; + outer04);
    &#125;
&#125;

class Outer04 &#123;
    private int n1 =99;
    public void f1() &#123;
        //创建一个基于类的匿名内部类
        //第一种调用方法
        //不能添加访问修饰符，因为它的地位就是一个局部变量
        //作用域：仅仅是在方法或者代码块中
        Person p = new Person() &#123;
            private int n1 =88;
            @Override
            public void hi() &#123;
                //可以直接访问外部类的所有成员，包含私有的
                //如果外部类和匿名内部类的成员重名时，匿名内部类访问的话，
                //默认遵循就近原则，如果想访问外部类的成员，则可以使用(外部类名.this.成员)去访问
                System.out.println(&quot;匿名内部类重写了hi()方法...&quot;);
                System.out.println(&quot;n1 = &quot; + n1);//访问内部的n1
                System.out.println(&quot;外部n1 = &quot; + Outer04.this.n1);
                System.out.println(&quot;内部的hashcode = &quot; + Outer04.this);
            &#125;
        &#125;;
        p.hi();//动态绑定机制

        //第二种调用方法
        new Person() &#123;
            @Override
            public void hi() &#123;
                System.out.println(&quot;匿名内部类重写了hi()方法,第二种...&quot;);
            &#125;
        &#125;.hi();

        new Person() &#123;
            @Override
            public void ok(String name) &#123;
                System.out.println(&quot;重写了&quot; + name);
            &#125;
        &#125;.ok(&quot;Jack&quot;);
    &#125;
&#125;

class Person &#123;
    public void hi() &#123;
        System.out.println(&quot;Person hi()&quot;);
    &#125;

    public void ok(String name) &#123;
        System.out.println(&quot;Person ok() &quot; + name);
    &#125;
&#125;
</code></pre>
<p>匿名内部类的实践</p>
<pre><code class="lang-java">package com.zzy.InnerClass;

public class InnerClassExercise02 &#123;
    public static void main(String[] args) &#123;
        CellPhone cellPhone = new CellPhone();
        cellPhone.alarmClock(new Bell() &#123;
            @Override
            public void ring() &#123;
                System.out.println(&quot;懒猪起床了...&quot;);
            &#125;
        &#125;);
        //在这里，编译类型是匿名内部类，重写了ring方法
        cellPhone.alarmClock(new Bell() &#123;
            @Override
            public void ring() &#123;
                System.out.println(&quot;小伙伴上课了...&quot;);
            &#125;
        &#125;);
    &#125;
&#125;

interface Bell &#123;
    public void ring();
&#125;

class CellPhone &#123;
    public void alarmClock(Bell bell) &#123;
        System.out.println(bell.getClass());
        bell.ring();//动态绑定机制
    &#125;
&#125;
</code></pre>
<h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><p>成员内部类是定义在外部类的成员位置，并且没有static修饰</p>
<pre><code class="lang-java">package com.zzy.InnerClass;

import java.util.PrimitiveIterator;

public class MemberInnerClass01 &#123;
    public static void main(String[] args) &#123;
        Outer05 outer05 = new Outer05();
        outer05.m1();

        //外部其他类，使用成员内部类的三种方法
        //第一种方法
        Outer05.Inner05 inner05 = outer05.new Inner05();
        inner05.say();

        //第二种方式，在外部类中，编写一个方法，可以返回Inner08对象
        Outer05.Inner05 inner05instance = outer05.getInner05Instance();
        inner05instance.say();

        //第三种方式
        Outer05.Inner05 inner05_ = new Outer05().new Inner05();
        inner05_.say();
    &#125;
&#125;

class Outer05 &#123;
    private int n1 = 10;
    public String name = &quot;张三&quot;;
    //可以添加任意访问修饰符(public、protected、默认、private),因为它的地位就是一个成员
    //作用域：和外部类的其他成员一样，为整个类体
    public class Inner05 &#123;//成员内部类
        private int n1 =66;
        private String name = &quot;李四&quot;;
        public void say() &#123;
            //可以直接访问外部类的所有成员，包含私有的
            //如果成员内部类的成员和外部类的成员重名,会遵守就近原则。
            System.out.println(&quot;成员内部类的n1 = &quot; + n1 + &quot; 成员内部类类的name = &quot; + name);
            System.out.println(&quot;外部类n1=&quot; + Outer05.this.n1 + &quot; 外部类的name=&quot; + Outer05.this.name);
        &#125;
    &#125;
    //方法，返回一个Inner05的实例
    public Inner05 getInner05Instance() &#123;
        return new Inner05();
    &#125;
    //调用成员内部类
    public void m1() &#123;
        Inner05 inner05 = new Inner05();
        inner05.say();
    &#125;
&#125;
</code></pre>
<h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><pre><code class="lang-java">package com.zzy.InnerClass;

public class StaticInnerClass01 &#123;
    public static void main(String[] args) &#123;
        Outer6 outer6 = new Outer6();
        outer6.m1();

        //外部其他类使用静态内部类
        //方式1
        //因为静态内部类，是可以通过类名直接访问
        Outer6.Inner6 inner6 = new Outer6.Inner6();
        inner6.say();

        //方式2，编写一个普通方法，可以返回静态内部类的对象实例
        Outer6.Inner6 inner6_ = outer6.getInner6();
        inner6_.say();

        //方式3，编写一个静态方法
        Outer6.Inner6 inner6_1 = Outer6.getInner6_();
        inner6_1.say();
    &#125;
&#125;

class Outer6 &#123;
    private int n1 =10;
    private static String name = &quot;张三&quot;;
    //静态内部类
    //放在外部类的成员位置，有static修饰
    //可以添加任意的修饰符，因为它的地位就是一个成员
    //作用域：整个类体
    static class Inner6 &#123;
        private static String name = &quot;zzy学java&quot;;
        public void say() &#123;
            //可以直接访问外部类的所有静态成员，包含私有的，但不能访问非静态成员
            //如果成员内部类的成员和外部类的成员重名,会遵守就近原则。但访问外部类不用加this了
            System.out.println(name);
            System.out.println(Outer6.name);
        &#125;
    &#125;

    public Inner6 getInner6() &#123;
        return new Inner6();
    &#125;

    public static Inner6 getInner6_() &#123;
        return new Inner6();
    &#125;
    //外部内调用
    public void m1() &#123;
        Inner6 inner6 = new Inner6();
        inner6.say();
    &#125;
&#125;
</code></pre>
<h2 id="枚举和注解"><a href="#枚举和注解" class="headerlink" title="枚举和注解"></a>枚举和注解</h2><p>自定义实现枚举</p>
<p>1.构造器私有化</p>
<p>2.本类内部创建一组对象</p>
<p>3.对外暴露对象（添加public final static修饰符）</p>
<p>4.可以提供get方法，但是不要提供set方法。</p>
<pre><code class="lang-java">package com.zzy.enum_;

/**
 * @autho: 周钟炎
 * @version: 1.0
 */
public class Enum02 &#123;
    public static void main(String[] args) &#123;
        System.out.println(Season_.AUTUMN);
    &#125;
&#125;

//自定义枚举实现
class Season_ &#123;
    private String name;
    private String desc;

    //1.将构造器私有化
    //2.去掉set方法
    //3.在Season内部，直接创建固定的对象

    //定义了四个对象
    public final static Season_ SPRING = new Season_(&quot;春天&quot;, &quot;温暖&quot;);
    public final static Season_ SUMMER = new Season_(&quot;夏天&quot;, &quot;炎热&quot;);
    public final static Season_ AUTUMN = new Season_(&quot;秋天&quot;, &quot;凉爽&quot;);
    public final static Season_ WINTER = new Season_(&quot;冬天&quot;, &quot;寒冷&quot;);
    private Season_(String name, String desc) &#123;
        this.name = name;
        this.desc = desc;
    &#125;

    public String getName() &#123;
        return name;
    &#125;

    public String getDesc() &#123;
        return desc;
    &#125;

    @Override
    public String toString() &#123;
        return &quot;Season_&#123;&quot; +
                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +
                &quot;, desc=&#39;&quot; + desc + &#39;\&#39;&#39; +
                &#39;&#125;&#39;;
    &#125;
&#125;
</code></pre>
<p>关键字实现枚举</p>
<p>主要是对类的创建做了简化。</p>
<pre><code class="lang-java">package com.zzy.enum_;

/**
 * @autho: 周钟炎
 * @version: 1.0
 */
public class Enum03 &#123;
    public static void main(String[] args) &#123;
        System.out.println(Season1.SPRING);
    &#125;
&#125;
//关键字实现枚举
enum Season1 &#123;
    //使用关键字来实现enum
    //1.使用关键字enum替代class
    //2.按照下面的写法，如果有多个常量，使用,间隔即可
    //3.如果使用enum来实现枚举，要求将定义常量对象写在最前面
    SPRING(&quot;春天&quot;, &quot;温暖&quot;),
    SUMMER(&quot;夏天&quot;, &quot;炎热&quot;);
    private String name;
    private String desc;
    private Season1(String name, String desc) &#123;
        this.name = name;
        this.desc = desc;
    &#125;

    public String getName() &#123;
        return name;
    &#125;

    public String getDesc() &#123;
        return desc;
    &#125;

    @Override
    public String toString() &#123;
        return &quot;Season_&#123;&quot; +
                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +
                &quot;, desc=&#39;&quot; + desc + &#39;\&#39;&#39; +
                &#39;&#125;&#39;;
    &#125;
&#125;
</code></pre>
<p>==Javap可以将编译的class文件反编译，从而看到一些重要的信息。==</p>
<p>枚举练习</p>
<pre><code class="lang-java">package com.zzy.enum_;

/**
 * @autho: 周钟炎
 * @version: 1.0
 */
public class EnumExercise &#123;
    public static void main(String[] args) &#123;
        Gender boy = Gender.BOY;
        Gender bou2 = Gender.BOY;
        //所有的enum类都继承了Enum类，它的toString方法返回的是名字
        System.out.println(boy);
        System.out.println(boy == bou2);
    &#125;
&#125;

enum Gender&#123;
    BOY,GIRL;
&#125;
</code></pre>
<p>枚举方法的使用:</p>
<pre><code class="lang-java">package com.zzy.enum_;

/**
 * @autho: 周钟炎
 * @version: 1.0
 */
public class EnumMethod &#123;
    //演示Enum类的各种方法的使用
    public static void main(String[] args) &#123;
        Season1 spring = Season1.SPRING;
        //输入枚举变量的名字
        System.out.println(spring.name());
        //输出的是该枚举对象的次序，从0开始编号
        System.out.println(spring.ordinal());
        //从反编译可以看出，values方法,返回Season1[],含有定义的所有枚举对象
        Season1[] values = Season1.values();

        for(Season1 i : values) &#123;//简洁的写法
            System.out.println(&quot;i = &quot; + i);
        &#125;

        //valueof：将字符串转换成枚举对象，要求字符串必须为已有的常量名，否则报异常
        //1.根据你输入的&quot;SUMMER&quot;到Season1的枚举对象去查找
        //2.如果找到了，就返回，如果没找到，就报错
        Season1 summer = Season1.valueOf(&quot;SUMMER&quot;);
        System.out.println(&quot;autumn = &quot; + summer);

        //compareTO:比较两个枚举常量，比较的就是编号
        //self.ordinal - other.ordinal
        System.out.println(Season1.SPRING.compareTo(Season1.SUMMER));
    &#125;
&#125;
</code></pre>
<p>枚举练习</p>
<pre><code class="lang-java">package com.zzy.enum_;

/**
 * @autho: 周钟炎
 * @version: 1.0
 */
public class EnumExercise01 &#123;
    public static void main(String[] args) &#123;
        Week[] values = Week.values();
        System.out.println(&quot;所有输出的信息如下：&quot;);
        for (Week i : values) &#123;
            System.out.println(i);
        &#125;
    &#125;
&#125;


enum Week &#123;
    MONDAY(&quot;星期一&quot;),
    TUESDAY(&quot;星期二&quot;),
    WEDNESDAY(&quot;星期三&quot;),
    THURSDAY(&quot;星期四&quot;),
    FRIDAY(&quot;星期五&quot;),
    SATURDAY(&quot;星期六&quot;),
    SUNDAY(&quot;星期日&quot;);
    private String week;
    private Week(String week) &#123;
        this.week = week;
    &#125;

    @Override
    public String toString() &#123;
        return week;
    &#125;
&#125;
</code></pre>
<p>enum细节：</p>
<p>1.使用enum关键词后，就不能再继承其他类了，因为enum会隐式的继承Enum，而Java是单继承机制。</p>
<p>2.枚举类和普通类一样，可以实现接口。</p>
<p>Target是修饰注解的注解，称为元注解。</p>
<p>@Deprecated修饰某个元素，表示该元素已经过时了，即不推荐使用，但是仍然可以使用。</p>
<p>当们不希望看到这些警告的时候，可以使用SuppressWarnings注解来抑制警告信息</p>
<p>元注解：</p>
<p>1.Retention，指定注解的作用范围</p>
<p>2.Target，指定注解可以在哪些地方使用</p>
<p>3.Documented，指定该注解是否会在javadoc体现</p>
<p>4.Inherited，子类会继承父类注解</p>
<p>枚举搭配switch使用：</p>
<pre><code class="lang-java">package com.zzy.annotation;

/**
 * @autho: 周钟炎
 * @version: 1.0
 */
public class Homework07 &#123;
    public static void main(String[] args) &#123;
        Color green = Color.GREEN;
        green.show();

        switch (green) &#123;
            case YELLOW:
                System.out.println(&quot;匹配到黄色...&quot;);
                break;
            case RED:
                System.out.println(&quot;匹配到红色...&quot;);
                break;
            case BLACK:
                System.out.println(&quot;匹配到黑色...&quot;);
                break;
            case BLUE:
                System.out.println(&quot;匹配到蓝色...&quot;);
                break;
            case GREEN:
                System.out.println(&quot;匹配到绿色...&quot;);
                break;
            default:
                System.out.println(&quot;没有匹配到...&quot;);
        &#125;
    &#125;
&#125;

enum Color implements IColor&#123;
    RED(255,0,0),
    BLUE(0,0,255),
    BLACK(0,0,0),
    YELLOW(255,255,0),
    GREEN(0,255,0);
    private int redValue;
    private int greenValue;
    private int blueValue;

    Color(int redValue, int greenValue, int blueValue) &#123;
        this.redValue = redValue;
        this.greenValue = greenValue;
        this.blueValue = blueValue;
    &#125;

    @Override
    public void show() &#123;
        System.out.println(&quot;redValue = &quot; + redValue);
        System.out.println(&quot;redValue = &quot; + greenValue);
        System.out.println(&quot;redValue = &quot; + blueValue);
    &#125;
&#125;

interface IColor &#123;
    abstract void show();
&#125;
</code></pre>
<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><pre><code class="lang-java">//如果程序员，认为一段代码可能出现异常，可以使用try-catch异常处理机制来解决
//从而保证程序的健壮性
//如果进行了异常处理，那么即使出现了异常，程序也可以继续执行
</code></pre>
<p>执行过程中所发生的异常事件可分为两大类</p>
<p>1.Error（错误）：Java虚拟机无法解决的严重问题。如：JVM系统内部错误、资源耗尽等严重情况。</p>
<p>2.Exception:其他因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理。Exception又分为两大类：运行时异常【程序运行时，发生的异常】和编译时异常【编程时，编译器检查出的异常】。</p>
<p>常见的运行时异常：</p>
<p>1.NullPointerException 空指针异常</p>
<p>2.ArithmeticException 数学运算异常</p>
<p>3.ArrayIndexOutOfBoundsException 数组下标越界异常</p>
<p>4.ClassCastException 类型转换异常</p>
<p>5.NumberFormatException 数字格式不正确异常</p>
<h2 id="try-catch异常处理"><a href="#try-catch异常处理" class="headerlink" title="try-catch异常处理"></a>try-catch异常处理</h2><pre><code class="lang-java">package com.zzy.exception_;

/**
 * @autho: 周钟炎
 * @version: 1.0
 */
public class Exception02 &#123;
    public static void main(String[] args) &#123;
        try &#123;//碰到异常以后会跳过后面的代码，直接执行catch块
            //如果异常没有发生，则顺序执行try的代码块，不会进入到catch
            //如果想不管是否发生异常，都执行以下代码，可以用finally
            String str = &quot;zzy学Java&quot;;
            int a = Integer.parseInt(str);
            System.out.println(&quot;数字：&quot; + a);
        &#125; catch (NumberFormatException e) &#123;
            System.out.println(&quot;异常信息 = &quot; + e.getMessage());
        &#125;finally &#123;
            System.out.println(&quot;finally代码块被执行&quot;);
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="lang-java">package com.zzy.exception_;

/**
 * @autho: 周钟炎
 * @version: 1.0
 */
public class Exception03 &#123;
    public static void main(String[] args) &#123;
        //可以使用多个catch分别捕获不同的异常，相应处理
        //但是要求子类异常写在前面，父类异常写在后面
        try &#123;
            Person person = new Person();
            person = null;
            System.out.println(person.name);
            int n1 = 10;
            int n2 = 0;
            int res = n1 / n2;
        &#125; catch (NullPointerException e) &#123;
            System.out.println(&quot;异常信息是：&quot; + e.getMessage());
        &#125;catch (ArithmeticException e) &#123;
            System.out.println(&quot;异常信息是：&quot; + e.getMessage());
        &#125;
        catch (Exception e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
        &#125;
    &#125;
&#125;

class Person &#123;
    public String name = &quot;jack&quot;;

    public String getName() &#123;
        return name;
    &#125;
&#125;
</code></pre>
<p>可以使用try-finally配合使用，这种用法相当于没有捕获异常，因为程序会崩溃。应用场景一般是执行一段代码，不管是否发生异常，都必须执行某个业务逻辑。</p>
<p>异常处理练习题：</p>
<pre><code class="lang-java">package com.zzy.exception_;

/**
 * @autho: 周钟炎
 * @version: 1.0
 */
public class ExceptionExercise &#123;
    public static int method() &#123;
        int i = 1;
        try &#123;
            i++;
            String[] names = new String[3];
            if (names[1].equals(&quot;tom&quot;)) &#123;
                System.out.println(names[1]);
            &#125;else &#123;
                names[3] = &quot;hspedu&quot;;
            &#125;
            return 1;
        &#125;catch (ArrayIndexOutOfBoundsException e) &#123;
            return 2;
        &#125;catch (NullPointerException e) &#123;
            return ++i; //这里的i会被传给临时变量，最后再返回这个临时变量
        &#125;finally &#123;
            ++i;
            System.out.println(&quot;i = &quot; + i);
        &#125;
    &#125;

    public static void main(String[] args) &#123;
        System.out.println(method());
    &#125;
&#125;
</code></pre>
<p>利用异常控制输入：</p>
<pre><code class="lang-java">package com.zzy.exception_;

import java.util.Scanner;

/**
 * @autho: 周钟炎
 * @version: 1.0
 */
public class ExceptionExercise01 &#123;
    public static void main(String[] args) &#123;
        Scanner scanner = new Scanner(System.in);
        int num = 0;
        while (true) &#123;
            System.out.println(&quot;请输入一个整数：&quot;);
            try &#123;
                num = Integer.parseInt(scanner.next());
                break;
            &#125; catch (NumberFormatException e) &#123;
                System.out.println(&quot;你输入的不是一个整数...&quot;);
            &#125;
        &#125;
        System.out.println(&quot;你输入的值：&quot; + num);
    &#125;
&#125;
</code></pre>
<h2 id="throws异常处理"><a href="#throws异常处理" class="headerlink" title="throws异常处理"></a>throws异常处理</h2><p>1.如果一个方法可能生成某种异常，但是并不能确定如何处理这种异常，则该方法应显示地声明抛出异常，表明该方法将不对这些异常进行处理，而由该方法的调用者负责处理。</p>
<p>2.在方法声明中用throws语句可以声明抛出异常的列表，throws后面的异常类型可以是方法中产生的异常，也可以是它的父类</p>
<p>细节：</p>
<p>==子类重写父类的方法时，对抛出异常的规定：子类重写的方法，所抛出的异常类型要么和父类一样，要么为父类抛出的异常类型的子类==</p>
<h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><pre><code class="lang-java">package com.zzy.throws_;

/**
 * @autho: 周钟炎
 * @version: 1.0
 */
public class CustomException &#123;
    public static void main(String[] args) &#123;
        int age = 180;
        if (!(age &gt;= 18 &amp;&amp; age &lt;= 120)) &#123;
            //这里可以沟通构造器设置它的信息
            throw new AgeException(&quot;年龄需要在18-120岁之间...&quot;);
        &#125;

        System.out.println(&quot;你的年龄范围正确...&quot;);
    &#125;
&#125;

//一般都继承运行时异常，不然是编译时异常，还需要对它进行处理，程序才能跑起来
class AgeException extends RuntimeException &#123;
    public AgeException(String message) &#123;//构造器
        super(message);
    &#125;
&#125;
</code></pre>
<p>throw和throws的区别</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>意义</th>
<th>位置</th>
<th>后面跟的东西</th>
</tr>
</thead>
<tbody>
<tr>
<td>throws</td>
<td>异常的一种处理方式</td>
<td>方法声明处</td>
<td>异常类型</td>
</tr>
<tr>
<td>throw</td>
<td>自定义异常的关键字</td>
<td>方法体中</td>
<td>异常对象</td>
</tr>
</tbody>
</table>
</div>
<p>异常案例：</p>
<p>==finally输出在throw之前==</p>
<pre><code class="lang-java">package com.zzy.throws_;

/**
 * @autho: 周钟炎
 * @version: 1.0
 */
public class ExceptionExercise &#123;
    public static void main(String[] args) &#123;
        try &#123;
            ReturnExceptionDemo.methodA();
        &#125;catch (Exception e) &#123;
            System.out.println(e.getMessage());
        &#125;

        ReturnExceptionDemo.methodB();
    &#125;
&#125;

class ReturnExceptionDemo &#123;
    static void methodA() &#123;
        try &#123;
            System.out.println(&quot;进入方法A...&quot;);
            //先输出finally里的内容，再throw
            throw new RuntimeException(&quot;制造异常...&quot;);
        &#125; finally &#123;
            System.out.println(&quot;用A方法的finally...&quot;);
        &#125;
    &#125;

    static void methodB() &#123;
        try &#123;
            System.out.println(&quot;进入方法B...&quot;);
            return;
        &#125;finally &#123;
            System.out.println(&quot;调用B方法的finally...&quot;);
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="lang-java">package com.zzy.throws_;

import java.util.Scanner;

/**
 * @autho: 周钟炎
 * @version: 1.0
 */
public class Homework01 &#123;
    public static void main(String[] args) &#123;
        try &#123;
            Scanner scanner = new Scanner(System.in);
            System.out.println(&quot;输入第一个数：&quot;);
            //可能有输入异常
            int num1 = Integer.parseInt(scanner.next());
            System.out.println(&quot;输入第二个数：&quot;);
            int num2 = Integer.parseInt(scanner.next());
            //可能有算数异常
            int res = cal(num1, num2);
            System.out.println(&quot;输出的结果为：&quot; + res);
        &#125; catch (NumberFormatException e) &#123;
            System.out.println(&quot;请输入整数...&quot;);
        &#125; catch (ArithmeticException e) &#123;
            System.out.println(&quot;分母不能为0...&quot;);
        &#125;
    &#125;

    public static int cal(int n1, int n2) &#123;
        return n1 / n2;
    &#125;
&#125;
</code></pre>
<h1 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h1><h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><p>针对8种基本定义相应的引用类型-包装类</p>
<p>boolean、char这两的父类是Object，byte、short、int、long、float、double的父类是Number</p>
<p><a href="https://blog.csdn.net/qq_44707077/article/details/116030063">深入浅出Java包装类_TD230的博客-CSDN博客</a></p>
<h2 id="包装类和-基本数据的转换"><a href="#包装类和-基本数据的转换" class="headerlink" title="包装类和 基本数据的转换"></a>包装类和 基本数据的转换</h2><p>装箱和拆箱</p>
<pre><code class="lang-java">package com.zzy.wrapper;

/**
 * @autho: 周钟炎
 * @version: 1.0
 */
public class Integer01 &#123;
    public static void main(String[] args) &#123;
        //int-&gt;Integer的装箱和拆箱
        //jdk5前是手动装箱和拆箱
        int n1 = 100;
        Integer integer = Integer.valueOf(n1);
        //手动拆箱
        int i = integer.intValue();

        //jdk5后，就可以自动装箱和自动拆箱
        int n2 = 200;
        Integer integer2 = n2; //底层使用的是仍然是 Integer.valueOf(n2)
        //自动拆箱
        int n3 = integer2; //底层使用的仍然是 int n3 = integer.intValue()
    &#125;
&#125;
</code></pre>
<p>==三元运算符是一个整体==</p>
<pre><code class="lang-java">package com.zzy.wrapper;

/**
 * @autho: 周钟炎
 * @version: 1.0
 */
public class Exercise01 &#123;
    public static void main(String[] args) &#123;
        Object obj1 = true ? new Integer(1) : new Double(2.0);
        //这里结果是1.0，三元运算符是一个整体，要先提升优先级
        System.out.println(obj1);
    &#125;
&#125;
</code></pre>
<p>包装类和String的转换</p>
<pre><code class="lang-java">package com.zzy.wrapper;

/**
 * @autho: 周钟炎
 * @version: 1.0
 */
public class WrapperVsString &#123;
    public static void main(String[] args) &#123;
        //包装类(Integer)装成String
        Integer i1 = 100; //自动装箱
        //方式1
        String str1 = i1 + &quot;&quot;; //这里只是值传递

        //方式二
        String str2 = i1.toString();

        //方式三
        String str3 = String.valueOf(i1);

        //把String转成包装类
        int i2 = Integer.parseInt(str4); //这里换成Integer可以用到自动装箱
        Integer i3 = new Integer(str4);
        Integer i4 = Integer.valueOf(str4);
    &#125;
&#125;
</code></pre>
<p>练习：</p>
<pre><code class="lang-java">package com.zzy.wrapper;

/**
 * @autho: 周钟炎
 * @version: 1.0
 */
public class Exercise02 &#123;
    public static void main(String[] args) &#123;
        Integer i = new Integer(1);
        Integer j = new Integer(1);
        System.out.println(i == j);

        //主要看valueOf的源码
        Integer m = 1;
        Integer n = 1;
        System.out.println(m == n);

        Integer x = 128;
        Integer y = 128;
        System.out.println( x == y);
    &#125;
&#125;
</code></pre>
<h2 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h2><pre><code class="lang-java">package com.zzy.string_;

/**
 * @autho: 周钟炎
 * @version: 1.0
 */
public class String01 &#123;
    public static void main(String[] args) &#123;
        String name = &quot;zzy&quot;;

        //创建String对象的两种方式
        //方式1,直接创建
        //方式一先从常量池查看是否有&quot;zzy&quot;数据空间，如果有，直接指向；如果没有则重新创建，然后指向
        //最终指向的是常量池的空间地址
        String s = &quot;zzy&quot;;

        //方式2，调用构造器
        //先在堆中创建空间，里面维护了value属性，指向常量池的zzy空间，如果常量池没有&quot;zzy&quot;，重新创建，
        //如果有，直接通过value指向。最终的是堆中的空间地址
        String s1 = new String(&quot;zzy&quot;);

        String a = &quot;abc&quot;;
        String b = new String(&quot;abc&quot;);
        System.out.println(a.equals(b)); //T
        System.out.println(a == b); //F
        //intern方法就是到常量池去找这个b对象，如果有，直接返回常量池的地址，
        // 没有就在常量池创建一个在返回
        System.out.println(a == b.intern()); //T
        System.out.println(b == b.intern()); //F

        //这里在常量池里创建了两个对象
        String str1 = &quot;abc&quot;;
        str1 = &quot;bcd&quot;;

        //这里在常量池创建了一个对象，底层会对其进行优化
        String str2 = &quot;hello&quot; + &quot;abc&quot;;


        String str3 = &quot;zzy&quot;;
        String str4 = &quot;java&quot;;
        //下面两条语句有着明细的区别，str5是先在池中创建一个StringBuilder对象，然后append添加进去
        // 最后将拼接起来的字符串返回给堆区，堆区再指向str5，所以返回的是堆中的地址
        //str6是直接拼接，返回的是池中的地址
        String str5 = str3 + str4;
        String str6 = &quot;zzy&quot; + &quot;java&quot;;
        System.out.println(str5 == str6); //F
    &#125;
&#125;
</code></pre>
<p>案例</p>
<pre><code class="lang-java">package com.zzy.string_;

/**
 * @autho: 周钟炎
 * @version: 1.0
 */
public class String02 &#123;
    public static void main(String[] args) &#123;
        Test01 ex = new Test01();
        //这个changes方法会在栈上重新开辟一块区域，运行完就销毁了
        ex.changes(ex.str, ex.ch);
        System.out.println(ex.str + &quot;and&quot;); //hspand
        System.out.println(ex.ch); //hava
    &#125;
&#125;

class Test01 &#123;
    String str = new String(&quot;hsp&quot;);
    final char[] ch = &#123;&#39;j&#39;, &#39;a&#39;, &#39;v&#39;, &#39;a&#39;&#125;;
    public void changes(String str, char ch[]) &#123;
        str = &quot;java&quot;;
        ch[0] = &#39;h&#39;;
    &#125;
&#125;
</code></pre>
<p>String类的常用方法</p>
<p>String类是保存字符串常量的，每次更新都需要重新开辟空间，效率较低，因此Java设计者还提供了StringBuilder和StringBuffer来增强String的功能，并提高效率</p>
<pre><code class="lang-java">package com.zzy.string_;

/**
 * @autho: 周钟炎
 * @version: 1.0
 */
public class StringMethod &#123;
    public static void main(String[] args) &#123;
        String str = &quot;春眠不觉晓，处处闻啼鸟，夜来风雨声，花落知多少&quot;;
        String[] str1 = str.split(&quot;，&quot;);
        for (String i : str1) &#123;
            System.out.println(i);
        &#125;

        //在分割时，碰见特殊字符，则需要进行转义
        String str2 = &quot;E:\\aaa\\bbb&quot;;
        String[] str3 = str2.split(&quot;\\\\&quot;);
        for (String i : str3) &#123;
            System.out.println(i);
        &#125;

        //字符串转成字符数组
        String str4 = &quot;happy&quot;;
        char[] chars =  str4.toCharArray();
        for (char i : chars) &#123;
            System.out.println(i);
        &#125;

        //format可以定义String的输出格式
        String name = &quot;Han Shun Ping&quot;;
        String[] s = str.split(&quot; &quot;);
         String format = String.format(&quot; %s,%s ,%c&quot;, s[2], s[0], s[1].charAt(0));
        System.out.println(format);
    &#125;
&#125;
</code></pre>
<p>StringBuffer类</p>
<p>StringBuffer代表可变的字符序列，可以对字符串内容进行增删。</p>
<pre><code class="lang-java">package com.zzy.stringbuffer_;

/**
 * @autho: 周钟炎
 * @version: 1.0
 */
public class StringBuffer01 &#123;
    public static void main(String[] args) &#123;
        //在父类中 AbstractStringBuilder有属性byte[]，不是final修饰的
        //因此它是存放在堆中，不是存放在常量池
        //StringBuffer是一个final类，不能被继承
        //因为StringBuffer字符内容是存在byte[] value里的 ，因此每次变化内容不用都更换地址，
        // 除非是内存不够了，效率高于String
        StringBuffer stringBuffer = new StringBuffer(&quot;hello&quot;);

    &#125;
&#125;
</code></pre>
<p>StringBuffer的几种构造器</p>
<pre><code class="lang-java">package com.zzy.stringbuffer_;

/**
 * @autho: 周钟炎
 * @version: 1.0
 */
public class StringBuffer02 &#123;
    public static void main(String[] args) &#123;
        //1.创建一个默认为16大小的char[]，用于存放字符内容
        StringBuffer stringBuffer1 = new StringBuffer();

        //2.通过构造器指定char[]大小
        StringBuffer stringBuffer2 = new StringBuffer(100);

        //3.通过给一个String创建StringBuffer
        StringBuffer stringBuffer3 = new StringBuffer(&quot;zzy&quot;);
    &#125;
&#125;
</code></pre>
<p>String与StringBuffer的转换</p>
<pre><code class="lang-java">package com.zzy.stringbuffer_;

/**
 * @autho: 周钟炎
 * @version: 1.0
 */
public class StringAndStringBuffer &#123;
    public static void main(String[] args) &#123;
        //String-&gt;StringBuffer
        String str = &quot;hello&quot;;
        //方式1，使用构造器,但是这里只是stringbuffer做了改变
        StringBuffer stringBuffer = new StringBuffer(str);

        //方式2，先创建一个空的，在用append去增加
        StringBuffer stringBuffer1 = new StringBuffer();
        stringBuffer1.append(str);

        //StringBuffer-&gt;String
        StringBuffer stringBuffer2 = new StringBuffer(&quot;zzy&quot;);
        //方式1，使用StringBuffer提供的toString方法
        String str1 = stringBuffer2.toString();
        //方式2，使用String提供的构造器
        String s = new String(stringBuffer2);
    &#125;
&#125;
</code></pre>
<p>StringBuffer的增删改查</p>
<p>1.增 append 2.删 delete 3.改 replace 4. indexOf 5. 插 insert 6. 获取长度 length</p>
<pre><code class="lang-java">package com.zzy.stringbuffer_;

/**
 * @autho: 周钟炎
 * @version: 1.0
 */
public class StringBuferMethod &#123;
    public static void main(String[] args) &#123;
        StringBuffer stringBuffer = new StringBuffer(&quot;hello&quot;);
        //尾插
        stringBuffer.append(&quot;,&quot;);
        stringBuffer.append(&quot;张三丰&quot;);
        stringBuffer.append(&quot;张无忌&quot;).append(100).append(true).append(10.5);
        System.out.println(stringBuffer);

        //删除
        stringBuffer.delete(12, 15);
        System.out.println(stringBuffer);//前闭后开

        //修改
        stringBuffer.replace(9,12,&quot;周芷若&quot;);
        System.out.println(stringBuffer);

        //查找
        int num = stringBuffer.indexOf(&quot;张三丰&quot;);
        System.out.println(num);

        //插入,在索引为9的位置插入，原来索引为9的内容自动后移
        stringBuffer.insert(9, &quot;操&quot;);
        System.out.println(stringBuffer);
        //长度
        System.out.println(stringBuffer.length());
    &#125;
&#125;
</code></pre>
<p>练习题</p>
<pre><code class="lang-java">package com.zzy.stringbuffer_;

import java.util.Scanner;

/**
 * @autho: 周钟炎
 * @version: 1.0
 */
public class StringBufferExercise &#123;
    public static void main(String[] args) &#123;
        Scanner scanner = new Scanner(System.in);
        String str = scanner.next();
        StringBuffer stringBuffer = new StringBuffer(str);
        //查
        for (int i = stringBuffer.lastIndexOf(&quot;.&quot;) - 3; i &gt; 0 ; i -= 3) &#123;
            stringBuffer = stringBuffer.insert(i, &quot;,&quot;);
        &#125;
        System.out.println(stringBuffer);
    &#125;

&#125;
</code></pre>
<p>StringBuilder类</p>
<p>1.一个可变的字符序列。此类提供一个与StringBuffer兼容的API，但不保证同步（有线程安全问题）。该类被设计用作StringBuffer的一个简易替换，用在字符串缓冲区被单个线程使用的时候。如果可能，建议优先采用该类，因为在大多数实现中，它比StringBuffer要快。</p>
<p>2.在StringBuilder上的主要操作是append和insert方法，可以重载这些方法，以接受任意类型的数据。</p>
<p>String: 不可变字符序列，效率低，但是复用率高。</p>
<p>StringBuffer：可变字符序列，效率较高，线程安全。</p>
<p>StringBuilder:可变字符序列，效率最高，线程不安全。</p>
<p>使用的原则：</p>
<p>1.如果字符串存在大量的修改操作，一般使用StringBuffer或者StringBuilder</p>
<p>2.如果字符串存在大量的修改操作，并在单线程的情况下，使用StringBuilder</p>
<p>3.如果字符串存在大量的修改操作，并在多线程的情况下，使用StringBuilder</p>
<p>4.如果我们字符串很少修改，被多个对象引用，使用String,比如配置信息</p>
<h2 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h2><p>一般都为静态方法</p>
<pre><code class="lang-java">package com.zzy.math_;

import com.sun.jdi.DoubleValue;

import java.sql.SQLOutput;

/**
 * @autho: 周钟炎
 * @version: 1.0
 */
public class MathMethod &#123;
    public static void main(String[] args) &#123;
        //Math常用方法
        //abs 绝对值
        int abs = Math.abs(-2);
        System.out.println(abs);

        //pow 求幂
        double pow = Math.pow(2, 3);
        System.out.println(pow);

        //ceil 向上取整 返回最小整数（转成double)
        double ceil = Math.ceil(- 3.1);
        System.out.println(ceil);

        //floor 向下取整,坐标轴右边为上,(装成double)
        double floor = Math.floor(-3.1);
        System.out.println(floor);

        //round 四舍五入
        long round = Math.round(4.5);
        System.out.println(round);

        //开方
        double x = Math.sqrt(10);
        System.out.println(x);

        //返回随机数,返回[0, 1)的数
        double y = Math.random();
        double z = Math.floor( y * 6 + 2);
        System.out.println(z);

        //max, min 返回最大值和最小值
        int min = Math.min(1, 9);
        int max = Math.max(45, 90);
        System.out.println(&quot;max = &quot; + max);
        System.out.println(&quot;min = &quot; + min);
    &#125;
&#125;
</code></pre>
<h2 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h2><p>toString方法，打印出数组所有元素</p>
<pre><code class="lang-java">package com.zzy.array_;

import java.util.Arrays;
import java.util.Comparator;

/**
 * @autho: 周钟炎
 * @version: 1.0
 */
public class ArrayMethod01 &#123;
    public static void main(String[] args) &#123;
        Integer[] integers = &#123;1, 20, 90&#125;;
        //Arrays的toString方法
        System.out.println(Arrays.toString(integers));

        //排序
        Integer[] arr1 = &#123;1, -1, 7, 0, 89&#125;;
        //可以使用冒泡排序，也可以使用Arrays提供的sort方法
        //数组是引用类型,所以通过sort排序后，会直接影响到实参 arr
        Arrays.sort(arr1);
        System.out.println(&quot;排序后...&quot;);
        System.out.println(Arrays.toString(arr1));

        //定制排序，实现了Comparator接口的匿名内部类
        Arrays.sort(arr1, new Comparator&lt;Integer&gt;() &#123;
            @Override
            public int compare(Integer o1, Integer o2) &#123;
                return o2 -o1;
            &#125;
        &#125;);
        System.out.println(Arrays.toString(arr1));
    &#125;
&#125;
</code></pre>
<p>自己实现排序：</p>
<pre><code class="lang-java">package com.zzy.array_;

import java.util.Arrays;
import java.util.Comparator;

/**
 * @autho: 周钟炎
 * @version: 1.0
 */
public class ArraySortCustom &#123;
    public static void main(String[] args) &#123;
        int[] arr = &#123;1, -1, 8, 0, 20 &#125;;
        bubble_sort01(arr, new Comparator() &#123;
            @Override
            public int compare(Object o1, Object o2) &#123;
                int i1 = (Integer) o1; //向下转型加自动拆箱
                int i2 = (Integer) o2;
                return i1 -i2; //return i2 -i1;
            &#125;
        &#125;);
        System.out.println(Arrays.toString(arr));
    &#125;

    public static void bubble_sort(int[] arr) &#123;
        for (int i = 0; i &lt; arr.length ; i++) &#123;
            for (int j = i+1; j &lt;arr.length ; j++) &#123;
                if ( arr[i] &gt; arr[j]) &#123;
                    int temp = arr[i];
                    arr[i] = arr[j];
                    arr[j] = temp;
                &#125;
            &#125;
        &#125;
    &#125;

    //结合冒泡 + 定制
    public static void bubble_sort01 (int[] arr, Comparator c) &#123;
        for (int i = 0; i &lt; arr.length ; i++) &#123;
            for (int j = i+1; j &lt;arr.length ; j++) &#123;
                //数组的排序由if里的语句去控制
                if ( c.compare(arr[i], arr[j]) &gt; 0) &#123;
                    int temp = arr[i];
                    arr[i] = arr[j];
                    arr[j] = temp;
                &#125;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="lang-java">package com.zzy.array_;

import java.util.Arrays;
import java.util.List;

/**
 * @autho: 周钟炎
 * @version: 1.0
 */
public class ArrayMethod02 &#123;
    public static void main(String[] args) &#123;
        Integer[] arr = &#123;1, 2, 90, 123, 567&#125;;
        //使用binarySearch 二叉查找，要求数组是有序的
        //如果该数组是无序的，不能使用binarySearch
        //如果不存在，就返回 -(low + 1)，low代表他应该存在的位置
        int index = Arrays.binarySearch(arr, 568);
        System.out.println(index); //-6

        //copyOf 数组元素的复制,从arr中拷贝 arr.length个元素到newArr
        //如果拷贝的长度 &gt;原来数组，就在原来的数组尾插一个null
        Integer[] newArr = Arrays.copyOf(arr, arr.length + 1);
        System.out.println(Arrays.toString(newArr));

        //fill 数组填充,使用99替换原来的数组
        Integer[] num = &#123;9, 3, 2&#125;;
        Arrays.fill(num, 99);
        System.out.println(&quot;数组填充后...&quot;);
        System.out.println(Arrays.toString(num));

        //equals 比较两个数组元素内容是否完全一致,如果是则返回true
        Integer[] arr1 = &#123;1, 2, 90, 123, 567&#125;;
        boolean bool = Arrays.equals(arr, arr1);
        System.out.println(bool);

        //asList 将一组值，转换成List, List是一个接口
        List&lt;Integer&gt; asList = Arrays.asList(2, 3, 4, 5, 6, 1);
        System.out.println(&quot;asList = &quot; + asList);
    &#125;
&#125;
</code></pre>
<h2 id="System"><a href="#System" class="headerlink" title="System"></a>System</h2><p>1.exit退出当前程序</p>
<p>2.arraycopy：复制数组元素，比较适合底层调用，一般使用Arrays.copyOf完成复制数组</p>
<p>3.currentTimeMillens:返回当前时间距离1970-1-1的毫秒数</p>
<p>4.gc:运行垃圾回收机制System.gc();</p>
<h2 id="BigInteger和BigDecimal"><a href="#BigInteger和BigDecimal" class="headerlink" title="BigInteger和BigDecimal"></a>BigInteger和BigDecimal</h2><pre><code class="lang-java">package com.zzy.bignum_;

import java.math.BigInteger;

/**
 * @autho: 周钟炎
 * @version: 1.0
 */
public class bigInteger &#123;
    public static void main(String[] args) &#123;
        //编程中处理很大的整数,用BigInteger
        BigInteger bigInteger = new BigInteger(&quot;2321546576824343&quot;);
        System.out.println(bigInteger);

        //在对BigInteger进行加减乘除的时候，需要使用对应的方法，不能直接进行+ - * /
        BigInteger bigInteger1 = new BigInteger(&quot;100&quot;);
        BigInteger add = bigInteger.add(bigInteger1);
        System.out.println(add);

        BigInteger subtract = bigInteger.subtract(bigInteger1);
        System.out.println(subtract);

        BigInteger multiply = bigInteger.multiply(bigInteger1);
        System.out.println(multiply);

        BigInteger divide = bigInteger.divide(bigInteger1);
        System.out.println(divide);
    &#125;
&#125;
</code></pre>
<pre><code class="lang-java">package com.zzy.bignum_;

import java.math.BigDecimal;
import java.math.RoundingMode;

/**
 * @autho: 周钟炎
 * @version: 1.0
 */
public class bigDecimal_ &#123;
    public static void main(String[] args) &#123;
        //当我们需要保存一个精度很高的数时，double不够用
        BigDecimal bigDecimal = new BigDecimal(&quot;0.3232545465665454325&quot;);
        System.out.println(bigDecimal);
        //再除以小数的时候，可能是一个无限循环的小数，会抛出异常
        BigDecimal bigDecimal1 = new BigDecimal(&quot;3&quot;);
        //在调用divide时，指定精度就可以
        //如果有无限循环小数，就会保留分子的精度
        bigDecimal = bigDecimal.divide(bigDecimal1, RoundingMode.CEILING);
        System.out.println(bigDecimal);
    &#125;
&#125;
</code></pre>
<h2 id="日期类"><a href="#日期类" class="headerlink" title="日期类"></a>日期类</h2><pre><code class="lang-java">package com.zzy.date_;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

/**
 * @autho: 周钟炎
 * @version: 1.0
 */
public class Date01 &#123;
    public static void main(String[] args) throws ParseException &#123;
        //获取当前的系统时间
        Date date = new Date();
        System.out.println(&quot;当前日期 = &quot; + date);
        //默认输出的日期格式是国外的
        //用SimpleDateFormat改变的格式是规定好的
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy年MM月dd日 hh:mm:ss E&quot;);
        String format = simpleDateFormat.format(date);
        System.out.println(format);

        //也可以用构造器，输入毫秒数，但是时间是从1970年1月1号00:00开始的
        Date date1 = new Date(321321);
        System.out.println(date1);

        //把字符串转成Date
        String s = &quot;1996年01月01日 10:20:30 星期一&quot;;
        Date parse = simpleDateFormat.parse(s);
        System.out.println(simpleDateFormat.format(parse));
    &#125;
&#125;
</code></pre>
<p>第二代时间</p>
<pre><code class="lang-java">package com.zzy.date_;

import java.util.Calendar;

/**
 * @autho: 周钟炎
 * @version: 1.0
 */
public class Calender_ &#123;
    public static void main(String[] args) &#123;
        //Calender是一个抽象类,并且其构造器是受保护的
        Calendar c = Calendar.getInstance();
        //里面有很多字段，从中拿出相应的字段就好了
        System.out.println(&quot;c = &quot; + c);
        System.out.println(&quot;年:&quot; + c.get(Calendar.YEAR));
        //返回月的时候是按照0开始编号的
        System.out.println(&quot;月：&quot; + c.get(Calendar.MONTH) + 1);
        System.out.println(&quot;日：&quot; + c.get(Calendar.DAY_OF_MONTH));
        System.out.println(&quot;小时：&quot; + c.get(Calendar.HOUR));
        System.out.println(&quot;24小时制：&quot; + c.get(Calendar.HOUR_OF_DAY));
        System.out.println(&quot;分：&quot; + c.get(Calendar.MINUTE));
        System.out.println(&quot;秒：&quot; + c.get(Calendar.SECOND));

        //需要自己组合格式
    &#125;
&#125;
</code></pre>
<p>第三代时间</p>
<pre><code class="lang-java">package com.zzy.date_;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.time.format.DateTimeFormatter;

/**
 * @autho: 周钟炎
 * @version: 1.0
 */
public class LocalTime_ &#123;
    public static void main(String[] args) &#123;
        LocalDateTime ldt = LocalDateTime.now();
        System.out.println(ldt);
        System.out.println(&quot;年:&quot; + ldt.getYear());
        System.out.println(&quot;月：&quot; + ldt.getMonth());
        System.out.println(&quot;月：&quot; + ldt.getMonthValue());
        System.out.println(&quot;日：&quot; + ldt.getDayOfMonth());
        System.out.println(&quot;时：&quot; + ldt.getHour());
        System.out.println(&quot;分：&quot; + ldt.getMinute());
        System.out.println(&quot;秒：&quot; + ldt.getSecond());

        //获得年月日
        LocalDate now = LocalDate.now();
        //获取时分秒
        LocalTime now2 = LocalTime.now();

        //使用DateTimeFormatter对象进行格式化
        DateTimeFormatter dtf = DateTimeFormatter.ofPattern(&quot;yyyy年MM月dd日 HH小时mm分钟ss秒 E&quot;);
        String s = dtf.format(ldt);
        System.out.println(s);

        //加减时间
        LocalDateTime ldt2 = ldt.plusDays(890);
        System.out.println(dtf.format(ldt2));

        LocalDateTime ldt3 = ldt.minusYears(2);
        System.out.println(dtf.format(ldt3));
    &#125;
&#125;
</code></pre>
<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><p>保存多个数据时使用的是数组，而数组有不足的地方</p>
<p>数组</p>
<p>1.长度开始时必须指定，而且一旦指定，不能更改</p>
<p>2.保存的必须为同一类型的元素</p>
<p>3.增加或者删除元素比较麻烦</p>
<p>集合</p>
<p>1.可以动态保存任意多个对象，使用比较方便。</p>
<p>2.提供了一系列方便的操作对象的方法：add、remover、set、get</p>
<p>3.使用集合添加、删除新元素比较简单</p>
<p>集合主要分为2大类：</p>
<p>单列集合Collection</p>
<p>List: ArrayList、LinkedList、Vector</p>
<p>Set:HashSet、TreeSet</p>
<p>双列集合：</p>
<p>Map: HashMap、TreeMap、Hashtable、Properties</p>
<h2 id="List类的方法"><a href="#List类的方法" class="headerlink" title="List类的方法"></a>List类的方法</h2><pre><code class="lang-java">package com.zzy.collection_;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

/**
 * @autho: 周钟炎
 * @version: 1.0
 */
public class Collection01 &#123;
    public static void main(String[] args) &#123;
        List list = new ArrayList(); //动态绑定
        //增加
        list.add(&quot;jack&quot;);
        list.add(10);
        list.add(true);
        System.out.println(list);

        //删
        list.remove(0);//删除第一个元素
        list.remove(true);//删除某个元素
        System.out.println(list);

        //查找
        System.out.println(list.contains(10));

        //返回元素的个数
        System.out.println(list.size());

        //判断是否为空
        System.out.println(list.isEmpty());

        //清空
//        list.clear();

        //添加多个对象
        ArrayList arrayList = new ArrayList();
        arrayList.add(&quot;红楼梦&quot;);
        arrayList.add(&quot;三国演义&quot;);
        list.addAll(arrayList);
        System.out.println(list);

        //删除多个元素
        list.removeAll(arrayList);
        System.out.println(list);
    &#125;
&#125;
</code></pre>
<p>实现了Iterable接口的可以采用迭代器的方式遍历</p>
<pre><code class="lang-java">package com.zzy.collection_;

import java.util.ArrayList;
import java.util.Iterator;

/**
 * @autho: 周钟炎
 * @version: 1.0
 */
public class CollectionIterator &#123;
    public static void main(String[] args) &#123;
        ArrayList arrayList = new ArrayList();
        arrayList.add(new Book(&quot;三国演义&quot;, &quot;罗贯中&quot;, 19));
        arrayList.add(new Book(&quot;红楼梦&quot;, &quot;曹雪芹&quot;, 20));
        arrayList.add(new Book(&quot;西游记&quot;, &quot;吴世恩&quot;, 22));
        System.out.println(arrayList);

        //遍历
        Iterator it = arrayList.iterator();

        while (it.hasNext()) &#123;
            //因为什么都能存，所以返回的是Object
            Object obj = it.next();
            System.out.println(obj); //动态绑定
        &#125;

        //如果想重新遍历，就要重置迭代器
        it = arrayList.iterator();
        while (it.hasNext()) &#123;
            Object next =  it.next();
            System.out.println(next);
        &#125;
    &#125;
&#125;

class Book &#123;
    public String name;
    public String author;
    public double price;

    public Book(String name, String author, double price) &#123;
        this.name = name;
        this.author = author;
        this.price = price;
    &#125;

    @Override
    public String toString() &#123;
        return &quot;Book&#123;&quot; +
                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +
                &quot;, author=&#39;&quot; + author + &#39;\&#39;&#39; +
                &quot;, price=&quot; + price +
                &#39;&#125;&#39;;
    &#125;
&#125;
</code></pre>
<p>==ctrl加J可以提示所有的快捷键==</p>
<p>List集合类中元素有序，且可重复。</p>
<p>List集合中的每个元素都有其对应的顺序索引</p>
<pre><code class="lang-java">package com.zzy.collection_;

import java.util.ArrayList;
import java.util.List;

/**
 * @autho: 周钟炎
 * @version: 1.0
 */
public class ListMethod &#123;
    public static void main(String[] args) &#123;
        List list = new ArrayList();
        list.add(&quot;老黑&quot;);
        list.add(&quot;大狗&quot;);

        //在指定位置插入
        list.add(1, &quot;大黄&quot;);
        System.out.println(list);

        //加入多个元素
        List list1 = new ArrayList();
        list1.add(&quot;lxc&quot;);
        list1.add(&quot;zy&quot;);
        list.addAll(1, list1);
        System.out.println(list);

        //替换
        list.set(0, &quot;sy&quot;);
        System.out.println(list);

        //返回集合,返回的是一个前闭后开的范围
        List returnlist = list.subList(0, 3);
        System.out.println(returnlist);
    &#125;
&#125;
</code></pre>
<p>ArrayList效率高,但是是线程不安全的</p>
<p>ArrayList源码</p>
<p>1.ArrayList中维护了一个Object类型的数组</p>
<p>2.当创建ArrayList对象时，如果使用的是无参构造器，则初始elementData容量为0，第一次添加，则扩容elementData为10，如需再次扩容，则扩容elmentData为1.5倍。</p>
<p>3.如果使用的是制定大小的构造器，则初始化elementData容量为指定大小，如果需要扩容，则直接扩容elementData为1.5倍。</p>
<p>transient //表示瞬间的、短暂的，表示该属性不会被序列号</p>
<p>Vector</p>
<p>1.Vector底层也是一个对象数组， protected Object[] elementData;</p>
<p>2.Vector是线程安全的</p>
<p>3.如果是无参，默认为10，满后，就按2倍扩容</p>
<p>LinkedList</p>
<p>1.LinkedList底层实现了双向链表和双端队列的特点</p>
<p>2.可以添加任意元素（元素可以重复），包括null</p>
<p>3.线程不安全，没有实现同步</p>
<p>LinkedList底层维护了一个双向链表，两个属性first和last分别指向首节点和尾结点</p>
<p>每个节点(Node对象)，里面又维护了prev、next、item三个属性，prev指向前一个，通过next指向后一个节点，最近实现双向链表。</p>
<p>比较方便添加和删除</p>
<pre><code class="lang-java">package com.zzy.collection_;

/**
 * @autho: 周钟炎
 * @version: 1.0
 */
public class LinkedList01 &#123;
    public static void main(String[] args) &#123;
        Node jack = new Node(&quot;jack&quot;);
        Node tom = new Node(&quot;tom&quot;);
        Node hsp = new Node(&quot;老韩&quot;);
        //jack-&gt;tom-&gt;hsp
        //连接三个结点
        jack.next = tom;
        tom.next = hsp;
        //hsp-&gt;tom-&gt;jack
        hsp.pre = tom;
        tom.pre = jack;

        Node first = jack;
        Node last = hsp;

        //从头到尾遍历
        while (true) &#123;
            if (first == null) &#123;//true
                break;
            &#125;
            System.out.println(first);
            first = first.next; //tom.next = null;
        &#125;

        //从尾到头遍历
        while (true) &#123;
            if (last == null) &#123;
                break;
            &#125;
            System.out.println(last);
            last = last.pre;
        &#125;

        //在tom和和老韩之间加入一个对象
        Node zf = new Node(&quot;张飞&quot;);

        tom.next = zf;
        zf.next = hsp;
        hsp.pre = zf;
        zf.pre = tom;

        first = jack;
        while (true) &#123;
            if (first == null) &#123;//true
                break;
            &#125;
            System.out.println(first);
            first = first.next; //tom.next = null;
        &#125;
    &#125;
&#125;

class Node &#123;
    public Object item;
    public Node next; //下一个节点
    public Node pre; //前一个节点

    public Node(Object item) &#123;
        this.item = item;
    &#125;

    public String toString() &#123;
        return &quot;Node name = &quot; + item;
    &#125;
&#125;
</code></pre>
<pre><code class="lang-java">package com.zzy.collection_;

import java.util.LinkedList;

/**
 * @autho: 周钟炎
 * @version: 1.0
 */
public class LinkedList02 &#123;
    public static void main(String[] args) &#123;
        LinkedList linkedList = new LinkedList();
        linkedList.add(1);
        linkedList.add(2);
        linkedList.add(3);
        System.out.println(linkedList);

        linkedList.remove();
        System.out.println(linkedList);

        //修改某个节点对象
        linkedList.set(1,999);
        System.out.println(linkedList);

        //得到某个节点对象
        System.out.println(linkedList.get(0));
    &#125;
&#125;
</code></pre>
<h2 id="Set类"><a href="#Set类" class="headerlink" title="Set类"></a>Set类</h2><p>1.无序（添加和取出的顺序不一致），没有索引</p>
<p>2.不允许重复的元素，所以最多包含一个null</p>
<p>HashSet:</p>
<p>1.HashSet底层是HashMap</p>
<p>2.添加一个元素时，先得到hash值，会转成-&gt;索引值</p>
<p>3.找到存储数据表table，看这个索引位置是否有已经存放的元素</p>
<p>4.如果没有，直接加入</p>
<p>5.如果有，调用equals比较，如果相同，就放弃添加，如果不相同，则添加到最后</p>
<p>6.在Java8中，如果一条链表的元素个数达到TREEIFT_THRESHOLD（默认为8），并且table的大小&gt;=MIN_TREEIFY_CAPACITY（默认64），就会进行树化（红黑树）</p>
<p>经典题：</p>
<pre><code class="lang-java">package com.zzy.set_;

import java.util.HashSet;
import java.util.Objects;

/**
 * @autho: 周钟炎
 * @version: 1.0
 */
public class HashSetExercise02 &#123;
    public static void main(String[] args) &#123;
        HashSet hashSet = new HashSet();
        hashSet.add(new Employee_(&quot;zzy&quot;, 30000,
                new Employee_().new MyDate(1998, 11, 24)));
        hashSet.add(new Employee_(&quot;zzy&quot;, 30000,
                new Employee_().new MyDate(1998, 11, 24)));
        System.out.println(hashSet);
    &#125;
&#125;

class Employee_ &#123;
    private String name;
    private double salary;
    private MyDate birthday;

    public Employee_(String name, double salary, MyDate birthday) &#123;
        this.name = name;
        this.salary = salary;
        this.birthday = birthday;
    &#125;

    public Employee_()&#123;&#125;

    class MyDate&#123;
        private int year;
        private int month;
        private int day;

        public MyDate(int year, int month, int day) &#123;
            this.year = year;
            this.month = month;
            this.day = day;
        &#125;

        //通过内部类的hashCode和 equals的重写，套娃使其得到的hashCode依据birthday的内容决定
        //而不是地址
        @Override
        public boolean equals(Object o) &#123;
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            MyDate myDate = (MyDate) o;
            return year == myDate.year &amp;&amp; month == myDate.month &amp;&amp; day == myDate.day;
        &#125;

        @Override
        public int hashCode() &#123;
            return Objects.hash(year, month, day);
        &#125;
    &#125;

    @Override
    public boolean equals(Object o) &#123;
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Employee_ employee_ = (Employee_) o;
        return name.equals(employee_.name) &amp;&amp; birthday.equals(employee_.birthday);
    &#125;

    @Override
    public int hashCode() &#123;
        //这里的name是在常量池,但是要保证内部类的所影响的hashCode一致
        return Objects.hash(name, birthday);
    &#125;
&#125;
</code></pre>
<p>LinkedHashSet</p>
<p>1.在LinkedHashSet中维护了一个hash表和双向链表</p>
<p>2.在某个节点有before和after属性，这样可以形成双向链表</p>
<p>3.在添加一个元素时，先求hash值，再求索引，确定该元素在table的位置，然后将添加的元素加入到双向链接（如果已经存在，不添加【原则和hashset一样】</p>
<p>4.这样的话，我们遍历LinkedHashSet也能确保插入顺序和遍历顺序一致</p>
<p>里面HashMapNode里有内部类LinkedHashMapEntry</p>
<p>==其实set也是键值对的形式，但是其value是用一个常量填充的==</p>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><pre><code class="lang-java">package com.zzy.map_;

import java.util.HashMap;
import java.util.Map;

/**
 * @autho: 周钟炎
 * @version: 1.0
 */
@SuppressWarnings(&#123;&quot;all&quot;&#125;)
public class Map_ &#123;
    public static void main(String[] args) &#123;
        //map接口实现类的特点
        //1.保存具有映射关系的key-value
        //无序的，因为底层还是hashMap
        Map map = new HashMap();
        map.put(&quot;No1&quot;, &quot;zzy&quot;);
        map.put(&quot;No2&quot;, &quot;林动&quot;);
        //当key相同的，会进行替换
        map.put(&quot;No1&quot;, &quot;韩顺平&quot;);
        //value值是可以重复的
        map.put(&quot;No3&quot;, &quot;zzy&quot;);
        System.out.println(&quot;map = &quot; + map);
        //Map的key可以为null，value也可以为空，但是key的null只能有一个，value为null可以有多个
        //key和value之间存在单向一对一关系，即通过指定的key总能找到对应的value

        //通过get方法，传入key，得到相应的value
        System.out.println(map.get(&quot;No1&quot;));
    &#125;
&#125;
</code></pre>
<p>Map的源码解析</p>
<pre><code class="lang-java">package com.zzy.map_;

import java.util.Collection;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;

/**
 * @autho: 周钟炎
 * @version: 1.0
 */
public class MapSource &#123;
    public static void main(String[] args) &#123;
        Map map = new HashMap();
        map.put(&quot;no1&quot;, &quot;韩顺平&quot;);
        map.put(&quot;no2&quot;, &quot;zzy&quot;);

        //1.k-v是在HashMap$Node里面管理的
        //2.k-v为了方便程序员的遍历，还会创建EntrySet集合，该集合存放的元素的类型是Entry
        //3.entrySet中，定义的类型是Map.Entry, 但是实际上存放的还是HashMap$Node,这是因为Ha
        //HashMap$Node implements Map.Entry
        //4.当把HashMap$Node 对象放到entrySet 就方便我们遍历,因为Map.entry提供了重要方法
        //getKey() 和 getValue()
        Set set = map.entrySet();
        for (Object obj : set) &#123;
            Map.Entry entry = (Map.Entry) obj;
            System.out.println(entry.getKey() + &quot;-&quot; + entry.getValue());
        &#125;

        //k值收集到了Set里  value收集到了 Collection
        Set set1 = map.keySet();
        //KeySet
        System.out.println(set1.getClass());
        Collection values = map.values();
        //Values
        System.out.println(values.getClass());
    &#125;
&#125;
</code></pre>
<p>➢扩容机制[和HashSet相同]<br>1) HashMap底层维护了Node类型的数组table,默认为null<br>2)当创建对象时，将加载因子(loadfactor)初始化为0.75.<br>3) 当添加key-val时，通过key的哈希值得到在table的索引。然后判断该索引处是否有元素，<br>如果没有元素直接添加。如果该索引处有元素，继续判断该元素的key是否和准备加入的<br>key相等，如果相等，则直接替换val;如果不相等需要判断是树结构还是链表结构，做出<br>相应处理。如果添加时发现容量不够，则需要扩容。<br>4)第1次添加，则需要扩容table容量为16,临界值(threshold)为12.<br>5)以后再扩容，则需要扩容table容量为原来的2倍，临界值为原来的2倍,即24,依次类推.<br>6)在Java8中，如果一条链表的元素个数超过TREEIFY THRESHOLD(默认是8)，并且<br>table的大小&gt;= MIN TREEIFY CAPACITY(默认64),就会进行树化(红黑树)</p>
<hr>

<p>Map的接口和常用方法</p>
<pre><code class="lang-java">package com.zzy.map_;

import java.util.HashMap;
import java.util.Map;

/**
 * @autho: 周钟炎
 * @version: 1.0
 */
public class MapMethod &#123;
    public static void main(String[] args) &#123;
        Map map = new HashMap();
        map.put(&quot;邓超&quot;, new Book(&quot;&quot;, 100));
        map.put(&quot;王宝强&quot;, &quot;马蓉&quot;);
        map.put(&quot;宋喆&quot;, &quot;马蓉&quot;);
        map.put(&quot;邓超&quot;, &quot;孙俪&quot;);
        map.put(null, &quot;刘亦菲&quot;);
        System.out.println(&quot;map=&quot; +map );

        //remove:根据键删除映射关系
        map.remove(null);
        System.out.println(&quot;map=&quot; +map );

        //通过键获得值
        Object val = map.get(&quot;王宝强&quot;);
        System.out.println(&quot;value = &quot; + val);

        //获取元素个数
        System.out.println(&quot;size = &quot; + map.size());

        //判断元素是否为空
        System.out.println(map.isEmpty());

        //清除l-v
        map.clear();

        //查找键是否存在
        System.out.println(map.containsKey(&quot;邓超&quot;));

    &#125;
&#125;

class Book &#123;
    private String name;
    private int num;

    public Book(String name, int num) &#123;
        this.name = name;
        this.num = num;
    &#125;
&#125;
</code></pre>
<p>Map的遍历</p>
<pre><code class="lang-java">package com.zzy.map_;

import java.util.*;

/**
 * @autho: 周钟炎
 * @version: 1.0
 */
public class Mapfor &#123;
    public static void main(String[] args) &#123;
        Map map = new HashMap();
        map.put(&quot;邓超&quot;, new Book(&quot;&quot;, 100));
        map.put(&quot;王宝强&quot;, &quot;马蓉&quot;);
        map.put(&quot;宋喆&quot;, &quot;马蓉&quot;);
        map.put(&quot;邓超&quot;, &quot;孙俪&quot;);
        map.put(null, &quot;刘亦菲&quot;);

        Set keyset = map.keySet();
        //第一组,通过key获取vales
        for (Object o : keyset) &#123;
            System.out.println(o + &quot;-&quot; + map.get(o));
        &#125;
        Iterator it = keyset.iterator();
        while (it.hasNext()) &#123;
            Object next =  it.next();
            System.out.println(next + &quot;-&quot; + map.get(next));
        &#125;

        //第二组，取出所有的values
        Collection values = map.values();
        for (Object o : values) &#123;
            System.out.println(o);
        &#125;
        Iterator it2= values.iterator();
        while (it2.hasNext()) &#123;
            Object next =  it2.next();
            System.out.println(next);
        &#125;

        //通过EntrySet
        Set set = map.entrySet();
        for (Object o : set) &#123;
            //向下转型
            Map.Entry entry = (Map.Entry) o;
            System.out.println(entry.getKey() + &quot;-&quot; + entry.getValue());
        &#125;
        Iterator it3 = set.iterator();
        while (it3.hasNext()) &#123;
            Object next =  it3.next();
            Map.Entry entry = (Map.Entry) next;
            System.out.println(entry.getKey() + &quot;-&quot; +entry.getValue());
        &#125;
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>JS细节</title>
    <url>/2021/08/25/%E5%89%8D%E7%AB%AF/JS%E7%BB%86%E8%8A%82/</url>
    <content><![CDATA[<h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><p>删除对象中的属性 delete obj.name</p>
<p>对象的属性名不强制要求遵守标识符的规范，但尽量按照规范使用</p>
<p>访问对象里的属性有两种方法：</p>
<p>1.通过.来访问</p>
<p>2.通过[]来访问</p>
<p>访问对象里的方法只能通过.来进行访问。</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>基本数据类型</p>
<p>String、Number、Boolean、Null、Undefined,存储在栈内存中</p>
<p>引用数据类型</p>
<p>Object、它是存储在堆内存中,将一个变量设置为null会断开其指针指向</p>
<p>基本数据类型比较值，引用数据类型比较地址</p>
<h2 id="对象字面量"><a href="#对象字面量" class="headerlink" title="对象字面量"></a>对象字面量</h2><pre><code>var obj = &#123;&#125;;
var obj2 = &#123;
    name:&quot;猪八戒&quot;,
    age:18
&#125;
</code></pre><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>如果return语句后不跟任何值就相当于返回一个undefined，如果函数中不写return,则也会返回undefined</p>
<p>立即执行函数</p>
<pre><code>(function(a,b,c)&#123;
      console.log(a+b+c);
    &#125;)(1,2,3)
</code></pre><h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><p>回调函数：由我们自己创建，但是不由我们调用的，称为回调函数</p>
<h3 id="函数方法call，apply"><a href="#函数方法call，apply" class="headerlink" title="函数方法call，apply"></a>函数方法call，apply</h3><p>函数方法call()、apply(),调用时传入参数，可以改变函数的this指向, call()方法可以将实参在对象之后依次传递，apply()方法需要将实参封装到一个数组中统一传递</p>
<h3 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h3><p>arguments是一个类数组对象，它也可以通过索引来操作数据，也可以获取长短，在调用函数时，我们所传递的实参都会在arguments中保存</p>
<h2 id="for-in"><a href="#for-in" class="headerlink" title="for in"></a>for in</h2><pre><code>var obj = &#123;
      name:&#39;张三&#39;,
      age:18,
      gender:&#39;男&#39;
    &#125;

    for (a in obj)&#123;
      console.log(a);
      console.log(obj[a]);
    &#125;
</code></pre><h2 id="in以及hasOwnProperty"><a href="#in以及hasOwnProperty" class="headerlink" title="in以及hasOwnProperty"></a>in以及hasOwnProperty</h2><pre><code>//使用in检查对象中是否含有某个属性时，如果对象中没有但是原型中有，也会返回true
    console.log(&quot;name&quot; in mc);
    //hasOwnProperty是检查自身有没有这个属性的方法
    console.log(mc.hasOwnProperty(&quot;name&quot;));
</code></pre><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p>当一个对象不在使用以后，将其设置为null，断开与堆内存的连接，这样垃圾回收机制才会运行</p>
<h1 id="内建对象"><a href="#内建对象" class="headerlink" title="内建对象"></a>内建对象</h1><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组的存储性能比普通对象要好，在开发中经常使用</p>
<p>方法：</p>
<p>arr.join(“-“) arr.join方法可以把数组转成字符串。其中传入的参数是分隔符<br>arr.sort()方法默认会按照Unicode进行排序，在设计到数字的排序时，可能会出现错误，需要自己制定规则排序</p>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>fromCharAt()</p>
<pre><code>var result = String.fromCharCode(72);
    console.log(result);
</code></pre><h1 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h1><p>DOM操作主要还是寻找相关的API方法，逻辑上不难，主要理解Element、Node、Event的相互关系。</p>
<p>我们想要操作网页的元素，则必须可以访问到这个元素，html这种树形的结构，我们只要先拿到其文档对象，就可以采用相应的方法对其进行操作。</p>
<p>浏览器已经为我们提供了文档节点对象，这个对象是winodw属性，可以在页面中直接使用，文档节点代表的是整个网页。</p>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>事件就是用户和浏览器之间的交互行为</p>
<h2 id="浏览器页面的加载顺序"><a href="#浏览器页面的加载顺序" class="headerlink" title="浏览器页面的加载顺序"></a>浏览器页面的加载顺序</h2><p>浏览器在加载一个页面时，是按照自上向下的顺序加载的，将js代码编写到页面的下部就是为了可以在页面加载完毕以后再执行js代码</p>
<p>如果想把js代码写在上面，可以给window绑定一个onload事件，该事件对应的响应函数将会在页面加载完成后执行</p>
<h2 id="事件绑定，获取节点元素"><a href="#事件绑定，获取节点元素" class="headerlink" title="事件绑定，获取节点元素"></a>事件绑定，获取节点元素</h2><p>如果需要读取元素节点属性，直接使用元素.属性名，但class属性不能采用这种方法，读取class属性时需要使用.className</p>
<pre><code class="lang-html">//获取body标签
    var body = document.body;
    console.log(body);
    //获取Html标签
    var html = document.documentElement;
    console.log(html);
    //document.all代表页面中的所有元素
    var all = document.all;
    console.log(all.length);
    //参数为css选择器，可以查询到对应的元素,但是它只会返回一个元素
    var div = document.querySelector(&quot;.box1 div&quot;)
    //返回多个元素，以数组形式返回,即使符合条件的元素只有一个，它也会返回数组
    var div = document.querySelectorAll(&quot;.box1&quot;)
</code></pre>
<h2 id="Dom练习"><a href="#Dom练习" class="headerlink" title="Dom练习"></a>Dom练习</h2><pre><code class="lang-html">&lt;form action=&quot;&quot;&gt;
    你爱好的运动是?&lt;input type=&quot;checkbox&quot; id=&quot;checkedAllBox&quot;&gt; 全选/全不选
    &lt;br&gt;
    &lt;input type=&quot;checkbox&quot; name=&quot;items&quot; value=&quot;足球&quot;&gt;足球
    &lt;input type=&quot;checkbox&quot; name=&quot;items&quot; value=&quot;篮球&quot;&gt;篮球
    &lt;input type=&quot;checkbox&quot; name=&quot;items&quot; value=&quot;羽毛球&quot;&gt;羽毛球
    &lt;input type=&quot;checkbox&quot; name=&quot;items&quot; value=&quot;兵乓球&quot;&gt;兵乓球
    &lt;br&gt;
    &lt;input type=&quot;button&quot; id=&quot;checkedAllBtn&quot; value=&quot;全选&quot;&gt;
    &lt;input type=&quot;button&quot; id=&quot;checkedNoBtn&quot; value=&quot;全不选&quot;&gt;
    &lt;input type=&quot;button&quot; id=&quot;checkedRevBtn&quot; value=&quot;反选&quot;&gt;
    &lt;input type=&quot;button&quot; id=&quot;sendBtn&quot; value=&quot;提交&quot;&gt;
  &lt;/form&gt;
  &lt;script&gt;
    var checkedAllBtn = document.getElementById(&quot;checkedAllBtn&quot;)
    var items = document.getElementsByName(&quot;items&quot;)
    checkedAllBtn.onclick = () =&gt; &#123;
      items.forEach((value) =&gt; &#123;
        value.checked = true
      &#125;)
    &#125;

    var checkedNoBtn = document.getElementById(&quot;checkedNoBtn&quot;)
    checkedNoBtn.onclick = () =&gt; &#123;
      items.forEach((value) =&gt; &#123;
        value.checked = false
      &#125;)
    &#125;

    var checkedRevBtn = document.getElementById(&quot;checkedRevBtn&quot;)
    checkedRevBtn.onclick = () =&gt; &#123;
      items.forEach((value) =&gt; &#123;
        value.checked = !value.checked
      &#125;)
    &#125;

    var sendBtn = document.getElementById(&quot;sendBtn&quot;)
    sendBtn.onclick = () =&gt; &#123;
      items.forEach((event) =&gt; &#123;
       if (event.checked === true) &#123;
          console.log(event.value);
       &#125;
      &#125;)
    &#125;

    var checkedAllBox = document.getElementById(&quot;checkedAllBox&quot;)
    checkedAllBox.onclick = () =&gt; &#123;
      items.forEach((event) =&gt; &#123;
        event.checked = checkedAllBox.checked
      &#125;)
    &#125;
    var num = 0
    items.forEach((event) =&gt; &#123;
      event.onclick = () =&gt; &#123;
        checkedAllBox.checked = true
        if (!event.checked) &#123;
          checkedAllBox.checked = false
        &#125;
      &#125;
    &#125;)
  &lt;/script&gt;
</code></pre>
<h2 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h2><pre><code class="lang-html">&lt;ul id=&quot;city&quot;&gt;
    &lt;li&gt;上海&lt;/li&gt;
    &lt;li&gt;深圳&lt;/li&gt;
    &lt;li&gt;武汉&lt;/li&gt;
    &lt;li id=&quot;bj&quot;&gt;北京&lt;/li&gt;
  &lt;/ul&gt;
  &lt;button id=&quot;addCity&quot;&gt;点我添加&lt;/button&gt;
  &lt;button id=&quot;deleteCity&quot;&gt;点我删除&lt;/button&gt;
  &lt;script&gt;
    function myClick(idStr, fun) &#123;
      var ele = document.getElementById(idStr)
      ele.onclick = fun
    &#125;
    myClick(&quot;addCity&quot;,() =&gt; &#123;
    //获取父元素节点
    var city = document.getElementById(&quot;city&quot;);
    //创建子元素节点
    var li = document.createElement(&quot;li&quot;);
    //添加内容
    li.innerHTML = &quot;广州&quot;;
    //将子元素追加进去
    city.appendChild(li)
    &#125;)

    myClick(&quot;deleteCity&quot;, () =&gt; &#123;
      var bj = document.getElementById(&quot;bj&quot;)
      //这种方式来进行删除
      bj.parentNode.removeChild(bj)
    &#125;)
  &lt;/script&gt;
</code></pre>
<h2 id="DOM操作css"><a href="#DOM操作css" class="headerlink" title="DOM操作css"></a>DOM操作css</h2><p>拿到element以后直接element.style.height =”300px”修改，在遇见background-color这种时，需要采用驼峰命名backgroundColor，这种设置都是设置的内联样式，有着较高的优先级，在用这种方法进行读取时，也是读的内联样式，因此可能会读取不到样式表中的样式。</p>
<h1 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h1><p><img src="https://raw.githubusercontent.com/zzygeo/images/master/js运算符优先级.4dxtiok15my0.png" alt="js运算符优先级"></p>
<h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><p>JS中一共有两种作用域<br>全局作用域：</p>
<ul>
<li>直接写到script标签中的JS代码，都在全局作用域</li>
<li>全局作用域在页面打开时创建，在页面关闭时销毁</li>
<li>在全局作用域中有一个全局对象window，我们可以直接使用，他代表我们浏览器的窗口</li>
<li>在全局作用域中，创建的变量都会作为window对象的属性保存</li>
<li>创建的方法都会作为window对象的方法保存</li>
</ul>
<p>函数作用域</p>
<ul>
<li>调用函数时创建函数作用域，函数执行完毕以后，函数作用域销毁</li>
<li>每调用一次函数就会创建一个新的函数作用域，他们之间是相互独立的</li>
<li>在函数作用域中可以访问到全局作用域的变量</li>
<li>访问时遵循就近一致原则</li>
</ul>
<h2 id="声明提前"><a href="#声明提前" class="headerlink" title="声明提前"></a>声明提前</h2><p>使用var关键字声明的变量，会在所有的代码执行之前被声明</p>
<pre><code>    //var a;在执行时会先执行这个
    console.log(a);
    var a = 18
</code></pre><p>函数声明提前</p>
<p>使用函数声明形式创建的函数function 函数(){},它会在所有的代码执行之前就被创建</p>
<p>使用函数表达式创建的函数，不会被声明提前，所以不能在声明前被调用</p>
<pre><code>sum1();//3
console.log(sum2);//undefined
var sum2 = function() &#123;
    return 2 + 3;
&#125;
function sum1() &#123;
    return 1 + 2;
&#125;
</code></pre><p>在函数作用域也有声明提前的特性，可以理解为一个小的全局作用域</p>
<p>没有使用var声明的变量，在方法内部或外部都是全局变量，但如果是在方法内部声明，在方法外部使用之前需要先调用方法，告知系统声明了全局变量后方可在方法外部使用</p>
<pre><code>function a() &#123;
      b = 10
    &#125;
a()//需要先调用
console.log(b);
</code></pre><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>解析器在调用函数每次都会向函数内部传递一个隐含的参数，这个隐含的参数就是this</p>
<p>根据函数的调用方式的不同，this会指向不同的对象</p>
<p>以函数的形式调用时，this永远指向的都是window</p>
<p>以方法的形式调用时，this指向的就是调用该方法的对象</p>
<p> 当以构造函数的形式调用时，this就是新创建的那个对象</p>
<h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><p>构造函数的执行流程</p>
<ol>
<li>立即创建一个对象</li>
<li>将新建的对象设置为函数中的this</li>
<li>执行函数中的代码</li>
<li>将新建的对象作为返回值返回</li>
</ol>
<p>所有的对象都是Object的子类</p>
<h1 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h1><p>原型prototype，我们所创建的每一个函数，解析器都会向函数中添加一个属性prototype，这里存的地址指向这个原型对象</p>
<p>如果函数作为普通函数调用prototype没有任何作用，当函数通过构造函数调用时，它所创建的对象中都会有一个隐含的属性指向该构造函数的原型对象，可以通过<strong>proto</strong>来访问，原型对象就相当于一个公共的区域，所有同一个类的实例都可以访问到这个原型对象，我们可以将对象中共有的内容，统一设置到原型对象中</p>
<p>当我们访问对象的一个属性或方法时，它会先在对象自身中寻找，如果有则直接使用，如果没有则会去原型对象中寻找，如果找到则直接使用</p>
<pre><code>function Person(name, age, gender)&#123;
      this.name = name;
      this.age = age;
      this.gender = gender
      console.log(this);
    &#125;
    var p = new Person(&#39;猪八戒&#39;, 28, &#39;男&#39;);
    console.log(Person.prototype);
    console.log(p.__proto__);
    console.log(Person.prototype == p.__proto__);
</code></pre><p>可以和java里的static修饰符做比较</p>
<h1 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h1><p>JS里有基本数据类型 String、Number、Boolean、Null、Undefined</p>
<p>引用数据类型Object</p>
<p>在JS中为我们提供了三个包装类，通过这三个包装类可以将基本数据类型的数据转换成对象</p>
<p>String()、Number()、Boolean()</p>
<p>细节：</p>
<p>方法和属性只能添加给对象，不能添加给基本数据类型，当我们对一些基本数据类型的值去调用属性和方法时，浏览器会临时使用包装类将其转换成对象，然后再调用对象的属性和方法</p>
<pre><code>var s = 123;
s = s.toString();
console.log(typeof s);
</code></pre><h1 id="事件-1"><a href="#事件-1" class="headerlink" title="事件"></a>事件</h1><pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
  &lt;title&gt;JS对象&lt;/title&gt;
  &lt;style&gt;
    #box1&#123;
      width: 100px;
      height: 100px;
      background-color: pink;
      position: absolute;
    &#125;
  &lt;/style&gt;
&lt;/head&gt;
&lt;body style=&quot;height: 1000px;&quot;&gt;
  &lt;div id=&quot;box1&quot;&gt;&lt;/div&gt;
  &lt;script&gt;
    var box1 = document.getElementById(&quot;box1&quot;)
    //鼠标事件调用时，会传入一个event参数
    document.onmousemove = function(event) &#123;
    //clientX、clientY是按照浏览器的可视窗口来看的，因此当出现滚动条了以后就有问题了
    //pageX、pageY是相对这个body的高度的
    var st2 = document.documentElement.scrollTop;
    var left = event.clientX;
    var top = event.clientY;
    box1.style.left = left + st2 + &quot;px&quot;;
    box1.style.top = top + st2 + &quot;px&quot;;
   &#125;
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h2 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h2><p>当事件发生后，这个事件就要开始传播(从里到外或者从外向里)。为什么要传播呢？因为事件源本身（可能）并没有处理事件的能力，即处理事件的函数（方法）并未绑定在该事件源上。例如我们点击一个按钮时，就会产生一个click事件，但这个按钮本身可能不能处理这个事件，事件必须从这个按钮传播出去，从而到达能够处理这个事件的代码中（例如我们给按钮的onclick属性赋一个函数的名字，就是让这个函数去处理该按钮的click事件），或者按钮的父级绑定有事件函数，当该点击事件发生在按钮上，按钮本身并无处理事件函数，则传播到父级去处理。</p>
<h2 id="事件委派"><a href="#事件委派" class="headerlink" title="事件委派"></a>事件委派</h2><p>指将事件统一绑定给元素的共同的祖先元素，这样当后代元素上的事件触发时，会一直冒泡到祖先元素，从而通过祖先元素的响应函数来处理事件。</p>
<p>好处：事件委派是利用了冒泡，通过委派可以减少事件绑定的次数，提高程序的性能。</p>
<pre><code class="lang-html">&lt;button id=&quot;bt1&quot;&gt;点击添加超链接&lt;/button&gt;
  &lt;ul id=&quot;u1&quot;&gt;
    &lt;li&gt;&lt;a href=&quot;javascript:;&quot; class=&quot;link&quot;&gt;超链接1&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;javascript:;&quot; class=&quot;link&quot;&gt;超链接2&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;javascript:;&quot; class=&quot;link&quot;&gt;超链接3&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
  &lt;script&gt;
    var allA = document.getElementsByTagName(&quot;a&quot;)
    var u1 = document.getElementById(&quot;u1&quot;)
    for (var i = 0; i &lt; allA.length; i++) &#123;
      u1.onclick = function (event) &#123;
        console.log(event.target);
        if (event.target.className == &quot;link&quot;) &#123;
          alert(&quot;我是A的单击响应函数...&quot;)
        &#125;
      &#125;
    &#125;
    var bt1 = document.getElementById(&quot;bt1&quot;)
    bt1.onclick = function () &#123;
      var li = document.createElement(&quot;li&quot;)
      li.innerHTML = &quot;&lt;a href=&#39;javascript:;&#39; class=&#39;link&#39;&gt;新链接&lt;/a&gt;&quot;
      u1.appendChild(li)
    &#125;
  &lt;/script&gt;
</code></pre>
<h2 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h2><pre><code class="lang-html">&lt;button id=&quot;btn01&quot;&gt;点我一下&lt;/button&gt;
    &lt;script&gt;
        let btn01 = document.getElementById(&quot;btn01&quot;)
        /*
        通过这种方式绑定的点击事件，只能绑定一个
         */

        btn01.onclick = function() &#123;
            console.log(&quot;@&quot;);
        &#125;

        /*btn01.onclick = function() &#123;
            console.log(&quot;!&quot;);
        &#125;*/

        /*addEventListener()
        * 通过这个方法也可以为元素绑定响应函数
        * 参数：
        *   1.事件的字符串,不要on
        *   2.回调函数
        *   3.是否在捕获阶段触发事件，需要一个布尔值，一般都传false
        * */
        btn01.addEventListener(&quot;click&quot;,function () &#123;
            alert(1)
        &#125;)

        btn01.addEventListener(&quot;click&quot;,function () &#123;
            alert(2)
        &#125;)
    &lt;/script&gt;
</code></pre>
<h2 id="事件传播"><a href="#事件传播" class="headerlink" title="事件传播"></a>事件传播</h2><pre><code class="lang-html">&lt;div id=&quot;box1&quot;&gt;
    &lt;div id=&quot;box2&quot;&gt;
        &lt;div id=&quot;box3&quot;&gt;&lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
&lt;script&gt;
    /*
    * 事件的传播
    *   关于事件的传播，网景公司和微软公司有着不同的理解
    *   微软公司认为事件应该是由内向外传播，也就是当事件触发时，应该先触发当前元素上的事件
    *   然后再向当前元素的祖先元素上传播，也就是说事件应该在冒泡阶段再执行
    *
    *   网景公司认为事件应该是由外向内传播的，也就是当前时间触发时，应该先触发当前元素的最外层
    *   的事件，然后再向内传播给后代元素
    *   W3C综合了两个公司的方案，将事件传播分成了3个阶段
    *   1.在捕获阶段，从最外层的祖先元素，向目标元素进行事件的捕获，但是默认不触发事件
    *   2.目标阶段，事件捕获到目标元素，开始触发事件
    *   3.冒泡阶段，事件从目标元素向外开始触发事件
    * IE8及以下的浏览器中没有捕获阶段*/
    let btn1 = document.getElementById(&quot;box1&quot;)
    let btn2 = document.getElementById(&quot;box2&quot;)
    let btn3 = document.getElementById(&quot;box3&quot;)
    btn1.onclick = function () &#123;
        alert(&quot;1&quot;);
    &#125;
    btn2.onclick = function () &#123;
        alert(&quot;2&quot;);
    &#125;
    btn3.onclick = function () &#123;
        alert(&quot;3&quot;);
    &#125;
&lt;/script&gt;
</code></pre>
<h2 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h2><pre><code class="lang-html">&lt;input type=&quot;text&quot; id=&quot;box1&quot;&gt;
    &lt;script&gt;
        let box1 = document.getElementById(&quot;box1&quot;)
        box1.onkeydown = function (event) &#123;
            console.log(&quot;键盘按下了...&quot;)
            console.log(event.key)
        &#125;
    &lt;/script&gt;
</code></pre>
<p>把几个键盘事件记住就行</p>
<h1 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h1><p>BOM即浏览器对象，BOM可以使我们通过JS来操作浏览器，在BOM中为我们提供了一组对象，用来完成对浏览器的操作。</p>
<p>window:代表的是整个浏览器，同时window也是网页中的全局对象</p>
<p>Navigator:代表的是当前浏览器的信息，通过该对象可以来识别不同的浏览器</p>
<p>Location:代表当前浏览器的地址栏信息,通过Location可以获取地址栏信息，或者操作浏览器页面跳转</p>
<p>History:代表浏览器的历史记录，可以通过该对象来操作浏览器的历史记录，由于隐私原因，该对象不能获取到具体的历史记录</p>
<p>Screen：代表用户的屏幕的信息，通过该对象可以获取到用户的显示器的相关的信息</p>
<h1 id="定时作用"><a href="#定时作用" class="headerlink" title="定时作用"></a>定时作用</h1><p>案例,鼠标事件控制div盒子移动</p>
<pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;style&gt;
        #box1&#123;
            width: 100px;
            height: 100px;
            background-color: red;
            position: absolute;
        &#125;
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;box1&quot;&gt;&lt;/div&gt;
    &lt;script&gt;
        let box1 = document.getElementById(&quot;box1&quot;);
        let dir = &#39;&#39;;
        let speed = 10;
        setInterval(() =&gt; &#123;
            switch (dir) &#123;
                case &quot;ArrowUp&quot;:
                    box1.style.top = box1.offsetTop - speed + &quot;px&quot;;
                    break;
                case &quot;ArrowDown&quot;:
                    box1.style.top = box1.offsetTop + speed + &quot;px&quot;;
                    break;
                case &quot;ArrowRight&quot;:
                    box1.style.left = box1.offsetLeft + speed + &quot;px&quot;;
                    break;
                case &quot;ArrowLeft&quot;:
                    box1.style.left = box1.offsetLeft - speed + &quot;px&quot;;
                    break;
            &#125;
        &#125;,30)
        document.onkeydown = function (event) &#123;
            if (event.ctrlKey) &#123;
                speed = 50;
            &#125;else &#123;
                speed = 10;
            &#125;
            dir = event.key;
        &#125;
        document.onkeyup = function () &#123;
            dir = &#39;&#39;;
        &#125;
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h1 id="类的操作"><a href="#类的操作" class="headerlink" title="类的操作"></a>类的操作</h1><pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;style&gt;
        .b1 &#123;
            width: 100px;
            height: 100px;
            background-color: red;
        &#125;
        .b2&#123;
            width: 200px;
            background-color: orange;
        &#125;
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;button id=&quot;btn01&quot;&gt;点我修改box的样式&lt;/button&gt;
    &lt;br&gt;&lt;/br&gt;
    &lt;div id=&quot;box1&quot; class=&quot;b1&quot;&gt;&lt;/div&gt;
&lt;script&gt;
    let btn01 = document.getElementById(&quot;btn01&quot;);
    let box1 = document.getElementById(&quot;box1&quot;);
    btn01.onclick = function () &#123;
        /*
        * 通过style属性来修改元素的样式，每修改一个样式，浏览器就要重新渲染一次页面
        * 这样执行的性能是比较差的*/
        /*box1.style.width = &quot;200px&quot;;
        box1.style.height = &quot;300px&quot;;
        box1.style.backgroundColor = &quot;orange&quot;;*/

        /*我们可以通过修改元素的class属性来间接的修改样式*/
        // box1.className = &quot;b2&quot;;

        /*要适用两种类，可以追加,但是会追加多个属性，需要做个判断*/
        let reg = /\bb2\b/;
        if (!reg.test(box1.className)) &#123;
            box1.className += &quot; &quot; + &quot;b2&quot;;
        &#125;

        /*要删除某个类，直接将其替换置空就行*/
    &#125;

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h1 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h1><p>JS中的对象只有JS自己认识，其他的语言都不认识。</p>
<p>JSON就是一个特殊格式的字符串，这个字符串可以被任意的语言所识别，并且可以转换成任意语言中的对象，JSON在开发中主要用来数据的交互。</p>
<p>JSON- JavaScript Object Notation</p>
<p>JSON和JS对象的格式一样，只不过JSON字符串中的属性名必须加双引号，其他的和JS语法一致。</p>
<p>JSON分类</p>
<p>1.对象{}</p>
<p>2.数组[]</p>
<p>JSON.parse(json)可以将JSON转换成js对象</p>
<p>JSON.stringify()可以将JS对象转换成JSON字符串</p>
]]></content>
  </entry>
  <entry>
    <title>css细节</title>
    <url>/2021/08/17/%E5%89%8D%E7%AB%AF/css%E7%BB%86%E8%8A%82/</url>
    <content><![CDATA[<h1 id="div"><a href="#div" class="headerlink" title="div"></a>div</h1><p>div设置100%依赖于父级，back-img要占满整个屏幕设置background-size: cover; background-repeat: no-repeat;</p>
<p>要固定div的相对位置，使用absolute属性</p>
]]></content>
  </entry>
  <entry>
    <title>vue学习</title>
    <url>/2021/07/24/%E5%89%8D%E7%AB%AF/vue%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="入门介绍"><a href="#入门介绍" class="headerlink" title="入门介绍"></a>入门介绍</h1><p>Vue是一套用于构建用户界面的渐进式JavaScript框架</p>
<p>采用组件化模式，提高代码复用率，且让代码更好维护</p>
<p>传统采用命令式编码，需要编码人员自己DOM，声明式编码可以直接写入</p>
<p>使用虚拟DOM +优秀的Diff算法，尽量复用DOM节点</p>
<p>学习Vue之间要掌握的JavaScript基础知识:</p>
<p>ES6语法规范、ES6模板化、包管理器、原型、原型链、数组常用方法、axios、promise</p>
<h1 id="vue2细节"><a href="#vue2细节" class="headerlink" title="vue2细节"></a>vue2细节</h1><h2 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h2><p>v-bind可以动态绑定，将Vue和html属性绑定</p>
<p>v-model可以完成双向绑定,但是v-model只能用在表单类元素上（输入类元素）</p>
<p>v-on:click简写为@click v-moel:value简写为v-model</p>
<p>vue参考了MVVM模型，M：model对应data中的数据 V:view模板  VM:viewModer：vue实例对象</p>
<h2 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h2><pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
  &lt;title&gt;Document&lt;/title&gt;
  &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;
  &lt;style&gt;
    *&#123;
      margin-top: 20px;
    &#125;
    .demo1&#123;
      height: 50px;
      background-color: blue;
    &#125;
    .box1&#123;
      padding: 5px;
      background-color: pink;
    &#125;
    .box2&#123;
      padding: 5;
      background-color: orange;
    &#125;
    .list&#123;
      width: 200px;
      height: 200px;
      background-color: deeppink;
      overflow: auto;
    &#125;
    .list li&#123;
      height: 100px;
    &#125;
  &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;!--
    Vue中的事件修饰符：
    1.prevent: 阻止默认事件
    2.stop: 阻止事件冒泡
    3.once: 事件只触发一次
    4.capture: 使用事件的捕获方式
    5.self: 只有event.target是当前操作的元素时才触发事件
    6.passive: 事件的默认行为立即执行，无需等待事件回调执行完毕
  --&gt;
  &lt;div id=&quot;root&quot;&gt;
    &lt;h2&gt;欢迎来到&#123;&#123;name&#125;&#125;学习&lt;/h2&gt;
    &lt;!-- 组织默认事件 --&gt;
    &lt;a href=&quot;http://zzygeo.cn&quot; @click.prevent=&quot;showInfo&quot;&gt;点我提示信息&lt;/a&gt;
    &lt;!-- 阻止事件冒泡 --&gt;
    &lt;div class=&quot;demo1&quot; @click=&quot;showInfo&quot;&gt;
      &lt;button @click.stop=&quot;showInfo&quot;&gt;点我提示信息&lt;/button&gt;
    &lt;/div&gt;
    &lt;!-- 事件只触发一次 --&gt;
    &lt;button @click.once=&quot;showInfo&quot;&gt;点我提示信息&lt;/button&gt;
    &lt;!-- 使用事件的捕获模式,捕获阶段是由外往内的，冒泡阶段是由内往外的，先捕获再冒泡,capture就是让其
    在捕获阶段就执行
    --&gt;
    &lt;div class=&quot;box1&quot; @click.capture=&quot;showMessage(1)&quot;&gt;
      div1
      &lt;div class=&quot;box2&quot; @click=&quot;showMessage(2)&quot;&gt;
        div2
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;!-- 只有event.target是当前操作的元素时才触发事件,button导致的冒泡不会影响div --&gt;
    &lt;div class=&quot;demo1&quot; @click.self=&quot;showInfo&quot;&gt;
      &lt;button @click=&quot;showInfo&quot;&gt;点我提示信息&lt;/button&gt;
    &lt;/div&gt;
    &lt;!-- 事件的默认行为立即执行，无需等待事件回调执行完毕 --&gt;
    &lt;ul @wheel.passive=&quot;demo&quot; class=&quot;list&quot;&gt;
      &lt;li&gt;1&lt;/li&gt;
      &lt;li&gt;2&lt;/li&gt;
      &lt;li&gt;3&lt;/li&gt;
      &lt;li&gt;4&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/div&gt;
&lt;/body&gt;
  &lt;script&gt;
    Vue.config.productionTip = false
    const vm = new Vue(&#123;
      data:function()&#123;
        return&#123;
          name:&#39;尚硅谷&#39;
        &#125;
      &#125;,
      methods:&#123;
        showInfo:function(e)&#123;
          // e.preventDefault()
          alert(&#39;同学你好&#39;)
        &#125;,
        showMessage:function(msg)&#123;
        console.log(msg);
      &#125;,
      demo:function()&#123;//先等待回调，然后再执行，这里会浪费大量的时间
        for (let index = 0; index &lt; 100000; index++) &#123;
          console.log(&#39;#&#39;);
        &#125;
        console.log(&#39;@&#39;);
      &#125;
      &#125;
    &#125;)
    vm.$mount(&#39;#root&#39;)
  &lt;/script&gt;
&lt;/html&gt;
</code></pre>
<h2 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h2><pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
  &lt;title&gt;Document&lt;/title&gt;
  &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;!-- 
    1.Vue中常见的按键别名:
    回车=&gt;enter
    删除=&gt;delete
    退出=&gt;esc
    空格=&gt;space
    换行=&gt;tab（特殊，配合keydown使用）
    上=&gt;up
    下=&gt;down
    左=&gt;left
    右=&gt;right
    2.Vue未提供别名的按键，可以使用原始的key值去绑定，但注意要转成keytab-case（短横线命名）

    3.系统修饰键（用法特殊）：ctrl、alt、shift、meta
    1) 配合keyup使用：按下修饰键的同时，再按下其他键，随后释放其他件，时间才被触发
    2) 配合keydown使用：正常触发事件

    4.系统修饰按键后还可以跟指定按键
   --&gt;
  &lt;div id=&quot;root&quot;&gt;
    &lt;h2&gt;欢迎来到&#123;&#123;name&#125;&#125;来学习&lt;/h2&gt;
    &lt;input type=&quot;text&quot; placeholder=&quot;按下回车提示输入&quot; @keyup.ctrl.y=&quot;showInfo&quot;&gt;
  &lt;/div&gt;
&lt;/body&gt;
  &lt;script&gt;
    Vue.config.productionTip = false;
    // Vue.config.keyCodes.huiche = 13; //也可以自定义按键
    const vm = new Vue(&#123;
      data:function()&#123;
        return&#123;
          name:&#39;Vue&#39;
        &#125;
      &#125;,
      methods:&#123;
        showInfo:function(e)&#123;//这个e是键盘事件类
          // if (e.keyCode !== 13) return //这个可以用enter代替
          console.log(e.target.value);
        &#125;
      &#125;
    &#125;);
    vm.$mount(&#39;#root&#39;);
  &lt;/script&gt;
&lt;/html&gt;
</code></pre>
<h2 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h2><pre><code class="lang-html">computed:&#123;
    fullName:&#123;
    //fullName被读取时，get就会被调用，且返回值就会作为fullName的值
    //get什么时候调用 1.初次读取fullName时  2.所依赖的数据发生变化时，这里用了缓存
    get:function()&#123;//计算属性   Vue在这里把this指给了vm这个对象
        console.log(&#39;set被调用了&#39;);
        return this.firstName + &#39;-&#39; + this.lastName; 
    &#125;,
    //set在fullName被修改的时候被调用
    set:function(value)&#123;
        console.log(&#39;set&#39;, value);
        const arr = value.split(&#39;-&#39;);
        this.firstName = arr[0];
        this.lastName = arr[1];
    &#125;
&#125;
</code></pre>
<h2 id="监视属性"><a href="#监视属性" class="headerlink" title="监视属性"></a>监视属性</h2><p>在监视对象里的值改变时，默认的浅层监视监测不到数据变化，因此不能重新解析模板，需要开启深度监视deep:true</p>
<p>watch和computed在改变属性时候的区别</p>
<p>watch可以进行异步计算，如时间延迟函数</p>
<h2 id="class与style绑定"><a href="#class与style绑定" class="headerlink" title="class与style绑定"></a>class与style绑定</h2><pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
  &lt;title&gt;Document&lt;/title&gt;
  &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;
  &lt;style&gt;
    .basic&#123;
      height: 100px;
      width: 200px;
      border: 1px solid black;
    &#125;
    .happy&#123;
      border: 4px solid red;
      background-color: rgba( 255, 255, 0, 0.644);
      background: linear-gradient(30deg, yellow,pink,orange,yellow);
    &#125;
    .sad&#123;
      border: 4px solid green;
      background-color: rgba( 255, 255, 0, 0.644);
      background: linear-gradient(30deg, yellow,pink,orange,yellow);
    &#125;
    .normal&#123;
      border: 4px solid blue;
      background-color: rgba( 255, 255, 0, 0.644);
      background: linear-gradient(30deg, yellow,pink,orange,yellow);
    &#125;
    .color1&#123;
      background-color: antiquewhite;
    &#125;
    .color2&#123;
      background-color: aqua;
    &#125;
    .color3&#123;
      background-color: chartreuse;
    &#125;
  &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div id=&quot;root&quot;&gt;
    &lt;!-- 绑定class样式--字符串写法，适用于：样式的类名不确定，需要动态指定 --&gt;
    &lt;div  class=&quot;basic&quot; :class=&quot;mood&quot; @click=&quot;changeMood&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt; &lt;br&gt; &lt;br&gt;

    &lt;!-- 绑定class样式--数组写法,适用于：要绑定的样式个数不确定，名字也不确定 --&gt;
    &lt;div  class=&quot;basic&quot; :class=&quot;classArr&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt; &lt;br&gt; &lt;br&gt;

    &lt;!-- 绑定class样式--对象写法,适用于：要绑定的样式个数确定，名字也确定，但要动态决定用不用 --&gt;
    &lt;div  class=&quot;basic&quot; :class=&quot;classObj&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt; &lt;br&gt; &lt;br&gt;

    &lt;!-- 绑定style --&gt;
    &lt;div  class=&quot;basic&quot; :style=&quot;styleObj&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt;
  &lt;/div&gt;
&lt;/body&gt;
  &lt;script&gt;
    Vue.config.productionTip = false;
    const vm = new Vue(&#123;
      data:function()&#123;
        return&#123;
          name:&#39;尚硅谷&#39;,
          mood:&#39;happy&#39;,
          classArr:[&#39;color1&#39;, &#39;color2&#39;, &#39;color3&#39;],
          classObj:&#123;
            color1:false,
            color2:false
          &#125;,
          styleObj:&#123;
            fontSize:&#39;40px&#39;
          &#125;
        &#125;
      &#125;,
      methods:&#123;
        changeMood()&#123;
          var arr = [&#39;happy&#39;, &#39;sad&#39;, &#39;normal&#39;];
          var index = Math.floor(Math.random() * 3);
          this.mood = arr[index];
        &#125;
      &#125;
    &#125;);
    vm.$mount(&#39;#root&#39;)
  &lt;/script&gt;
&lt;/html&gt;
</code></pre>
<h2 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h2><pre><code class="lang-html">&lt;!-- 使用v-show做条件渲染,隐藏，频率高的情况下使用 --&gt;
&lt;h2 v-show=&quot;false&quot;&gt;欢迎来到&#123;&#123;name&#125;&#125;&lt;/h2&gt;

&lt;!-- 使用v-if做条件渲染，彻底删除，频率低的情况下使用 --&gt;
&lt;h2 v-if=&quot;false&quot;&gt;欢迎来到&#123;&#123;name&#125;&#125;&lt;/h2&gt;

&lt;!-- v-else-if与v-else --&gt;
&lt;!-- 需要连着写才有效果 --&gt;
&lt;h2 v-if=&quot;n === 1&quot;&gt;n=1&lt;/h2&gt;
&lt;h2 v-else-if=&quot;n == 2&quot;&gt;n=2&lt;/h2&gt;
&lt;h2 v-else-if=&quot;n == 3&quot;&gt;n=3&lt;/h2&gt;
&lt;h2 v-else&gt;哈哈&lt;/h2&gt;
&lt;button @click=&quot;n++&quot;&gt;点我n+1&lt;/button&gt;

&lt;!-- template可以当div盒子用，但在渲染的时候又不影响页面的布局，但它只能配合v-if用 --&gt;
</code></pre>
<h2 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h2><pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
  &lt;title&gt;Document&lt;/title&gt;
  &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div id=&quot;root&quot;&gt;
    &lt;!-- 遍历数组 --&gt;
    &lt;h2&gt;人员列表&lt;/h2&gt;
    &lt;ul&gt;
      &lt;!-- p是值，index是索引,给每个li分不同的id --&gt;
      &lt;li v-for=&quot;(p,index) in personArr&quot; :key=&quot;index&quot;&gt;
        &#123;&#123;p.name&#125;&#125;-&#123;&#123;p.age&#125;&#125;
      &lt;/li&gt;
    &lt;/ul&gt;
    &lt;br&gt;
    &lt;!-- 遍历对象 --&gt;
    &lt;h2&gt;汽车属性&lt;/h2&gt;
    &lt;ul&gt;
      &lt;!-- 第一个是val,第二个是key --&gt;
      &lt;li v-for=&quot;(val,key) in Car&quot; :key=&quot;key&quot;&gt;
        &#123;&#123;key&#125;&#125; - &#123;&#123;val&#125;&#125;
      &lt;/li&gt;
    &lt;/ul&gt;
    &lt;!-- 遍历字符串 --&gt;
    &lt;h2&gt;遍历字符串&lt;/h2&gt;
    &lt;ul&gt;
      &lt;li v-for=&quot;(val,index) in str&quot; :key=&quot;index&quot;&gt;
        &#123;&#123;val&#125;&#125;-&#123;&#123;index&#125;&#125;
      &lt;/li&gt;
    &lt;/ul&gt;

    &lt;!-- 遍历数字 --&gt;
    &lt;h2&gt;遍历数字&lt;/h2&gt;
    &lt;ul&gt;
      &lt;li v-for=&quot;(num,index) in 6&quot; :key=&quot;index&quot;&gt;
        &#123;&#123;index&#125;&#125;-&#123;&#123;num&#125;&#125;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/div&gt;
&lt;/body&gt;
  &lt;script&gt;
    Vue.config.productionTip = false;
    const vm = new Vue(&#123;
      data:function()&#123;
        return&#123;
          personArr:[
            &#123;id:&#39;001&#39;, name:&#39;张三&#39;,age:18&#125;,
            &#123;id:&#39;002&#39;, name:&#39;李四&#39;,age:18&#125;,
            &#123;id:&#39;003&#39;, name:&#39;王五&#39;,age:19&#125;    
          ],
          Car:&#123;
            name:&#39;奥迪A8&#39;,
            price:&#39;70万&#39;,
            color:&#39;黑色&#39;
          &#125;,
          str:&#39;hello&#39;
        &#125;
      &#125;
    &#125;);
    vm.$mount(&#39;#root&#39;)
  &lt;/script&gt;
&lt;/html&gt;
</code></pre>
<p>key的原理</p>
<p><img src="https://raw.githubusercontent.com/zzygeo/images/master/index作为key.7fprri03nn40.png" alt="index作为key"></p>
<p><img src="https://raw.githubusercontent.com/zzygeo/images/master/id作为key.79a32p8aifk0.png" alt="id作为key"></p>
<pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
  &lt;title&gt;Document&lt;/title&gt;
  &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div id=&quot;root&quot;&gt;
    &lt;!-- 
      虚拟DOM发生改变会存在对比算法，虚拟DOM中内容没变，直接使用之间的真实DOM
      若虚拟DOM中内容变了，则生成新的真实DOM，随后替换掉页面中之前的真实DOM
      所以对数据不进行逆序添加、逆序删除等操作的时候，使用index作为key是可以的，
      一般最好使用每条数据的唯一标识作为key
     --&gt;
    &lt;!-- 遍历数组 --&gt;
    &lt;h2&gt;人员列表&lt;/h2&gt;
    &lt;button @click=&quot;add&quot;&gt;点击&lt;/button&gt;
    &lt;ul&gt;
      &lt;li v-for=&quot;(p,index) in personArr&quot; :key=&quot;index&quot;&gt;
        &#123;&#123;p.name&#125;&#125;-&#123;&#123;p.age&#125;&#125;&lt;input type=&quot;text&quot;&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/div&gt;
&lt;/body&gt;
  &lt;script&gt;
    Vue.config.productionTip = false;
    const vm = new Vue(&#123;
      data:function()&#123;
        return&#123;
          personArr:[
            &#123;id:&#39;001&#39;, name:&#39;张三&#39;,age:18&#125;,
            &#123;id:&#39;002&#39;, name:&#39;李四&#39;,age:18&#125;,
            &#123;id:&#39;003&#39;, name:&#39;王五&#39;,age:19&#125;    
          ]
        &#125;
      &#125;,
      methods:&#123;
        add()&#123;
          const  p = &#123;id:&quot;004&quot;, name:&quot;老刘&quot;,age:30&#125;;
          this.personArr.unshift(p);
        &#125;
      &#125;
    &#125;);
    vm.$mount(&#39;#root&#39;)
  &lt;/script&gt;
&lt;/html&gt;
</code></pre>
<p>列表过滤：</p>
<pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
  &lt;title&gt;Document&lt;/title&gt;
  &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;!-- watch实现 --&gt;
  &lt;!-- &lt;div id=&quot;root&quot;&gt;
    &lt;h2&gt;人员列表&lt;/h2&gt;
    &lt;input type=&quot;text&quot; placeholder=&quot;请输入名字&quot; v-model=&quot;keyWord&quot;&gt;
    &lt;ul&gt;
      &lt;li v-for=&quot;(p, index) in filPersonArr&quot; :key=&quot;p.id&quot;&gt;
        &#123;&#123;p.name&#125;&#125;-&#123;&#123;p.age&#125;&#125;-&#123;&#123;p.sex&#125;&#125;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/div&gt;
&lt;/body&gt;
  &lt;script&gt;
    Vue.config.productionTip = false;
    const vm = new Vue(&#123;
      data:function()&#123;
        return&#123;
          personArr:[
            &#123;name:&#39;马冬梅&#39;, age:19, sex:&#39;女&#39;,id:&#39;001&#39;&#125;,
            &#123;name:&#39;周冬雨&#39;, age:20, sex:&#39;女&#39;,id:&#39;002&#39;&#125;,
            &#123;name:&#39;周杰伦&#39;, age:21, sex:&#39;男&#39;,id:&#39;003&#39;&#125;,
            &#123;name:&#39;温兆伦&#39;, age:22, sex:&#39;男&#39;,id:&#39;004&#39;&#125;
          ],
          keyWord:&#39;&#39;,
          filPersonArr:[]
        &#125;
      &#125;,
      watch:&#123;
        keyWord:&#123;
          immediate:true,
          handler(newVal)&#123;
            this.filPersonArr = this.personArr.filter((p)=&gt;&#123;
            return p.name.indexOf(newVal) &gt; -1;
            &#125;)
        &#125;    
        &#125;
      &#125;
    &#125;);
    vm.$mount(&#39;#root&#39;) --&gt;
    &lt;!-- computed实现 --&gt;
    &lt;div id=&quot;root&quot;&gt;
      &lt;h2&gt;人员列表&lt;/h2&gt;
      &lt;input type=&quot;text&quot; placeholder=&quot;请输入名字&quot; v-model=&quot;keyWord&quot;&gt;
      &lt;ul&gt;
        &lt;li v-for=&quot;(p, index) in filPersonArr&quot; :key=&quot;p.id&quot;&gt;
          &#123;&#123;p.name&#125;&#125;-&#123;&#123;p.age&#125;&#125;-&#123;&#123;p.sex&#125;&#125;
        &lt;/li&gt;
      &lt;/ul&gt;
    &lt;/div&gt;
  &lt;/body&gt;
    &lt;script&gt;
      Vue.config.productionTip = false;
      const vm = new Vue(&#123;
        data:function()&#123;
          return&#123;
            personArr:[
              &#123;name:&#39;马冬梅&#39;, age:19, sex:&#39;女&#39;,id:&#39;001&#39;&#125;,
              &#123;name:&#39;周冬雨&#39;, age:20, sex:&#39;女&#39;,id:&#39;002&#39;&#125;,
              &#123;name:&#39;周杰伦&#39;, age:21, sex:&#39;男&#39;,id:&#39;003&#39;&#125;,
              &#123;name:&#39;温兆伦&#39;, age:22, sex:&#39;男&#39;,id:&#39;004&#39;&#125;
            ],
            keyWord:&#39;&#39;
          &#125;
        &#125;,
        computed:&#123;
          filPersonArr:&#123;
            get()&#123;
              return this.personArr.filter((p)=&gt;&#123;
                return p.name.indexOf(this.keyWord) &gt; -1;
              &#125;)
            &#125;
          &#125;
        &#125;
      &#125;);
      vm.$mount(&#39;#root&#39;)
  &lt;/script&gt;
&lt;/html&gt;
</code></pre>
<p>列表排序</p>
<pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
  &lt;title&gt;Document&lt;/title&gt;
  &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div id=&quot;root&quot;&gt;
    &lt;h2&gt;人员列表&lt;/h2&gt;
    &lt;input type=&quot;text&quot; placeholder=&quot;请输入名字&quot; v-model=&quot;keyWord&quot;&gt;
    &lt;button @click=&quot;order=1&quot;&gt;年龄升序&lt;/button&gt;
    &lt;button @click=&quot;order=2&quot;&gt;年龄降序&lt;/button&gt;
    &lt;button @click=&quot;order=0&quot;&gt;原顺序&lt;/button&gt;
    &lt;ul&gt;
      &lt;li v-for=&quot;(p, index) in filPersonArr&quot; :key=&quot;p.id&quot;&gt;
        &#123;&#123;p.name&#125;&#125;-&#123;&#123;p.age&#125;&#125;-&#123;&#123;p.sex&#125;&#125;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/div&gt;
&lt;/body&gt;
  &lt;script&gt;
    Vue.config.productionTip = false;
    const vm = new Vue(&#123;
      data:function()&#123;
        return&#123;
          personArr:[
            &#123;name:&#39;马冬梅&#39;, age:19, sex:&#39;女&#39;,id:&#39;001&#39;&#125;,
            &#123;name:&#39;周冬雨&#39;, age:21, sex:&#39;女&#39;,id:&#39;002&#39;&#125;,
            &#123;name:&#39;周杰伦&#39;, age:20, sex:&#39;男&#39;,id:&#39;003&#39;&#125;,
            &#123;name:&#39;温兆伦&#39;, age:22, sex:&#39;男&#39;,id:&#39;004&#39;&#125;
          ],
          keyWord:&#39;&#39;,
          order:0
        &#125;
      &#125;,
      computed:&#123;
        filPersonArr:&#123;
          get()&#123;
            const arr = this.personArr.filter((p)=&gt;&#123;
              return p.name.indexOf(this.keyWord) &gt; -1;
            &#125;)
            if (this.order)&#123;
              arr.sort((a, b)=&gt;&#123;
                return this.order === 1 ? a.age - b.age : b.age - a.age;
              &#125;)
            &#125;
            return arr;
          &#125;
        &#125;
      &#125;,
    &#125;);
    vm.$mount(&#39;#root&#39;)
&lt;/script&gt;
&lt;/html&gt;
</code></pre>
<h2 id="Vue监测对象以及数组"><a href="#Vue监测对象以及数组" class="headerlink" title="Vue监测对象以及数组"></a>Vue监测对象以及数组</h2><p>Vue是通过一个递归给data里面的数据增加set和get方法，想给Vue添加一个reactive属性,可以调用Vue.set或者vm.$set，但给Vue添加reactive属性时，不能是Vue或者Vue._date</p>
<p>对数组进行监测的时候，对直接进行赋值所进行的修改并没有提供set和get方法，而是对操作数组的7组方法进行了包裹，从而在进行虚拟DOM那一套，当然也可以通过Vue.set和vm.$set去数组去进行修改</p>
<pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
  &lt;title&gt;Document&lt;/title&gt;
  &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;!--  --&gt;
  &lt;div id=&quot;root&quot;&gt;
    &lt;h1&gt;学生信息&lt;/h1&gt;
    &lt;button @click=&quot;student.age++&quot;&gt;年龄+1岁&lt;/button&gt; &lt;br&gt;
    &lt;button @click=&quot;addSex&quot;&gt;添加性别，默认值：男&lt;/button&gt; &lt;br&gt;
    &lt;button @click=&quot;addFriend&quot;&gt;在列表首位添加一个朋友&lt;/button&gt; &lt;br&gt;
    &lt;button @click=&quot;replacename&quot;&gt;修改第一个朋友的名字为：张三&lt;/button&gt; &lt;br&gt;
    &lt;button @click=&quot;addHobby&quot;&gt;添加一个爱好&lt;/button&gt; &lt;br&gt;
    &lt;button @click=&quot;spliceHobby&quot;&gt;修改第一个爱好为：开车&lt;/button&gt; &lt;br&gt;
    &lt;button @click=&quot;remove&quot;&gt;过滤掉爱好中的抽烟&lt;/button&gt; &lt;br&gt;

    &lt;h3&gt;姓名：&#123;&#123;student.name&#125;&#125;&lt;/h3&gt;
    &lt;h3&gt;年龄：&#123;&#123;student.age&#125;&#125;&lt;/h3&gt;
    &lt;h3 v-if=&quot;student.sex&quot;&gt;性别：&#123;&#123;student.sex&#125;&#125;&lt;/h3&gt;
    &lt;h3&gt;爱好：&lt;/h3&gt;
    &lt;ul&gt;
      &lt;li v-for=&quot;(h,index) in student.hobby&quot; :key=&quot;index&quot;&gt;&#123;&#123;h&#125;&#125;&lt;/li&gt;
    &lt;/ul&gt;
    &lt;h3&gt;朋友们：&lt;/h3&gt;
    &lt;ul&gt;
      &lt;li v-for=&quot;(f,index) in student.friends&quot; :key=&quot;index&quot;&gt;&#123;&#123;f.name&#125;&#125;-&#123;&#123;f.age&#125;&#125;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/div&gt;
&lt;/body&gt;
  &lt;script&gt;
    Vue.config.productionTip = false;
    const vm = new Vue(&#123;
      data:function()&#123;
        return&#123;
          student:&#123;
            name:&#39;tom&#39;,
            age:18,
            hobby:[&#39;抽烟&#39;, &#39;喝酒&#39;, &#39;烫头&#39;],
            friends:[
              &#123;name:&#39;jerry&#39;,age:35&#125;,
              &#123;name:&#39;tony&#39;,age:36&#125;
            ]
          &#125;
        &#125;
      &#125;,
      methods:&#123;
        addSex()&#123;
          this.$set(this.student,&#39;sex&#39;,&#39;男&#39;);
        &#125;,
        addFriend()&#123;
          this.student.friends.unshift(&#123;name:&#39;jack&#39;,age:70&#125;);
        &#125;,
        replacename()&#123;
          this.student.friends[0].name = &#39;张三&#39;;
        &#125;,
        addHobby()&#123;
          this.student.hobby.push(&#39;打麻将&#39;);
        &#125;,
        spliceHobby()&#123;
          this.student.hobby.splice(0, 1, &#39;开车&#39;);
        &#125;,
        remove()&#123;
          this.student.hobby = this.student.hobby.filter((p)=&gt;&#123;
            return p !== &#39;抽烟&#39;;
          &#125;)
        &#125;
      &#125;
    &#125;);
    vm.$mount(&#39;#root&#39;)
  &lt;/script&gt;
&lt;/html&gt;
</code></pre>
<h2 id="收集表单数据"><a href="#收集表单数据" class="headerlink" title="收集表单数据"></a>收集表单数据</h2><pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
  &lt;title&gt;Document&lt;/title&gt;
  &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;!-- 
    收集表单数据:
    若: &lt;input type=&quot;text&quot;/&gt;, 则v-mode1收集的是value值，用户输入的就是value值。
    若: &lt;input type=&quot;radio&quot; /&gt;，则v-mode1收集的是value值，且要给标签配置value值。
    若: &lt;input type=&quot; checkbox&quot;/&gt;
      1.没有配置input的value属性，那么收集的就是checked (勾选or 未勾选，是布尔值)
      2.配置input的value属性:
        (1)v-mode1的初始值是非数组，那么收集的就是checked (勾选or未勾选，是布尔值)
        (2)v-mode1的初始值是数组，那么收集的的就是value组成的数组
    备注: v-mode1的 三个修饰符:
      lazy:失去焦点再收集数据
      number:输入字符串转为有效的数字
      trim:输入首尾空格过滤
   --&gt;
  &lt;div id=&quot;root&quot;&gt;
  &lt;form @submit.prevent=&quot;demo&quot;&gt;
    &lt;label for=&quot;name&quot; &gt;账号：&lt;/label&gt;
    &lt;input type=&quot;text&quot; id=&quot;name&quot; v-model.trim=&quot;userInfo.account&quot;&gt;
    &lt;br&gt;
    &lt;label for=&quot;password&quot; &gt;密码：&lt;/label&gt;
    &lt;input type=&quot;password&quot; id=&quot;password&quot; v-model=&quot;userInfo.password&quot;&gt;
    &lt;br&gt;
    &lt;label for=&quot;age&quot; &gt;年龄：&lt;/label&gt;
    &lt;!-- v-model也是有修饰符的 --&gt;
    &lt;input type=&quot;number&quot; id=&quot;age&quot; v-model.number=&quot;userInfo.age&quot;&gt;
    &lt;br&gt;
    性别：
    男&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;male&quot; v-model=&quot;userInfo.sex&quot;&gt;
    女&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;female&quot; v-model=&quot;userInfo.sex&quot;&gt;
    &lt;br&gt;
    爱好：
    学习&lt;input type=&quot;checkbox&quot; v-model=&quot;userInfo.hobby&quot; value=&quot;study&quot;&gt;
    打游戏&lt;input type=&quot;checkbox&quot; v-model=&quot;userInfo.hobby&quot; value=&quot;game&quot;&gt;
    吃饭&lt;input type=&quot;checkbox&quot; v-model=&quot;userInfo.hobby&quot; value=&quot;eat&quot;&gt;
    &lt;br&gt;
    所属校区
    &lt;select v-model=&quot;userInfo.city&quot;&gt;
      &lt;option value=&quot;&quot;&gt;请选择校区&lt;/option&gt;
      &lt;option value=&quot;bj&quot;&gt;北京&lt;/option&gt;
      &lt;option value=&quot;sh&quot;&gt;上海&lt;/option&gt;
      &lt;option value=&quot;sz&quot;&gt;深圳&lt;/option&gt;
    &lt;/select&gt;
    &lt;br&gt;
    其他信息：
    &lt;textarea v-model.lazy=&quot;userInfo.other&quot;&gt;&lt;/textarea&gt;
    &lt;br&gt;
    &lt;input type=&quot;checkbox&quot; v-model=&quot;userInfo.agree&quot;&gt; 阅读并接受&lt;a href=&quot;#&quot;&gt;《用户协议》&lt;/a&gt;
    &lt;button&gt;提交&lt;/button&gt;
  &lt;/form&gt;
  &lt;/div&gt;
&lt;/body&gt;
  &lt;script&gt;
    Vue.config.productionTip = false;
    const vm = new Vue(&#123;
      data:function()&#123;
        return&#123;
          userInfo:&#123;
            account:&#39;&#39;,
            password:&#39;&#39;,
            sex:&#39;male&#39;,
            hobby:[],
            city:&#39;bj&#39;,
            other:&#39;&#39;,
            agree:&#39;&#39;,
            age:0
          &#125;
        &#125;
      &#125;,
      methods:&#123;
        demo()&#123;
          console.log(JSON.stringify(this.userInfo));
        &#125;
      &#125;
    &#125;);
    vm.$mount(&#39;#root&#39;)
  &lt;/script&gt;
&lt;/html&gt;
</code></pre>
<h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
  &lt;title&gt;Document&lt;/title&gt;
  &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;../js/dayjs.min.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;!-- 
    过滤器:
    定义:对要显示的数据进行特定格式化后再显示(适用于一些简单逻辑的处理)。
    语法:
      1.注册过滤器: Vue.filter(name,callback)或new Vue&#123;filters:&#123;&#125;&#125;
      2.使用过滤器: &#123;&#123; XXX | 过滤器名&#125;&#125; 或v-bind:属性= &quot;xx| 过滤器名&quot;
    备注:
      1.过滤器也可以接收额外参数、多个过滤器也可以串联
      2.并没有改变原本的数据，是产生新的对应的数据

   --&gt;
  &lt;div id=&quot;root&quot;&gt;
    &lt;h2&gt;显示格式化后的时间&lt;/h2&gt;
    &lt;h3&gt;现在是：&#123;&#123;time | timeFormater&#125;&#125;&lt;/h3&gt;
    &lt;h3&gt;现在是：&#123;&#123;time | timeFormater('YYYY年MM月DD日')&#125;&#125;&lt;/h3&gt;
    &lt;!-- 这里的mySlice会接受timeFormater返回的值进行处理 --&gt;
    &lt;h3&gt;现在是：&#123;&#123;time | timeFormater('YYYY年MM月DD日') | mySlice&#125;&#125;&lt;/h3&gt;
    &lt;h3 :x=&quot;msg | mySlice&quot;&gt;演示过滤器在绑定语法中的使用&lt;/h3&gt;
  &lt;/div&gt;
&lt;/body&gt;
  &lt;script&gt;
    Vue.config.productionTip = false;
    //全局过滤器
    Vue.filter(&#39;mySlice&#39;,function(value)&#123;
      return value.slice(0, 4);
    &#125;)
    const vm = new Vue(&#123;
      data:function()&#123;
        return&#123;
          time:1627532248020, //时间戳
          msg:&#39;Hello World!&#39;
        &#125;
      &#125;,
      filters:&#123;
        timeFormater(value, str=&#39;YYYY年MM月DD日 HH:mm:ss&#39;)&#123;//返回值把整个框替换掉,value就是time值，在上面不写也会传入
          return dayjs(value).format(str);
        &#125;,
        //局部过滤器
        // mySlice(value)&#123;
        //   return value.slice(0,4);
        // &#125;
      &#125;
    &#125;);
    vm.$mount(&#39;#root&#39;);
  &lt;/script&gt;
&lt;/html&gt;
</code></pre>
<h2 id="内置指令"><a href="#内置指令" class="headerlink" title="内置指令"></a>内置指令</h2><pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
  &lt;title&gt;Document&lt;/title&gt;
  &lt;style&gt;
    [v-cloak]&#123;
      display: none;
    &#125;
  &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;!-- 
    v-text直接替换掉文本内容
    v-html直接结构的解析,存在安全性问题
    v-cloak指令(没有值) :
    1.本质是一个特殊属性，Vue实例创建完毕并接管容器后，会删掉v- cloak属性。
    2.使用css配合v-cloak可以解决网速慢时页面展示出( &#123;xx&#125; &#125;的问题。
    v-pre跳过其所在节点的编译过程，没有使用指令语法，没有使用插值语法的节点
   --&gt;
  &lt;div id=&quot;root&quot;&gt;
    &lt;div&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt;
    &lt;div v-cloak&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt;
    &lt;div v-text=&quot;name&quot;&gt;&lt;/div&gt; 
    &lt;div v-html=&quot;str&quot;&gt;&lt;/div&gt;
    &lt;h2 v-once=&quot;handle&quot;&gt;初始化的n值是：&#123;&#123;n&#125;&#125;&lt;/h2&gt; 
    &lt;h2&gt;当前的n值是：&#123;&#123;n&#125;&#125;&lt;/h2&gt;
    &lt;button @click=&quot;n++&quot;&gt;点我n+1&lt;/button&gt;
  &lt;/div&gt;
  &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;
&lt;/body&gt;
  &lt;script&gt;
    Vue.config.productionTip = false;
    const vm = new Vue(&#123;
      data:function()&#123;
        return&#123;
          name:&#39;尚硅谷&#39;,
          str:&#39;&lt;h2&gt;你好啊！&lt;/h2&gt;&#39;,
          n:1
        &#125;
      &#125;
    &#125;);
    vm.$mount(&#39;#root&#39;)
  &lt;/script&gt;
&lt;/html&gt;
</code></pre>
<h2 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h2><pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
  &lt;title&gt;Document&lt;/title&gt;
  &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div id=&quot;root&quot;&gt;
    &lt;h2&gt;当前的n值是：&lt;span v-text=&quot;n&quot;&gt;&lt;/span&gt;&lt;/h2&gt;
    &lt;!-- 指令名由几个单词组成的写法 --&gt;
    &lt;h2&gt;放大10倍的n值是：&lt;span v-big-number=&quot;n&quot;&gt;&lt;/span&gt;&lt;/h2&gt;
    &lt;button @click=&quot;n++&quot;&gt;点我n+1&lt;/button&gt;
    &lt;br&gt;
    &lt;input type=&quot;text&quot; v-fbind=&quot;n&quot;&gt;
  &lt;/div&gt;
&lt;/body&gt;
  &lt;script&gt;
    Vue.config.productionTip = false;
    //全局指令
    Vue.directive(&#39;fbind&#39;,&#123;
          bind(element, binding)&#123;//绑定时调用
            element.value = binding.value;
          &#125;,
          inserted(element,binding)&#123;//指令所在元素被插入页面时
            element.focus();
          &#125;,
          update(element, binding)&#123;//指令所在模板被重新解析时调用
            element.value = binding.value;
          &#125;
        &#125;)
      Vue.directive(&#39;big-number&#39;,function(element,binding)&#123;
        element.innerText = binding.value * 10;
      &#125;)
    const vm = new Vue(&#123;
      data:function()&#123;
        return&#123;
          n:1
        &#125;
      &#125;,
      //这个自定义指令是局部的
      // directives:&#123;
        //big函数何时被调用，1.指令与元素成功绑定时 2.指令所在的模板被重新解析时
        //这里面的this都是window，因为这些操作都是自己做的DOM
        // &#39;big-number&#39;(element,binding)&#123;
        //   element.innerText = binding.value * 10;
        // &#125;,
        // fbind:&#123;
        //   bind(element, binding)&#123;//绑定时调用
        //     element.value = binding.value;
        //   &#125;,
        //   inserted(element,binding)&#123;//指令所在元素被插入页面时
        //     element.focus();
        //   &#125;,
        //   update(element, binding)&#123;//指令所在模板被重新解析时调用
        //     element.value = binding.value;
        //   &#125;
        // &#125;
        // &#125;

    &#125;);
    vm.$mount(&#39;#root&#39;)
  &lt;/script&gt;
&lt;/html&gt;
</code></pre>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
  &lt;title&gt;Document&lt;/title&gt;
  &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;!-- 常用的生命周期钩子:
    1. mounted: 发送ajax请求、启动定时器、绑定自定义事件、订阅消息等[初始化操作]。
    2. beforeDestroy:清除定时器、解绑自定义事件、取消订阅消息等[收尾工作]。
    关于销毁Vue实例
    1.销毁后借助Vue开发者工具看不到任何信息。
    2.销毁后自定义事件会失效，但原生DOM事件依然有效。
    3.一般不会在beforeDestroy操作数据，因为即便操作数据，也不会再触发更新流程了。
 --&gt;
  &lt;div id=&quot;root&quot;&gt;
    &lt;h2&gt;当前的n值是：&#123;&#123;n&#125;&#125;&lt;/h2&gt;
    &lt;button @click=&quot;add&quot;&gt;点我n+1&lt;/button&gt;
    &lt;button @click=&quot;destroy&quot;&gt;点我销毁vm&lt;/button&gt;
  &lt;/div&gt;
&lt;/body&gt;
  &lt;script&gt;
    Vue.config.productionTip = false;
    new Vue(&#123;
      el:&#39;#root&#39;,
      data:function()&#123;
        return&#123;
          n:1
        &#125;
      &#125;,
      methods:&#123;
        add()&#123;
          this.n++;
        &#125;,
        destroy()&#123;
          this.$destroy();
        &#125;
      &#125;,
      beforeCreate() &#123;
        console.log(this);
      &#125;,
      created() &#123;
        console.log(this);
      &#125;,
      beforeMount() &#123;
        console.log(&#39;beforeMount&#39;);
      &#125;,
      mounted() &#123;
        console.log(&#39;mounted&#39;);
      &#125;,
      beforeUpdate() &#123;
        console.log(&#39;beforeUpdate&#39;);
      &#125;,
      updated() &#123;
        console.log(&#39;updated&#39;);
      &#125;,
      beforeDestroy() &#123;
        console.log(&#39;beforedestroy&#39;);
        console.log(this.n);
      &#125;,
      destroyed() &#123;
        console.log(&#39;destroy&#39;);
      &#125;,
    &#125;);
  &lt;/script&gt;
&lt;/html&gt;
</code></pre>
<h2 id="element-ui"><a href="#element-ui" class="headerlink" title="element-ui"></a>element-ui</h2><p>按需引入</p>
<pre><code class="lang-javascript">module.exports = &#123;
  presets: [
    &#39;@vue/cli-plugin-babel/preset&#39;,
    [&quot;@babel/preset-env&quot;, &#123; &quot;modules&quot;: false &#125;]
  ],
  plugins: [
    [
      &quot;component&quot;,
      &#123;
        &quot;libraryName&quot;: &quot;element-ui&quot;,
        &quot;styleLibraryName&quot;: &quot;theme-chalk&quot;
      &#125;
    ]
  ]
&#125;
</code></pre>
]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6-11</title>
    <url>/2021/09/13/%E5%89%8D%E7%AB%AF/ES6-11/</url>
    <content><![CDATA[<h1 id="let和const"><a href="#let和const" class="headerlink" title="let和const"></a>let和const</h1><ol>
<li><p>变量不能重复声明</p>
</li>
<li><p>块级作用域</p>
</li>
<li><p>不存在变量提升</p>
</li>
<li><p>不影响作用域链</p>
</li>
</ol>
<pre><code class="lang-js">&#123;
      let school = &quot;中山大学&quot;;
      function fn() &#123;
        console.log(school);
      &#125;
      fn();
    &#125;
</code></pre>
<p>案例</p>
<pre><code class="lang-js">let item = document.getElementsByClassName(&quot;item&quot;);
    for (var i = 0; i &lt; item.length; i++) &#123;
      //这个i是在全局作用域,回调函数在函数点击时触发，这时候i已经成3了
      item[i].onclick = function() &#123;
        item[i].style.backgroundColor = &quot;black&quot;;
      &#125;
    &#125;
</code></pre>
<p>const细节：</p>
<ol>
<li>一定要赋初始值</li>
<li>一般常量使用大写</li>
<li>常量的值不能修改</li>
<li>块级作用域</li>
<li>对于数组和对象的元素修改，不算做对常量的修改，不会报错</li>
</ol>
<h1 id="变量赋值"><a href="#变量赋值" class="headerlink" title="变量赋值"></a>变量赋值</h1><pre><code class="lang-js">const F4 = [&#39;大狗&#39;,&#39;二狗&#39;,&#39;死狗&#39;,&#39;狗贼&#39;];
let [xiao, liu, zhao, song] = F4;

console.log(xiao);
console.log(liu);
</code></pre>
<pre><code class="lang-js">const zhao = &#123;
      name: &#39;赵本山&#39;,
      age: 26,
      xiaopin: function() &#123;
        console.log(&#39;我可以演小品...&#39;);
      &#125;
    &#125;

let &#123; name, age, xiaopin&#125; = zhao;
console.log(name);
console.log(age);
console.log(xiaopin);
xiaopin();
</code></pre>
<h1 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h1><p>内容中可以直接出现换行符</p>
<p>变量拼接</p>
<pre><code class="lang-js">let star = &#39;张国荣&#39;;
let out = `$&#123;star&#125;是我最喜欢的歌手...`;
console.log(out);
</code></pre>
<h1 id="简化对象写法"><a href="#简化对象写法" class="headerlink" title="简化对象写法"></a>简化对象写法</h1><pre><code class="lang-js">/* ES6允许在大括号里，直接写入变量和函数，作为对象的属性和方法，
    这样书写更加简洁 */
    let name =&quot;中山大学&quot;;
    let change = function () &#123;
      console.log(&quot;我们可以改变你...&quot;);
    &#125;
    const school = &#123;
      name,
      change,
      improve() &#123;
        console.log(&quot;我们可以提高你的技能...&quot;);
      &#125;
    &#125;
    console.log(school);
</code></pre>
<h1 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h1><p>this是静态的,this始终指向函数声明时所在作用域下的this的值</p>
<pre><code class="lang-js">/* ES6允许使用[箭头]（=&gt;）定义函数 */
  //  let fn = function(a, b) &#123;
  //   return a + b;
  //  &#125;
   //调用函数
  //  let res = fn(1, 2);
  //  console.log(res);

  function getName() &#123;
    console.log(this.name);
  &#125;

  let getName2 = () =&gt; &#123;
    console.log(this.name);
  &#125;

  window.name = &quot;尚硅谷&quot;;
  const school = &#123;
    name: &quot;ATGUIGU&quot;
  &#125;

  //直接调用
  getName();  //尚硅谷
  getName2(); //尚硅谷

  getName.call(school); //ATGUIGU
  getName2.call(school);  //尚硅谷
</code></pre>
<p>不能作为构造函数实例化对象</p>
<pre><code class="lang-js"> //不能作为构造函数实例化对象
  //  let Person = function(name, age) &#123;
  //    this.name = name;
  //    this.age = age;
  //  &#125;
  //  let me = new Person(&quot;xiao&quot;, 30);
  //  console.log(me); //可行

  let Person = (name, age) =&gt; &#123;
    this.name = name;
    this.age = age;
  &#125;

  let me = new Person(&quot;xiao&quot;, 30);
  console.log(me); //Person is not a constructor
</code></pre>
<p>不能使用arguments变量</p>
<pre><code class="lang-js"> let fn = () =&gt; &#123;
     console.log(arguments);
   &#125;
   fn(100); //arguments is not defined
</code></pre>
<p>箭头函数的简写：</p>
<pre><code class="lang-js">//省略小括号，当形参有且只有一个的时候
    let add = num =&gt; &#123;
      return ++num;
    &#125;
    console.log(add(9));
</code></pre>
<pre><code class="lang-js">  //省略花括号,当代码体只有一条语句的时候,此时return语句也需要省略
    //而且语句的执行结果就是函数的返回值
    let pow = num =&gt;  num * num;
    console.log(pow(8));  //64
</code></pre>
<p>案例</p>
<pre><code class="lang-js">const arr = [1, 6, 9, 10, 100, 25];
      const res = arr.filter(item =&gt; item % 2 === 0 );
      console.log(res);
</code></pre>
<p>箭头函数适合与this无关的回调。定时器，数组的方法的回调。</p>
<p>箭头函数不适合与this有关的回调。事件回调，对象的方法。</p>
<h1 id="ES6允许给函数参数赋初值"><a href="#ES6允许给函数参数赋初值" class="headerlink" title="ES6允许给函数参数赋初值"></a>ES6允许给函数参数赋初值</h1><pre><code class="lang-js"> //ES6允许给函数参数赋初始值
      //1.形参初始值，具有默认值的参数，一般位置要靠后（潜规则）
      // function add(a, b, c = 10) &#123;
      //   return a + b + c;
      // &#125;
      // let res = add(1, 2);
      // console.log(res);

      //与结构赋值结合
      function connect(&#123; host = &quot;127.0.0.1&quot;, username, password, port &#125;) &#123;
        this.host = host;
        this.username = username;
        this.password = password;
        this.port = port;
      &#125;
      connect(&#123;
        host: &quot;localhost&quot;,
        username: &quot;root&quot;,
        password: &quot;root&quot;,
        port: &quot;port&quot;,
      &#125;);
</code></pre>
<h1 id="rest参数"><a href="#rest参数" class="headerlink" title="rest参数"></a>rest参数</h1><pre><code class="lang-js"> //ES6引入rest参数，用于获取函数的实参，用来代替arguments
      //ES5获取实参的方法
      // function date() &#123;
      //   console.log(arguments);
      // &#125;
      // date(1, 2, 3);

      //rest参数
      // function date(...args) &#123;
      //   console.log(args);
      // &#125;
      // date(1,2,3);

      //rest参数必须放到实参最后,不然会报错
      function date(a, b, ...args) &#123;
        console.log(a);
        console.log(b);
        console.log(args);
      &#125;
      date(1, 2, 3, 4, 5, 6, 7);
</code></pre>
<h1 id="拓展运算符"><a href="#拓展运算符" class="headerlink" title="拓展运算符"></a>拓展运算符</h1><pre><code class="lang-js">const tfboys = [&#39;易烊千玺&#39;,&#39;王源&#39;,&#39;王俊凯&#39;];

      function fn() &#123;
        console.log(arguments);
      &#125;
      fn(...tfboys);  //类似于将(a,b,c)，将每个值取出来作为实参
</code></pre>
<pre><code class="lang-js"> const person = [&#39;张三&#39;,&#39;李四&#39;,&#39;王五&#39;];
      const person2 = [&#39;赵六&#39;,&#39;黄七&#39;];
      const person3 = person.concat(person2);
      console.log(person3);
      const person4 = [...person, ...person2];
      console.log(person4);
</code></pre>
<h1 id="Symbol数据类型"><a href="#Symbol数据类型" class="headerlink" title="Symbol数据类型"></a>Symbol数据类型</h1><p>ES6引入了一种新的原始数据类型Symbol，表示独一无二的值。他是JS语言的第七种数据类型，是一种类似于字符串的数据类型。</p>
<p>特点：</p>
<p>Symbol的值是唯一的，用来解决命名冲突的问题。</p>
<p>Symbol值不能与其他数据进行运算。</p>
<p>Symbol定义的对象属性不能使用for…in循环遍历，但是可以使用Reflect.ownKeys来获取对象的所有键名。</p>
<pre><code class="lang-js">//创建stmbol
      let s = Symbol();
      console.log(s, typeof s);

      let s2 = Symbol(&#39;尚硅谷&#39;);
      let s3 = Symbol(&#39;尚硅谷&#39;);
      console.log(s2 === s3); //false

      let s4 = Symbol.for(&#39;尚硅谷&#39;);
      let s5 = Symbol.for(&#39;尚硅谷&#39;);
      console.log(s4 === s5); //true
</code></pre>
<p>案例：</p>
<pre><code class="lang-js"> let game = &#123;
        name: &quot;俄罗斯方块&quot;,
        up() &#123;
          console.log(&quot;@&quot;);
        &#125;,
        down() &#123;
          console.log(&quot;!&quot;);
        &#125;
      &#125;;
      //这么写是拿不到这个字符串的值的，必须来一个去接受它
      // game[Symbol(&#39;up&#39;)] = function() &#123;
      //   console.log(&#39;我可以改变形状...&#39;);
      // &#125;

      //必须拿一个去接受它，然后就能去调用了
      let up = Symbol();
      game[up] = function() &#123;
        console.log(&#39;我可以改变形状...&#39;);
      &#125;
      game[up]();
    //顺便体会下.方式和[]的差别
</code></pre>
<h2 id="Symbol内置属性"><a href="#Symbol内置属性" class="headerlink" title="Symbol内置属性"></a>Symbol内置属性</h2><p>symbol有一些内置属性，用于特定方法下进行使用，可以拓展方法的功能。</p>
<h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><p>迭代器是一种接口，为不同的数据结构提供统一的访问机制。任何数据结构只要部署Iterator接口，就可以完成遍历操作。</p>
<p>原生聚类Iterator接口的数据（可用for of遍历），主要是原型上存在Symbol.iterator的函数.</p>
<ol>
<li>Array</li>
<li>Arguments</li>
<li>Set</li>
<li>Map</li>
<li>String</li>
<li>TypedArray</li>
<li>NodeList</li>
</ol>
<p>工作原理：</p>
<ol>
<li>创建一个指针对象，指向当前数据结构的起始位置</li>
<li>第一次调用对象的next方法，指针自动指向数据结构的第一个成员</li>
<li>接下来不断调用next方法，指针一直往后移动，直到指向最后一个成员</li>
<li>每次调用next方法返回一个包含value和done属性的对象</li>
</ol>
<pre><code class="lang-js">const xiyou = [&#39;唐僧&#39;,&#39;孙悟空&#39;,&#39;猪八戒&#39;,&#39;沙僧&#39;];
      // //使用for...of遍历数组
      // for (let item of xiyou) &#123;
      //   console.log(item);
      // &#125;

      let iterator = xiyou[Symbol.iterator]();
      console.log(iterator);
      console.log(iterator.next());
      console.log(iterator.next());
      console.log(iterator.next());
      console.log(iterator.next()); //done: false 这个表示是否遍历完数组的状态
      console.log(iterator.next()); //done: true
</code></pre>
<pre><code class="lang-js">//自定义遍历规则
      //自己构建Symbol.iterator的规则
      const obj = &#123;
        name: &quot;fpx&quot;,
        components: [&quot;xiaoming&quot;, &quot;doinb&quot;, &quot;xiaotian&quot;],
        [Symbol.iterator]() &#123;
          let index = 0;
          return &#123;
            next: () =&gt; &#123;
              if (index &lt; this.components.length) &#123;
                const res = &#123; value: this.components[index], done: false &#125;;
                index++;
                return res;
              &#125; else &#123;
                return &#123; value: undefined, done: &#39;true&#39;&#125;;
              &#125;
            &#125;,
          &#125;;
        &#125;,
      &#125;;

      for (let item of obj) &#123;
        console.log(item);
      &#125;
</code></pre>
<h1 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h1><p>生成器是ES6提供的一种异步编程解决方案，语法行为与传统函数完全不同。</p>
<pre><code class="lang-js">//生成器，特殊的函数
      //yield相当于函数的分隔符
      function *gen() &#123;
        yield &#39;1&#39;;
        yield &#39;2&#39;;
        yield &#39;3&#39;;
      &#125;

      let iterator = gen();
      console.log(iterator.next());
      console.log(iterator.next());
      console.log(iterator.next());

    //遍历
    for (let item of gen()) &#123;
        console.log(item);
      &#125;
</code></pre>
<pre><code class="lang-js">function* gen(arg) &#123;
        console.log(arg);
        let one = yield 111;
        console.log(one);
        let two = yield 222;
        console.log(two);
        yield 333;
      &#125;

      let iterator = gen(&#39;AAA&#39;);
      console.log(iterator.next());  //AAA,传入参数没问题

      //输入的结果将作为第一个yield的返回值
      console.log(iterator.next(&#39;BBB&#39;)); //BBB

      //输入的结果将作为第二个yield的返回值
      console.log(iterator.next(&#39;CCC&#39;)); //CCC
</code></pre>
<pre><code class="lang-js"> function one() &#123;
        setTimeout(() =&gt; &#123;
          console.log(111);
          iterator.next();
        &#125;, 1000)
      &#125;

      function two() &#123;
        setTimeout(() =&gt; &#123;
          console.log(222);
          iterator.next();
        &#125;, 2000)
      &#125;

      function three() &#123;
        setTimeout(() =&gt; &#123;
          console.log(333);
          iterator.next();
        &#125;, 3000)
      &#125;

      function *gen() &#123;
        yield one();
        yield two();
        yield three();
      &#125;

      let iterator = gen();
      iterator.next();
</code></pre>
<pre><code class="lang-js">//异步获取用户数据、订单数据、商品数据
      function getUsers() &#123;
        setTimeout(() =&gt; &#123;
          let data = &quot;用户数据&quot;;
          iterator.next(data);
        &#125;, 1000)
      &#125;

      function getOrders() &#123;
        setTimeout(() =&gt; &#123;
          let data = &quot;订单数据&quot;;
          iterator.next(data)
        &#125;, 1000)
      &#125;

      function getGoods() &#123;
        setTimeout(() =&gt; &#123;
          let data = &quot;商品数据&quot;;
          iterator.next(data)
        &#125;, 1000)
      &#125;

      function *gen() &#123;
        let users = yield getUsers();
        console.log(users);
        let orders = yield getOrders();
        console.log(orders);
        let goods = yield getGoods();
        console.log(goods);
      &#125;

      let iterator = gen();
      iterator.next()
</code></pre>
<h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><p>Promise是ES6引入的异步编程的新解决方案。语法上Promise是一个构造函数，用来封装异步操作并可以获取其成功或失败的结果。</p>
<ol>
<li>Promise构造函数：Promise(excutor){}</li>
<li>Promise.prototype.then方法</li>
<li>Promise.prototype.catch方法</li>
</ol>
<pre><code class="lang-js">//实例化Promise对象
      const p = new Promise(function(resolve, reject) &#123;
        setTimeout(function() &#123;
          // let data = &quot;数据库中的用户数据&quot;;
          //状态：成功
          // resolve(data);
          let err = &quot;数据读取失败&quot;;
          reject(err);
        &#125;, 1000)
      &#125;)

      //调用promise对象的then方法
      //前面调用了resolve方法，则会调用成功的回调函数
      p.then(function(value) &#123;
        console.log(value);
      &#125;, function(reason) &#123;
        console.log(reason);
      &#125;)
</code></pre>
<pre><code class="lang-js">//引入fs模块
const fs = require(&#39;fs&#39;);

//调用方法读取文件
// fs.readFile(&quot;./resources/长相思.md&quot;,(err, data) =&gt; &#123;
//   if (err) throw err;
//   console.log(data.toString());
// &#125;);

//使用Promise封装一个异步操作,所以里面写异步的操作
const p = new Promise(function(reslove, reject) &#123;
  //读取文件就是异步操作
  fs.readFile(&#39;./resources/长相思.md&#39;,(err, data) =&gt; &#123;
    if (err) reject(err);
    reslove(data)
  &#125;);
&#125;)

p.then(function(value)&#123;
  console.log(value.toString());
&#125;, function(reason) &#123;
  console.log(reason);
&#125;)

//这样就可以避免回调的嵌套
</code></pre>
<h2 id="promise-then方法"><a href="#promise-then方法" class="headerlink" title="promise.then方法"></a>promise.then方法</h2><pre><code class="lang-js">const p = new Promise((resolve, reject) =&gt; &#123;
        setTimeout(() =&gt; &#123;
          resolve(&#39;用户数据&#39;);
        &#125;,1000)
      &#125;)

      //then方法返回的直接也是Promise对象,这个对象状态由回调函数的执行结果决定
      //1.如果回调函数中返回的值是非promise类型的属性，状态为成功，返回值为对象的成功的值
      //2.如果回调函数中返回的值是promise对象，则成功还是失败的状态是根据返回的promise的状态决定的
      //3.抛出异常
      const res = p.then(value =&gt; &#123;
        console.log(value);
        //1.非promise类型的数据
        // return 123;

        //2.是promise对象
        return new Promise((resolve, reject) =&gt; &#123;
          // resolve(&quot;ok&quot;);
          // reject(&quot;失败了&quot;);
          throw new Error(&quot;出错了&quot;);
        &#125;)
      &#125;, reason =&gt; &#123;
        console.log(reason);
      &#125;)

      //这样的特性使得promise.then的方法是可以链式调用的
      //这样就可以避免回调地狱
      const result = p.then(value =&gt; &#123;&#125;, reason =&gt; &#123;&#125;)
      .then(value =&gt; &#123;&#125;, reason =&gt; &#123;&#125;)

      console.log(res);
</code></pre>
<pre><code class="lang-js"> const p = new Promise((resolve, reject) =&gt; &#123;
        setTimeout(() =&gt; &#123;
          reject(&quot;出错了...&quot;);
        &#125;, 1000)
      &#125;)

      //catch的作用相当p.thedn不写第一个函数的作用
      p.catch(function(reason) &#123;
        console.warn(reason);
      &#125;)
</code></pre>
<h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><p>ES6提供了新的数据结构Set(集合)。它类似于数组，但成员的值都是唯一的。集合实现了iterator接口。所以可以使用拓展运算符和for…of进行遍历。</p>
<p>集合的构建和方法的使用</p>
<pre><code class="lang-js">//集合的声明
      let s = new Set();
      let s2 = new Set([&quot;大事儿&quot;, &quot;小事儿&quot;, &quot;好事儿&quot;, &quot;坏事儿&quot;]);
      console.log(s, typeof s);
      console.log(s2, typeof s2);

      //元素个数
      console.log(s2.size);

      //添加新元素
      s2.add(&#39;喜事儿&#39;);
      console.log(s2);

      //删除元素
      s2.delete(&#39;坏事儿&#39;);
      console.log(s2);

      //检测是否有某个元素
      let res = s2.has(&#39;大事儿&#39;);
      console.log(res);

      //清空集合
      // s2.clear();
      // console.log(s2);

      //遍历
      for (let item of s2) &#123;
        console.log(item);
      &#125;
</code></pre>
<p>案例：</p>
<p>数组去重：</p>
<pre><code class="lang-js">let arr = [1,2,3,4,5,4,3,2,1];

      //数组去重，利用集合特性
      // let res = [...new Set(arr)];
      // console.log(res);

      let arr2 = [];
      for (let i in arr) &#123;
        if (arr2.length === 0) &#123;
          arr2.push(arr[i]);
          continue;
        &#125;
        if (arr2.indexOf(arr[i]) === -1) &#123;
          arr2.push(arr[i]);
        &#125;
      &#125;
      console.log(arr2);
</code></pre>
<p>数组求交集：</p>
<pre><code class="lang-js"> let arr = [1, 2, 3, 4, 5, 4, 3, 2, 1];
  let arr2 = [4, 5, 6, 5, 6];
      //交集
      let arr3 = [...new Set(arr)].filter((item) =&gt; arr2.indexOf(item) !== -1)
      console.log(arr3);
</code></pre>
<p>数组求并集：</p>
<pre><code class="lang-js"> let arr = [1, 2, 3, 4, 5, 4, 3, 2, 1];

      let arr2 = [4, 5, 6, 5, 6];

      //并集
      let union = [...new Set([...arr, ...arr2])];
      console.log(union);
</code></pre>
<p>数组求差集：</p>
<pre><code class="lang-js"> let arr = [1, 2, 3, 4, 5, 4, 3, 2, 1];

      let arr2 = [4, 5, 6, 5, 6];
      //求差集
      let diff = [...new Set(arr)].filter(item =&gt; !new Set(arr2).has(item))
      console.log(diff);
</code></pre>
<h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p>ES6提供了Map数据结构。它类似于对象，也是键值对的集合。但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当做键。Map也实现了iterator接口，所以可以使用【拓展运算符】和for…of进行遍历，map的常见属性和方法如下：</p>
<pre><code class="lang-js">let m = new Map();

      //添加元素
      m.set(&quot;name&quot;, &quot;尚硅谷&quot;);
      m.set(&quot;change&quot;, function () &#123;
        console.log(&quot;我们可以改变你...&quot;);
      &#125;);

      let key = &#123;
        school: &quot;ATGUIGU&quot;,
      &#125;;
      m.set(key, [&quot;北京&quot;, &quot;上海&quot;, &quot;深圳&quot;]);

      //元素个数
      console.log(m.size);

      //删除
      // m.delete(&quot;name&quot;);

      //获取
      console.log(m.get(&quot;change&quot;));

      //清空
      // m.clear();
      // console.log(m);

      //遍历,获取的是数组键值对
      for (let item of m) &#123;
        console.log(item);
      &#125;
</code></pre>
<h1 id="函数以及类的继承"><a href="#函数以及类的继承" class="headerlink" title="函数以及类的继承"></a>函数以及类的继承</h1><p>函数的继承：</p>
<pre><code class="lang-js">//ES5的继承
function Phone(brand, price) &#123;
      this.brand = brand;
      this.price = price;
    &#125;

    Phone.prototype.call = function() &#123;
      console.log(&#39;我可以打电话...&#39;);
    &#125;

    function SmartPhone(brand, price, color, size) &#123;
      //函数call方法，改变this的指向,传入参数为实参
      Phone.call(this, brand, price);
      this.color = color;
      this.size = size;
    &#125;

    //这里往原型上添加属性，相当于给SmartPhone找了个爸爸
    SmartPhone.prototype = new Phone;
    SmartPhone.prototype.constructor = SmartPhone;

    SmartPhone.prototype.photo = function() &#123;
      console.log(&#39;我可以拍照...&#39;);
    &#125;

    SmartPhone.prototype.playGame = function() &#123;
      console.log(&#39;我可以玩游戏...&#39;);
    &#125;

    const chuizi = new SmartPhone(&#39;锤子&#39;, 2499, &#39;黑色&#39;, &#39;5.5inch&#39;);

    console.log(chuizi);
</code></pre>
<p>类的继承：</p>
<pre><code class="lang-js"> class Phone &#123;
        //构造方法
        constructor(brand, price) &#123;
          this.brand = brand;
          this.price = price;
        &#125;

        //父类的成员属性
        call()&#123;
          console.log(&quot;我可以打电话...&quot;);
        &#125;
      &#125; 

      class SmartPhone extends Phone &#123;
        constructor(brand, price, color, size) &#123;
          super(brand, price);
          this.color = color;
          this.size = size;
        &#125;

        photo() &#123;
          console.log(&quot;拍照...&quot;);
        &#125;

        playGame() &#123;
          console.log(&quot;玩游戏&quot;);
        &#125;
        //可以实现方法的重写，就近一致原则
        call() &#123;
          console.log(&quot;我可以进行视频通话...&quot;);
        &#125;
      &#125;

      const xiaomi = new SmartPhone(&quot;小米&quot;, 799, &quot;黑色&quot;, &quot;4.7inch&quot;);
      console.log(xiaomi);
      xiaomi.call();
      xiaomi.photo();
      xiaomi.playGame();
</code></pre>
<h1 id="类的get和set方法"><a href="#类的get和set方法" class="headerlink" title="类的get和set方法"></a>类的get和set方法</h1><pre><code class="lang-js">//get 和 set
      class Phone &#123;
        get price() &#123;
          console.log(&quot;价格属性被读取了...&quot;);
          return &quot;i love you&quot;;
        &#125;

        set price(newVal) &#123;//必须传参数
          console.log(&quot;价格属性被修改了...&quot;);
          console.log(newVal);
        &#125;
      &#125;

      //实例化对象
      let s = new Phone();
      console.log(s.price);
      s.price = 10; //这个语句会引起set的调用, 参数newVal就是更改的值。
</code></pre>
<h1 id="数值扩展"><a href="#数值扩展" class="headerlink" title="数值扩展"></a>数值扩展</h1><pre><code class="lang-js">//JS的数值扩展
     /* Number.EPSILON是JavaScript 表示的最小精度
     当两个数的差值小于这个精度时，即可认为这两个数相等 */
      console.log(0.1 + 0.2 === 0.3); //false

      function equal(a, b) &#123;
        return (Math.abs(a - b) &lt; Number.EPSILON);
      &#125;

      console.log(equal(0.1 + 0.2, 0.3));

      //进制
      let b = 0b1010;
      console.log(b);

      let o = 0o222;
      console.log(o);

      let x = 0xff;
      console.log(x);

      //Number.isFinite 检测一个数值是否为优先数
      console.log(Number.isFinite(100));
      console.log(Number.isFinite(100 / 0));

      //其他的看Number方法
</code></pre>
<pre><code class="lang-js">//判断两个值是否为同一个值。
      console.log(Object.is(120, 120));
      console.log(Object.is(NaN, NaN)); //true
      console.log(NaN === NaN); //false

      //Object.assign 对象的合并
      const config1 = &#123;
        host: &#39;localhost&#39;,
        port: 3306,
        name: &#39;root&#39;,
        pass: &#39;root&#39;
      &#125;

      const config2 = &#123;
        host: &#39;http://atguigu.com&#39;,
        port: 33060,
        name: &#39;atguigu.com&#39;,
        pass: &#39;iloveyou&#39;
      &#125;
      //如果遇见同名的对象，后面的会把前面的覆盖掉
      console.log(Object.assign(config1, config2));

      //Object.setPrototypeOf 设置原型对象
      const school = &#123;
        name: &#39;尚硅谷&#39;
      &#125;
      const cities = &#123;
        campus: [&#39;北京&#39;, &#39;上海&#39;, &#39;深圳&#39;]
      &#125;

      //把cities加到school上的原型上
      Object.setPrototypeOf(school, cities);
      console.log(Object.getPrototypeOf(school));
      console.log(school);
</code></pre>
<h1 id="Object的一些新方法"><a href="#Object的一些新方法" class="headerlink" title="Object的一些新方法"></a>Object的一些新方法</h1><pre><code class="lang-js">//判断两个值是否为同一个值。
      console.log(Object.is(120, 120));
      console.log(Object.is(NaN, NaN)); //true
      console.log(NaN === NaN); //false

      //Object.assign 对象的合并
      const config1 = &#123;
        host: &#39;localhost&#39;,
        port: 3306,
        name: &#39;root&#39;,
        pass: &#39;root&#39;
      &#125;

      const config2 = &#123;
        host: &#39;http://atguigu.com&#39;,
        port: 33060,
        name: &#39;atguigu.com&#39;,
        pass: &#39;iloveyou&#39;
      &#125;
      //如果遇见同名的对象，后面的会把前面的覆盖掉
      console.log(Object.assign(config1, config2));

      //Object.setPrototypeOf 设置原型对象
      const school = &#123;
        name: &#39;尚硅谷&#39;
      &#125;
      const cities = &#123;
        campus: [&#39;北京&#39;, &#39;上海&#39;, &#39;深圳&#39;]
      &#125;

      //把cities加到school上的原型上dsadas
      Object.setPrototypeOf(school, cities);
      console.log(Object.getPrototypeOf(school));
      console.log(school);
</code></pre>
<h1 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h1><p>模块化是值将一个大的程序文件，拆分成许多小的文件，然后将小文件组合起来。</p>
<p>ES6模块化语法</p>
<p>模块功能主要由两个命令构成：export和import</p>
<p>export命令用于规定模块的对外接口</p>
<p>import命令用于输入其他模块提供的功能</p>
<p>export的使用方法：</p>
<pre><code class="lang-js">//统一暴露
let school = &#39;尚硅谷&#39;;

function teach() &#123;
  console.log(&quot;我们可以教给你开发技能...&quot;);
&#125;

export &#123;school, teach&#125;;

//分别暴露
export let student = &#39;张三&#39;;

export function say() &#123;
  console.log(&#39;我可以说话...&#39;);
&#125;

//默认暴露
export default &#123;
  school: &#39;atguigu&#39;,
  change: function() &#123;
    console.log(&#39;我们可以改变你的技能...&#39;);
  &#125;
&#125;
</code></pre>
<p>import的使用方法：</p>
<pre><code class="lang-js">import &#123;school, teach&#125; from &#39;./m1.js&#39;;
      //当变量名由冲突的时候，可以使用别名形式进行替代
      import &#123;school as guigu, teach as tc&#125; from &#39;xxx&#39;;

      //当时用默认暴露时，这个名称就是default，所以调用方法的时候也是x.default.xx的形式
      //解构赋值写法
      import &#123;default as m3&#125; from &#39;xxx&#39;;

      //简便形式，只能针对默认暴露
      import m3 from &#39;./m1.js&#39;
</code></pre>
<pre><code class="lang-js"> &lt;script&gt;

    &lt;/script&gt;
    //app里面集中写所有的import语句，再通过这样的方式去使用
    &lt;script type=&quot;module&quot; src=&quot;./app.js&quot;&gt;&lt;/script&gt;
</code></pre>
<h1 id="async和await"><a href="#async和await" class="headerlink" title="async和await"></a>async和await</h1><p>async和await两种语法结合可以让异步代码像同步代码一样</p>
<p>async函数：</p>
<ol>
<li>async函数的返回值为promise对象</li>
<li>promise对象的结果由async函数执行的返回值决定</li>
</ol>
<p>await表达式：</p>
<ol>
<li>await必须写在async函数里</li>
<li>await右侧的表达式一般为promise对象</li>
<li>await返回的是promise成功的值</li>
<li>await的promise失败了就会抛出异常，需要通过try…catch捕获处理</li>
</ol>
<pre><code class="lang-js">//引入fs模块
const fs = require(&#39;fs&#39;);

//读取文件
function readFile(filePath) &#123;
  return new Promise((resolve, reject) =&gt; &#123;
    fs.readFile(filePath, (err, data) =&gt; &#123;
      if (err) &#123;
        reject(err);
      &#125;
      resolve(data)
    &#125;)
  &#125;)
&#125;

async function main() &#123;
  try &#123;
    let data = await readFile(&#39;./gushi.md&#39;);
    console.log(data.toString());
  &#125; catch (error) &#123;
    console.log(error);
  &#125;
&#125;

main();
</code></pre>
<h1 id="正则扩展"><a href="#正则扩展" class="headerlink" title="正则扩展"></a>正则扩展</h1><p>正则表达式命名分组：</p>
<pre><code class="lang-js">let str = &#39;&lt;a href=&quot;http://www.atguigu.com&quot;&gt;尚硅谷&lt;/a&gt;&#39;;

      const reg = /&lt;a href=&quot;(?&lt;url&gt;.*)&quot;&gt;(?&lt;text&gt;.*)&lt;\/a&gt;/;

      const result = reg.exec(str);
      console.log(result);
      console.log(result.groups.url);
</code></pre>
<p>正则拓展-dotAll模式-模式修正符</p>
<pre><code class="lang-js">// . 除换行符以外的任意单个字符
      let str = `
        &lt;ul&gt;
        &lt;li&gt;
          &lt;a&gt;肖生克的救赎&lt;/a&gt;
          &lt;p&gt;上映时间：1994-09-10&lt;/p&gt;
        &lt;/li&gt;
        &lt;li&gt;
          &lt;a&gt;阿甘正传&lt;/a&gt;
          &lt;p&gt;上映时间：1994-07-06&lt;/p&gt;
        &lt;/li&gt;
      &lt;/ul&gt;`;

      //声明正则
      // const reg = /&lt;li&gt;\s+&lt;a&gt;(.*?)&lt;\/a&gt;\s+&lt;p&gt;(.*?)&lt;\/p&gt;/g;
      //加上这个s，表示模式修正符，可以使.能匹配任意字符
      const reg2 = /&lt;li&gt;.*?&lt;a&gt;(.*?)&lt;\/a&gt;.*?&lt;p&gt;(.*?)&lt;\/p&gt;/gs;
      let res;
      let data = [];
      while ((res = reg2.exec(str))) &#123;
        data.push(&#123; title: res[1], time: res[2] &#125;);
      &#125;
      console.log(data);
</code></pre>
<h1 id="Object-fromEntries"><a href="#Object-fromEntries" class="headerlink" title="Object.fromEntries"></a>Object.fromEntries</h1><pre><code class="lang-js"> //二维数组
     //fromEntries方法可以把二维数组转成对象
     const res = Object.fromEntries([
       [&#39;name&#39;, &#39;尚硅谷&#39;],
       [&#39;subject&#39;, &#39;Java，大数据，前端，云计算&#39;]
     ])
     console.log(res);
     //Map
     const m = new Map();
     m.set(&#39;name&#39;, &#39;atguigu&#39;);
     const res2 = Object.fromEntries(m);
     console.log(res2);

     //Object.entries 这个方法是将对象转成数组的
     const arr = Object.entries(&#123;
       name: &#39;尚硅谷&#39;
     &#125;)
     console.log(arr);
</code></pre>
<h1 id="私有属性"><a href="#私有属性" class="headerlink" title="私有属性"></a>私有属性</h1><pre><code class="lang-js">class Person &#123;
        name;
        //前面加#表示它是私有的
        #age;
        #wight;
        constructor(name, age, wight) &#123;
          this.name = name;
          this.#age = age;
          this.#wight = wight;
        &#125;

        toString() &#123;
          console.log(this.name, this.#age, this.#wight);
        &#125;
      &#125;

      let girl = new Person(&#39;小红&#39;, 18, &#39;45kg&#39;);
      girl.toString();
</code></pre>
<h1 id="可选链操作符"><a href="#可选链操作符" class="headerlink" title="可选链操作符"></a>可选链操作符</h1><pre><code class="lang-js">function main(config) &#123;
        //判断的时候写整个链得挨个去写，ES11多了可选链操作符做了简化
        // const dbHost = config &amp;&amp; config.db &amp;&amp; config.db.host;
        const dbHost = config?.db?.host;
        console.log(dbHost);
      &#125;

      main(&#123;
        db: &#123;
          host: &#39;192.168.1.100&#39;,
          username: &#39;root&#39;
        &#125;,
        cache: &#123;
          host: &#39;192.168.1.200&#39;,
          username: &#39;admin&#39;
        &#125;
      &#125;)
</code></pre>
<h1 id="动态import"><a href="#动态import" class="headerlink" title="动态import"></a>动态import</h1><p>在需要Import的时候在按需引入</p>
<pre><code class="lang-js">const btn = document.getElementById(&#39;btn&#39;);

//then函数的形参就是引入的那个文件，可以调用相关的方法
btn.onclick = function() &#123;
    import(&#39;./xxx&#39;).then(module =&gt; &#123;
        module.hello();
    &#125;)
&#125;
</code></pre>
<h1 id="大整型"><a href="#大整型" class="headerlink" title="大整型"></a>大整型</h1><pre><code class="lang-js"> //声明
      let n = 520n;
      console.log(n, typeof(n));

      //函数,将普通整型转成
      let n2 = 123;
      console.log(BigInt(n2));

      //JS的最大安全整型
      let max = Number.MAX_SAFE_INTEGER;
      console.log(max);

      //需要将这个数转成大整型进行运算，但是大整型只能和大整型进行运算
      console.log(BigInt(max));
      console.log(BigInt(max) + BigInt(2));
</code></pre>
]]></content>
  </entry>
</search>
