<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>github设置自己的域名</title>
    <url>/2021/01/20/Hexo/github%E8%AE%BE%E7%BD%AE%E8%87%AA%E5%B7%B1%E7%9A%84%E5%9F%9F%E5%90%8D/</url>
    <content><![CDATA[<p>哈哈，上次整了一晚上的没整明白，今天两下就整好了，看来真的进步不错哈哈，至少看东西，解决问题更有耐心也更能看懂了。<br><a id="more"></a></p>
<h1 id="1-购买域名"><a href="#1-购买域名" class="headerlink" title="1.购买域名"></a>1.购买域名</h1><p>我是买的阿里云的域名，如下图：<br><img src="/blog_img/github设置自己的域名/1.jpg" alt="域名"><br>域名解析如下：<br><img src="/blog_img/github设置自己的域名/2.jpg" alt="域名解析"></p>
<h1 id="2-github仓库设置域名地址"><a href="#2-github仓库设置域名地址" class="headerlink" title="2.github仓库设置域名地址"></a>2.github仓库设置域名地址</h1><p>在blog目录下的source文件下，创一个叫CNAME的无后缀文件，里面填入你的域名，比如我的   zzygeo.cn    如下图：<br><img src="/blog_img/github设置自己的域名/4.jpg" alt=""><br>如下图，主要是要设置博客上传分支的目录，以及更改你自己的域名（创建CNAME后自动生成），采用https加密。<br><img src="/blog_img/github设置自己的域名/3.jpg" alt=""></p>
<p>到此就设置完成了！</p>
<hr>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title>markdown语法</title>
    <url>/2020/09/24/Hexo/markdown%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1 id="1-标题"><a href="#1-标题" class="headerlink" title="1.标题"></a>1.标题</h1><a id="more"></a>
<pre><code># 一级标题
## 二级标题
### 三级标题
#### 四级标题
##### 五级标题
###### 六级标题 
</code></pre><p>注：# 和「标题文字」之间建议保留一个字符的空格，这是最标准的 Markdown 写法。</p>
<hr>
<h1 id="2-粗体、斜体、删除线"><a href="#2-粗体、斜体、删除线" class="headerlink" title="2. 粗体、斜体、删除线"></a>2. 粗体、斜体、删除线</h1><pre><code>*我是斜体*
**我是粗体**
***我是粗斜体***
~~我是删除线~~
</code></pre><p>显示效果：<br><em>我是斜体</em><br><strong>我是粗体</strong><br><strong><em>我是粗斜体</em></strong><br><del>我是删除线</del></p>
<hr>
<h1 id="3-表格"><a href="#3-表格" class="headerlink" title="3. 表格"></a>3. 表格</h1><pre><code>| 学号 | 姓名 | 分数|
| :- | -: | :-: |
| 小明 | 男 | 75 |
| 小红 | 女 | 79 |
| 小陆 | 男 | 92 |
</code></pre><p>显示效果：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">学号</th>
<th style="text-align:right">姓名</th>
<th style="text-align:center">分数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">小明</td>
<td style="text-align:right">男</td>
<td style="text-align:center">75</td>
</tr>
<tr>
<td style="text-align:left">小红</td>
<td style="text-align:right">女</td>
<td style="text-align:center">79</td>
</tr>
<tr>
<td style="text-align:left">小陆</td>
<td style="text-align:right">男</td>
<td style="text-align:center">92</td>
</tr>
</tbody>
</table>
</div>
<hr>
<h1 id="4-有序列表"><a href="#4-有序列表" class="headerlink" title="4. 有序列表"></a>4. 有序列表</h1><pre><code>1. 文本1
2. 文本2
3. 文本3
</code></pre><p>显示效果：  </p>
<ol>
<li>文本1</li>
<li>文本2</li>
<li>文本3</li>
</ol>
<hr>
<h1 id="5-无序列表"><a href="#5-无序列表" class="headerlink" title="5. 无序列表"></a>5. 无序列表</h1><pre><code>- 文本1
- 文本2
- 文本3
</code></pre><p>显示效果：  </p>
<ul>
<li>文本1</li>
<li>文本2</li>
<li>文本3</li>
</ul>
<hr>
<h1 id="6-行内代码块"><a href="#6-行内代码块" class="headerlink" title="6. 行内代码块"></a>6. 行内代码块</h1><pre><code>C语言里的函数 `scanf()` 怎么使用？
</code></pre><p>显示效果：<br>C语言里的函数 <code>scanf()</code> 怎么使用？</p>
<hr>
<h1 id="7-分割线"><a href="#7-分割线" class="headerlink" title="7. 分割线"></a>7. 分割线</h1><h2 id="可以在一行中用三个以上的减号、底线来建立一个分隔线，行内不能有其他内容。"><a href="#可以在一行中用三个以上的减号、底线来建立一个分隔线，行内不能有其他内容。" class="headerlink" title="可以在一行中用三个以上的减号、底线来建立一个分隔线，行内不能有其他内容。  "></a>可以在一行中用三个以上的减号、底线来建立一个分隔线，行内不能有其他内容。  </h2><pre><code>___
</code></pre><h2 id="显示效果："><a href="#显示效果：" class="headerlink" title="显示效果："></a>显示效果：</h2><hr>
<hr>
<h1 id="8-超链接"><a href="#8-超链接" class="headerlink" title="8. 超链接"></a>8. 超链接</h1><p>语法格式为<a href="链接地址" title="链接标题">链接文字</a>，[]里写链接文字，()里写链接地址, ()中的”“中可以为链接指定title属性，title属性为可选。title属性的效果是鼠标悬停在链接上会出现指定的title文字。链接地址与链接标题前有一个空格。<br>    欢迎来到<a href="http://blog.csdn.net/china_jeffery" title="zzygeo">多加香菜的博客</a></p>
<p>显示效果：<br>欢迎来到<a href="http://blog.csdn.net/china_jeffery" title="zzygeo">多加香菜的博客</a></p>
<hr>
<h1 id="9-图片"><a href="#9-图片" class="headerlink" title="9. 图片"></a>9. 图片</h1><p>语法格式为<img src="图片地址" alt="图片Alt" title="图片Title">，图片Alt的意思是如果图片因为某些原因不能显示，就用定义的图片Alt文字来代替图片。 图片Title则和超链接中的链接标题一样，表示鼠标悬停与图片上时出现的文字。 图片Alt 和 图片Titlee 都是可选的。</p>
<hr>
<h1 id="10-引用"><a href="#10-引用" class="headerlink" title="10. 引用"></a>10. 引用</h1><pre><code>&gt; 一级引用
&gt;&gt; 二级引用
&gt;&gt;&gt; 三级引用
&gt;&gt;&gt;&gt; 四级引用
</code></pre><p>显示效果：</p>
<blockquote>
<p>一级引用</p>
<blockquote>
<p>二级引用</p>
<blockquote>
<p>三级引用</p>
<blockquote>
<p>四级引用</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<hr>
<h1 id="11-空格"><a href="#11-空格" class="headerlink" title="11. 空格"></a>11. 空格</h1><pre><code>你好&amp;nbsp;&amp;nbsp;&amp;nbsp;jeffery
</code></pre><p>显示效果<br>你好&nbsp;&nbsp;&nbsp;zzy</p>
<hr>
<h1 id="12-字体、字号、颜色"><a href="#12-字体、字号、颜色" class="headerlink" title="12. 字体、字号、颜色"></a>12. 字体、字号、颜色</h1><pre><code>&lt;font face=&quot;黑体&quot;&gt;我是黑体字&lt;/font&gt;
&lt;font face=&quot;微软雅黑&quot;&gt;我是微软雅黑&lt;/font&gt;
&lt;font color=#0099ff size=23 face=&quot;黑体&quot;&gt;我是黑体，颜色#0099ff 字号23&lt;/font&gt;
</code></pre><p><font face="黑体">我是黑体字</font>  </p>
<p><font face="微软雅黑">我是微软雅黑</font>  </p>
<p><font color=#00 size=23 face="黑体">我是黑体，颜色#0099ff 字号23</font>&lt;/p&gt;</p>
<hr>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title>新电脑上部署hexo</title>
    <url>/2020/10/02/Hexo/%E6%96%B0%E7%94%B5%E8%84%91%E4%B8%8A%E9%83%A8%E7%BD%B2hexo/</url>
    <content><![CDATA[<h1 id="1-安装必要软件"><a href="#1-安装必要软件" class="headerlink" title="1. 安装必要软件"></a>1. 安装必要软件</h1><p>安装 Git 客户端<br>安装 node JS</p>
<a id="more"></a>
<hr>
<h1 id="2-拷贝源文件"><a href="#2-拷贝源文件" class="headerlink" title="2. 拷贝源文件"></a>2. 拷贝源文件</h1><p>将初始电脑上个人博客文件夹下这几个文件夹拷到当前新电脑的准备设置的博客路径下。</p>
<pre><code>_config.yml
package.json
scaffolds/
source/
themes/
</code></pre><hr>
<h1 id="3-安装hexo"><a href="#3-安装hexo" class="headerlink" title="3. 安装hexo"></a>3. 安装hexo</h1><p>在 cmd 下输入下面指令安装 hexo:</p>
<pre><code>npm install -g hexo
</code></pre><hr>
<h1 id="4-在新博客路径下，安装三方依赖库"><a href="#4-在新博客路径下，安装三方依赖库" class="headerlink" title="4. 在新博客路径下，安装三方依赖库"></a>4. 在新博客路径下，安装三方依赖库</h1><pre><code>npm install
npm install hexo-deployer-git --save //文章部署到 git 的模块
npm install 主题需要的插件
</code></pre><p><strong>千万别hxeo init</strong>，不然你就拉在裤子里了！！！</p>
<hr>
<h1 id="5-GITHUB-gitee-添加-SSH-KEYS"><a href="#5-GITHUB-gitee-添加-SSH-KEYS" class="headerlink" title="5. GITHUB/gitee 添加 SSH KEYS"></a>5. GITHUB/gitee 添加 SSH KEYS</h1><p>在GitHub/gitee的ssh keys那里再添加一个当前电脑的环境生成的key，但是可别把原来的电脑删掉了啊。<br>首先在本地创建 SSH Keys:</p>
<pre><code>ssh-keygen -t rsa -C “xxxx@xxxx.com“
</code></pre><p>后面的邮箱即为 github/gitee注册邮箱，也是你登录Github的邮箱（其实无关紧要，只是为了辨识生成的用户名），之后会要求确认路径和输入密码，一路回车就行。<br>成功的话会在git bash页面下看到生成的 .ssh文件夹路径，进去，打开 id_rsa.pub，复制里面的key（全选）即可。然后拷贝到 Github/gitee 的 SSH Keys(这里要添加一个新的)<br>然后在终端中，我们再次测试下公钥有没有添加成功：</p>
<pre><code>ssh -T git@gitee.com 
</code></pre><p>会弹出确认命令，输入yes,会弹出你的名字等等，会出现：</p>
<pre><code>Hi username! You&#39;ve successfully authenticated, but GitHub does not provide shell access.
</code></pre><p>然后：</p>
<pre><code>hexo g
hexo s
hexo d
</code></pre><hr>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title>hexo d 出现错误的用户名和密码的解决办法</title>
    <url>/2020/10/02/Hexo/hexo-d-%E5%87%BA%E7%8E%B0%E9%94%99%E8%AF%AF%E7%9A%84%E7%94%A8%E6%88%B7%E5%90%8D%E5%92%8C%E5%AF%86%E7%A0%81%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    <content><![CDATA[<p>在windows搜索栏输入：控制面板<a id="more"></a>)<br><img src="/blog_img/hexo d时错误用户名和密码解决办法/1.png" alt=""><br>然后点击：<br><img src="/blog_img/hexo d时错误用户名和密码解决办法/2.png" alt=""><br><img src="/blog_img/hexo d时错误用户名和密码解决办法/3.png" alt=""><br><img src="/blog_img/hexo d时错误用户名和密码解决办法/4.png" alt=""></p>
<p>点进去就可以更改用户名和密码了</p>
<hr>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title>pcl+vs+cmake编译</title>
    <url>/2020/12/27/PCL/pcl-vs-cmake%E7%BC%96%E8%AF%91/</url>
    <content><![CDATA[<p>上一篇写的配置可能是最基础的，也是很麻烦，其实可以用cmake来偷个懒，这样就不用附加依赖性已经加入库目录和包含目录了。<br><a id="more"></a></p>
<h1 id="1-软件准备"><a href="#1-软件准备" class="headerlink" title="1.软件准备"></a>1.软件准备</h1><p>1.All in one 安装包。</p>
<p>2.获取All in one 包对应得PDB文件包，用于后期单步调试。</p>
<p>3.安装Visual studio 2019编译器</p>
<p>4.cmake<br><img src="/blog_img/PCL配置/17.png" alt="示意图"><br><img src="/blog_img/PCL配置/1.jpg" alt="示意图"></p>
<p>其实源码包用不上，懒得改了，最复杂的方式就是源代码加第三方库进行配置，等我配置好了也会再一篇关于源码方式的配置。</p>
<hr>
<h1 id="2-链接"><a href="#2-链接" class="headerlink" title="2.链接"></a>2.链接</h1><p><a href="https://github.com/PointCloudLibrary/pcl/releases">pcl下载地址</a><br><a href="https://visualstudio.microsoft.com/zh-hans/downloads/">visual studio下载地址</a><br><a href="https://cmake.org/download/">cmake下载地址</a></p>
<hr>
<h1 id="3-安装事项"><a href="#3-安装事项" class="headerlink" title="3.安装事项"></a>3.安装事项</h1><p>为了方便配置，pcl安装目录尽量默认，不默认后续添加目录需要选择对应的位置。</p>
<p>pcl安装请一定选择创建系统路径，visual studio和cmake安装位置随意，其他选项默认即可。</p>
<p>pcl安装完成后，请把下载的pcd文件解压，如下图：<br><img src="/blog_img/PCL配置/2.jpg" alt=""></p>
<p>将所有文件复制，安装到pcl下的BIN文件下<br><img src="/blog_img/PCL配置/3.jpg" alt=""></p>
<p>检查pcl安装目录下的 3rdParty-OpenNI2是否只有一个安装包（我的是这样），这可能是事先安装过SDK的原因，请卸载了重新安装在OpenNI2下，安装完成如下图：<br><img src="/blog_img/PCL配置/4.jpg" alt=""></p>
<p>cmake 安装请选择添加到系统路径，没选的话也可以自己手动添加，添加的方式为cmake目录下bin文件  比如C:\APP\Cmake\bin这样的形式。</p>
<hr>
<h1 id="4-关于Visual-studio安装项目"><a href="#4-关于Visual-studio安装项目" class="headerlink" title="4.关于Visual studio安装项目"></a>4.关于Visual studio安装项目</h1><p>我安装了这些负载</p>
<p><img src="/blog_img/PCL配置/5.png" alt=""></p>
<hr>
<h1 id="5-环境配置"><a href="#5-环境配置" class="headerlink" title="5.环境配置"></a>5.环境配置</h1><p>右键我的电脑——高级系统设置-环境变量，在path选项下新建如下几项，根据你pcl安装的位置来：<br><img src="/blog_img/PCL配置/6.jpg" alt=""></p>
<p>比如我的：<br>C:\Program Files\PCL 1.11.0\bin<br>C:\Program Files\PCL 1.11.0\3rdParty\FLANN\bin<br>C:\Program Files\PCL 1.11.0\3rdParty\Qhull\bin<br>C:\Program Files\PCL 1.11.0\3rdParty\VTK\bin<br>C:\Program Files\PCL 1.11.0\3rdParty\OpenNI2\Tools<br>C:\Program Files\PCL 1.11.0\3rdParty\OpenNI2\Redist</p>
<p>在系统变量下，配置如下图：<br><img src="/blog_img/PCL配置/6.png" alt=""><br>比如我的：<br>C:\Program Files\PCL 1.11.0\3rdParty\FLANN\bin<br>C:\Program Files\PCL 1.11.0\3rdParty\OpenNI2\Tools<br>C:\Program Files\PCL 1.11.0\3rdParty\Qhull\bin<br>C:\Program Files\PCL 1.11.0\3rdParty\VTK\bin<br>C:\Program Files\PCL 1.11.0\bin</p>
<hr>
<h1 id="6-cmake编译"><a href="#6-cmake编译" class="headerlink" title="6.cmake编译"></a>6.cmake编译</h1><p>以管理员身份运行cmake-gui<br>在你想要的文件下创建一个名为example的文件夹，然后在此目录下创建一个source和cmake_bin文件，比如我的：</p>
<p><img src="/blog_img/PCL配置/18.png" alt=""></p>
<p>在source里面创建一个cpp文件和CMakeLists.txt文件。<br>CmakeLists.txt里写入以下内容：</p>
<pre><code>cmake_minimum_required(VERSION 2.6 FATAL_ERROR)
project(test)
find_package(PCL 1.4 REQUIRED)
include_directories($&#123;PCL_INCLUDE_DIRS&#125;)
link_directories($&#123;PCL_LIBRARY_DIRS&#125;)  
add_definitions($&#123;PCL_DEFINITIONS&#125;)
add_executable (test test.cpp)
target_link_libraries (test $&#123;PCL_LIBRARIES&#125;)
</code></pre><p>其中这个test就是你创建的测试代码的名字，请保持一致，如果你换别的名字，请把txt文件的名字也一起改了。我的如下：<br><img src="/blog_img/PCL配置/19.png" alt=""></p>
<p>测试代码请网上去找，我用的是上一篇文件里的（里面有个D盘文件的读取可能会报错，但只要能出彩色的那个图就算配置成功了）。</p>
<p>跟着步骤添加<br><img src="/blog_img/PCL配置/20.png" alt=""></p>
<p>点击Configure，选x64<br><img src="/blog_img/PCL配置/21.jpg" alt=""></p>
<p>再点击一次configure<br><img src="/blog_img/PCL配置/22.jpg" alt=""></p>
<p>点击Generate,出现Generating done.<br><img src="/blog_img/PCL配置/23.png" alt=""></p>
<p>找到cmake_bin底下的test_sln 打开。<br><img src="/blog_img/PCL配置/24.jpg" alt=""></p>
<p>将test设置为启动项，并调试。<br><img src="/blog_img/PCL配置/25.png" alt=""></p>
<p><img src="/blog_img/PCL配置/26.jpg" alt=""></p>
<hr>
]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
  </entry>
  <entry>
    <title>Ubuntu更换源教程</title>
    <url>/2021/03/14/Ubuntu/Ubuntu%E6%9B%B4%E6%8D%A2%E6%BA%90%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p>参考<a href="https://blog.csdn.net/weixin_43876206/article/details/100924378">博客</a><br><a id="more"></a></p>
<h1 id="1-备份源列表"><a href="#1-备份源列表" class="headerlink" title="1.备份源列表"></a>1.备份源列表</h1><pre><code>sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak
</code></pre><h1 id="2-打开sources-list文件"><a href="#2-打开sources-list文件" class="headerlink" title="2.打开sources.list文件"></a>2.打开sources.list文件</h1><pre><code>sudo gedit /etc/apt/sources.list
</code></pre><h1 id="3-修改sources-list文件"><a href="#3-修改sources-list文件" class="headerlink" title="3.修改sources.list文件"></a>3.修改sources.list文件</h1><pre><code>#  阿里镜像源

deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse

deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse

deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse

deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse

deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse
</code></pre><h1 id="4-更新并升级"><a href="#4-更新并升级" class="headerlink" title="4.更新并升级"></a>4.更新并升级</h1><pre><code>sudo apt-get update &amp;&amp; sudo apt-get upgrade
</code></pre><h1 id="5-恢复源列表"><a href="#5-恢复源列表" class="headerlink" title="5.恢复源列表"></a>5.恢复源列表</h1><pre><code>sudo cp /etc/apt/sources.list.bak /etc/apt/sources.list
</code></pre><hr>
<p>其他的源请自己搜索，这里只放了阿里云的。</p>
<hr>
]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
  </entry>
  <entry>
    <title>PCL-1-11-Visual-Studio-2019-配置</title>
    <url>/2020/10/04/PCL/PCL-1-11-Visual-Studio-2019-%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="1-软件准备"><a href="#1-软件准备" class="headerlink" title="1.软件准备"></a>1.软件准备</h1><p>1.All in one 安装包。</p>
<p>2.获取All in one 包对应得PDB文件包，用于后期单步调试。<br><a id="more"></a><br>3.获取PCL源码包</p>
<p>4.安装Visual studio 2019编译器</p>
<p><img src="/blog_img/PCL配置/1.jpg" alt="示意图"></p>
<hr>
<h1 id="2-链接"><a href="#2-链接" class="headerlink" title="2.链接"></a>2.链接</h1><p><a href="https://github.com/PointCloudLibrary/pcl/releases">pcl下载地址</a><br><a href="https://visualstudio.microsoft.com/zh-hans/downloads/">visual studio下载地址</a></p>
<hr>
<h1 id="3-安装事项"><a href="#3-安装事项" class="headerlink" title="3.安装事项"></a>3.安装事项</h1><p>为了方便配置，pcl安装目录尽量默认，不默认后续添加目录需要选择对应的位置。</p>
<p>pcl安装请一定选择创建系统路径，visual studio和cmake安装位置随意，其他选项默认即可。</p>
<p>pcl安装完成后，请把下载的pcd文件解压，如下图：<br><img src="/blog_img/PCL配置/2.jpg" alt=""></p>
<p>将所有文件复制，安装到pcl下的BIN文件下<br><img src="/blog_img/PCL配置/3.jpg" alt=""></p>
<p>检查pcl安装目录下的 3rdParty-OpenNI2是否只有一个安装包（我的是这样），这可能是事先安装过SDK的原因，请卸载了重新安装在OpenNI2下，安装完成如下图：<br><img src="/blog_img/PCL配置/4.jpg" alt=""></p>
<hr>
<h1 id="4-关于Visual-studio安装项目"><a href="#4-关于Visual-studio安装项目" class="headerlink" title="4.关于Visual studio安装项目"></a>4.关于Visual studio安装项目</h1><p>我安装了这些负载</p>
<p><img src="/blog_img/PCL配置/5.png" alt=""></p>
<hr>
<h1 id="5-环境配置"><a href="#5-环境配置" class="headerlink" title="5.环境配置"></a>5.环境配置</h1><p>右键我的电脑——高级系统设置-环境变量，在path选项下新建如下几项，根据你pcl安装的位置来：<br><img src="/blog_img/PCL配置/6.jpg" alt=""></p>
<p>比如我的：<br>C:\Program Files\PCL 1.11.0\bin<br>C:\Program Files\PCL 1.11.0\3rdParty\FLANN\bin<br>C:\Program Files\PCL 1.11.0\3rdParty\Qhull\bin<br>C:\Program Files\PCL 1.11.0\3rdParty\VTK\bin<br>C:\Program Files\PCL 1.11.0\3rdParty\OpenNI2\Tools<br>C:\Program Files\PCL 1.11.0\3rdParty\OpenNI2\Redist</p>
<p>在系统变量下，配置如下图：<br><img src="/blog_img/PCL配置/6.png" alt=""><br>比如我的：<br>C:\Program Files\PCL 1.11.0\3rdParty\FLANN\bin<br>C:\Program Files\PCL 1.11.0\3rdParty\OpenNI2\Tools<br>C:\Program Files\PCL 1.11.0\3rdParty\Qhull\bin<br>C:\Program Files\PCL 1.11.0\3rdParty\VTK\bin<br>C:\Program Files\PCL 1.11.0\bin</p>
<hr>
<h1 id="6-配置"><a href="#6-配置" class="headerlink" title="6.配置"></a>6.配置</h1><p>打开visual studio，新建一个空项目如图：<br><img src="/blog_img/PCL配置/7.jpg" alt=""></p>
<p>在release下创建属性表（如果是DEBUG版本请在DEBUG下创建）<br><img src="/blog_img/PCL配置/8.png" alt=""></p>
<p>切换到解决方案资源管理器，右键-添加-新建项<br><img src="/blog_img/PCL配置/9.png" alt=""></p>
<p>添加C++文件<br><img src="/blog_img/PCL配置/10.png" alt=""></p>
<p>接下来配置：<br><img src="/blog_img/PCL配置/11.png" alt=""></p>
<p>包含目录下添加，建议手点：<br>C:\Program Files\PCL 1.11.0\include\pcl-1.11<br>C:\Program Files\PCL 1.11.0\3rdParty\Boost\include\boost-1_73<br>C:\Program Files\PCL 1.11.0\3rdParty\Eigen\eigen3<br>C:\Program Files\PCL 1.11.0\3rdParty\FLANN\include<br>C:\Program Files\PCL 1.11.0\3rdParty\Qhull\include<br>C:\Program Files\PCL 1.11.0\3rdParty\VTK\include\vtk-8.2<br>C:\Program Files\PCL 1.11.0\3rdParty\OpenNI2\Include</p>
<p>库目录添加：<br>C:\Program Files\PCL 1.11.0\lib<br>C:\Program Files\PCL 1.11.0\3rdParty\Boost\lib<br>C:\Program Files\PCL 1.11.0\3rdParty\FLANN\lib<br>C:\Program Files\PCL 1.11.0\3rdParty\Qhull\lib<br>C:\Program Files\PCL 1.11.0\3rdParty\VTK\lib<br>C:\Program Files\PCL 1.11.0\3rdParty\OpenNI2\Lib</p>
<p>接下来配置：<br><img src="/blog_img/PCL配置/12.jpg" alt=""></p>
<p>在预处理器定义处添加：<br>BOOST_USE_WINDOWS_H<br>NOMINMAX<br>_CRT_SECURE_NO_DEPRECATE</p>
<p>在项目属性表（Project_one）和release下创建得属性表（test_one）中把所有选项里得SDL检查全改成否，如下图：</p>
<p><img src="/blog_img/PCL配置/13.jpg" alt=""></p>
<p><img src="/blog_img/PCL配置/14.jpg" alt=""></p>
<hr>
<h1 id="7-附加依赖项"><a href="#7-附加依赖项" class="headerlink" title="7.附加依赖项"></a>7.附加依赖项</h1><p>将PCL 1.11.0\3rdParty\VTK\lib和PCL 1.11.0\lib这两个文件夹下的lib文件的release版本添加到附加依赖项中（DEBUG版本添加DEBUG类型文件）</p>
<p><img src="/blog_img/PCL配置/15.png" alt=""></p>
<p>文件名称我已经归类好了</p>
<p>release版本：</p>
<p>pcl_common.lib<br>pcl_features.lib<br>pcl_filters.lib<br>pcl_io.lib<br>pcl_io_ply.lib<br>pcl_kdtree.lib<br>pcl_keypoints.lib<br>pcl_ml.lib<br>pcl_octree.lib<br>pcl_outofcore.lib<br>pcl_people.lib<br>pcl_recognition.lib<br>pcl_registration.lib<br>pcl_sample_consensus.lib<br>pcl_search.lib<br>pcl_segmentation.lib<br>pcl_stereo.lib<br>pcl_surface.lib<br>pcl_tracking.lib<br>pcl_visualization.lib<br>vtkChartsCore-8.2.lib<br>vtkCommonColor-8.2.lib<br>vtkCommonComputationalGeometry-8.2.lib<br>vtkCommonCore-8.2.lib<br>vtkCommonDataModel-8.2.lib<br>vtkCommonExecutionModel-8.2.lib<br>vtkCommonMath-8.2.lib<br>vtkCommonMisc-8.2.lib<br>vtkCommonSystem-8.2.lib<br>vtkCommonTransforms-8.2.lib<br>vtkDICOMParser-8.2.lib<br>vtkDomainsChemistry-8.2.lib<br>vtkDomainsChemistryOpenGL2-8.2.lib<br>vtkdoubleconversion-8.2.lib<br>vtkexodusII-8.2.lib<br>vtkexpat-8.2.lib<br>vtkFiltersAMR-8.2.lib<br>vtkFiltersCore-8.2.lib<br>vtkFiltersExtraction-8.2.lib<br>vtkFiltersFlowPaths-8.2.lib<br>vtkFiltersGeneral-8.2.lib<br>vtkFiltersGeneric-8.2.lib<br>vtkFiltersGeometry-8.2.lib<br>vtkFiltersHybrid-8.2.lib<br>vtkFiltersHyperTree-8.2.lib<br>vtkFiltersImaging-8.2.lib<br>vtkFiltersModeling-8.2.lib<br>vtkFiltersParallel-8.2.lib<br>vtkFiltersParallelImaging-8.2.lib<br>vtkFiltersPoints-8.2.lib<br>vtkFiltersProgrammable-8.2.lib<br>vtkFiltersSelection-8.2.lib<br>vtkFiltersSMP-8.2.lib<br>vtkFiltersSources-8.2.lib<br>vtkFiltersStatistics-8.2.lib<br>vtkFiltersTexture-8.2.lib<br>vtkFiltersTopology-8.2.lib<br>vtkFiltersVerdict-8.2.lib<br>vtkfreetype-8.2.lib<br>vtkGeovisCore-8.2.lib<br>vtkgl2ps-8.2.lib<br>vtkglew-8.2.lib<br>vtkGUISupportMFC-8.2.lib<br>vtkhdf5_hl-8.2.lib<br>vtkhdf5-8.2.lib<br>vtkImagingColor-8.2.lib<br>vtkImagingCore-8.2.lib<br>vtkImagingFourier-8.2.lib<br>vtkImagingGeneral-8.2.lib<br>vtkImagingHybrid-8.2.lib<br>vtkImagingMath-8.2.lib<br>vtkImagingMorphological-8.2.lib<br>vtkImagingSources-8.2.lib<br>vtkImagingStatistics-8.2.lib<br>vtkImagingStencil-8.2.lib<br>vtkInfovisCore-8.2.lib<br>vtkInfovisLayout-8.2.lib<br>vtkInteractionImage-8.2.lib<br>vtkInteractionStyle-8.2.lib<br>vtkInteractionWidgets-8.2.lib<br>vtkIOAMR-8.2.lib<br>vtkIOAsynchronous-8.2.lib<br>vtkIOCityGML-8.2.lib<br>vtkIOCore-8.2.lib<br>vtkIOEnSight-8.2.lib<br>vtkIOExodus-8.2.lib<br>vtkIOExport-8.2.lib<br>vtkIOExportOpenGL2-8.2.lib<br>vtkIOExportPDF-8.2.lib<br>vtkIOGeometry-8.2.lib<br>vtkIOImage-8.2.lib<br>vtkIOImport-8.2.lib<br>vtkIOInfovis-8.2.lib<br>vtkIOLegacy-8.2.lib<br>vtkIOLSDyna-8.2.lib<br>vtkIOMINC-8.2.lib<br>vtkIOMovie-8.2.lib<br>vtkIONetCDF-8.2.lib<br>vtkIOParallel-8.2.lib<br>vtkIOParallelXML-8.2.lib<br>vtkIOPLY-8.2.lib<br>vtkIOSegY-8.2.lib<br>vtkIOSQL-8.2.lib<br>vtkIOTecplotTable-8.2.lib<br>vtkIOVeraOut-8.2.lib<br>vtkIOVideo-8.2.lib<br>vtkIOXML-8.2.lib<br>vtkIOXMLParser-8.2.lib<br>vtkjpeg-8.2.lib<br>vtkjsoncpp-8.2.lib<br>vtklibharu-8.2.lib<br>vtklibxml2-8.2.lib<br>vtklz4-8.2.lib<br>vtklzma-8.2.lib<br>vtkmetaio-8.2.lib<br>vtkNetCDF-8.2.lib<br>vtkogg-8.2.lib<br>vtkParallelCore-8.2.lib<br>vtkpng-8.2.lib<br>vtkproj-8.2.lib<br>vtkpugixml-8.2.lib<br>vtkRenderingAnnotation-8.2.lib<br>vtkRenderingContext2D-8.2.lib<br>vtkRenderingContextOpenGL2-8.2.lib<br>vtkRenderingCore-8.2.lib<br>vtkRenderingExternal-8.2.lib<br>vtkRenderingFreeType-8.2.lib<br>vtkRenderingGL2PSOpenGL2-8.2.lib<br>vtkRenderingImage-8.2.lib<br>vtkRenderingLabel-8.2.lib<br>vtkRenderingLOD-8.2.lib<br>vtkRenderingOpenGL2-8.2.lib<br>vtkRenderingVolume-8.2.lib<br>vtkRenderingVolumeOpenGL2-8.2.lib<br>vtksqlite-8.2.lib<br>vtksys-8.2.lib<br>vtktheora-8.2.lib<br>vtktiff-8.2.lib<br>vtkverdict-8.2.lib<br>vtkViewsContext2D-8.2.lib<br>vtkViewsCore-8.2.lib<br>vtkViewsInfovis-8.2.lib<br>vtkzlib-8.2.lib</p>
<p>DEBUG版本：</p>
<p>pcl_commond.lib<br>pcl_featuresd.lib<br>pcl_filtersd.lib<br>pcl_io_plyd.lib<br>pcl_iod.lib<br>pcl_kdtreed.lib<br>pcl_keypointsd.lib<br>pcl_mld.lib<br>pcl_octreed.lib<br>pcl_outofcored.lib<br>pcl_peopled.lib<br>pcl_recognitiond.lib<br>pcl_registrationd.lib<br>pcl_sample_consensusd.lib<br>pcl_searchd.lib<br>pcl_segmentationd.lib<br>pcl_stereod.lib<br>pcl_surfaced.lib<br>pcl_trackingd.lib<br>pcl_visualizationd.lib<br>vtkChartsCore-8.2-gd.lib<br>vtkCommonColor-8.2-gd.lib<br>vtkCommonComputationalGeometry-8.2-gd.lib<br>vtkCommonCore-8.2-gd.lib<br>vtkCommonDataModel-8.2-gd.lib<br>vtkCommonExecutionModel-8.2-gd.lib<br>vtkCommonMath-8.2-gd.lib<br>vtkCommonMisc-8.2-gd.lib<br>vtkCommonSystem-8.2-gd.lib<br>vtkCommonTransforms-8.2-gd.lib<br>vtkDICOMParser-8.2-gd.lib<br>vtkDomainsChemistry-8.2-gd.lib<br>vtkDomainsChemistryOpenGL2-8.2-gd.lib<br>vtkdoubleconversion-8.2-gd.lib<br>vtkexodusII-8.2-gd.lib<br>vtkexpat-8.2-gd.lib<br>vtkFiltersAMR-8.2-gd.lib<br>vtkFiltersCore-8.2-gd.lib<br>vtkFiltersExtraction-8.2-gd.lib<br>vtkFiltersFlowPaths-8.2-gd.lib<br>vtkFiltersGeneral-8.2-gd.lib<br>vtkFiltersGeneric-8.2-gd.lib<br>vtkFiltersGeometry-8.2-gd.lib<br>vtkFiltersHybrid-8.2-gd.lib<br>vtkFiltersHyperTree-8.2-gd.lib<br>vtkFiltersImaging-8.2-gd.lib<br>vtkFiltersModeling-8.2-gd.lib<br>vtkFiltersParallel-8.2-gd.lib<br>vtkFiltersParallelImaging-8.2-gd.lib<br>vtkFiltersPoints-8.2-gd.lib<br>vtkFiltersProgrammable-8.2-gd.lib<br>vtkFiltersSelection-8.2-gd.lib<br>vtkFiltersSMP-8.2-gd.lib<br>vtkFiltersSources-8.2-gd.lib<br>vtkFiltersStatistics-8.2-gd.lib<br>vtkFiltersTexture-8.2-gd.lib<br>vtkFiltersTopology-8.2-gd.lib<br>vtkFiltersVerdict-8.2-gd.lib<br>vtkfreetype-8.2-gd.lib<br>vtkGeovisCore-8.2-gd.lib<br>vtkgl2ps-8.2-gd.lib<br>vtkglew-8.2-gd.lib<br>vtkGUISupportMFC-8.2-gd.lib<br>vtkhdf5_hl-8.2-gd.lib<br>vtkhdf5-8.2-gd.lib<br>vtkImagingColor-8.2-gd.lib<br>vtkImagingCore-8.2-gd.lib<br>vtkImagingFourier-8.2-gd.lib<br>vtkImagingGeneral-8.2-gd.lib<br>vtkImagingHybrid-8.2-gd.lib<br>vtkImagingMath-8.2-gd.lib<br>vtkImagingMorphological-8.2-gd.lib<br>vtkImagingSources-8.2-gd.lib<br>vtkImagingStatistics-8.2-gd.lib<br>vtkImagingStencil-8.2-gd.lib<br>vtkInfovisCore-8.2-gd.lib<br>vtkInfovisLayout-8.2-gd.lib<br>vtkInteractionImage-8.2-gd.lib<br>vtkInteractionStyle-8.2-gd.lib<br>vtkInteractionWidgets-8.2-gd.lib<br>vtkIOAMR-8.2-gd.lib<br>vtkIOAsynchronous-8.2-gd.lib<br>vtkIOCityGML-8.2-gd.lib<br>vtkIOCore-8.2-gd.lib<br>vtkIOEnSight-8.2-gd.lib<br>vtkIOExodus-8.2-gd.lib<br>vtkIOExport-8.2-gd.lib<br>vtkIOExportOpenGL2-8.2-gd.lib<br>vtkIOExportPDF-8.2-gd.lib<br>vtkIOGeometry-8.2-gd.lib<br>vtkIOImage-8.2-gd.lib<br>vtkIOImport-8.2-gd.lib<br>vtkIOInfovis-8.2-gd.lib<br>vtkIOLegacy-8.2-gd.lib<br>vtkIOLSDyna-8.2-gd.lib<br>vtkIOMINC-8.2-gd.lib<br>vtkIOMovie-8.2-gd.lib<br>vtkIONetCDF-8.2-gd.lib<br>vtkIOParallel-8.2-gd.lib<br>vtkIOParallelXML-8.2-gd.lib<br>vtkIOPLY-8.2-gd.lib<br>vtkIOSegY-8.2-gd.lib<br>vtkIOSQL-8.2-gd.lib<br>vtkIOTecplotTable-8.2-gd.lib<br>vtkIOVeraOut-8.2-gd.lib<br>vtkIOVideo-8.2-gd.lib<br>vtkIOXML-8.2-gd.lib<br>vtkIOXMLParser-8.2-gd.lib<br>vtkjpeg-8.2-gd.lib<br>vtkjsoncpp-8.2-gd.lib<br>vtklibharu-8.2-gd.lib<br>vtklibxml2-8.2-gd.lib<br>vtklz4-8.2-gd.lib<br>vtklzma-8.2-gd.lib<br>vtkmetaio-8.2-gd.lib<br>vtkNetCDF-8.2-gd.lib<br>vtkogg-8.2-gd.lib<br>vtkParallelCore-8.2-gd.lib<br>vtkpng-8.2-gd.lib<br>vtkproj-8.2-gd.lib<br>vtkpugixml-8.2-gd.lib<br>vtkRenderingAnnotation-8.2-gd.lib<br>vtkRenderingContext2D-8.2-gd.lib<br>vtkRenderingContextOpenGL2-8.2-gd.lib<br>vtkRenderingCore-8.2-gd.lib<br>vtkRenderingExternal-8.2-gd.lib<br>vtkRenderingFreeType-8.2-gd.lib<br>vtkRenderingGL2PSOpenGL2-8.2-gd.lib<br>vtkRenderingImage-8.2-gd.lib<br>vtkRenderingLabel-8.2-gd.lib<br>vtkRenderingLOD-8.2-gd.lib<br>vtkRenderingOpenGL2-8.2-gd.lib<br>vtkRenderingVolume-8.2-gd.lib<br>vtkRenderingVolumeOpenGL2-8.2-gd.lib<br>vtksqlite-8.2-gd.lib<br>vtksys-8.2-gd.lib<br>vtktheora-8.2-gd.lib<br>vtktiff-8.2-gd.lib<br>vtkverdict-8.2-gd.lib<br>vtkViewsContext2D-8.2-gd.lib<br>vtkViewsCore-8.2-gd.lib<br>vtkViewsInfovis-8.2-gd.lib<br>vtkzlib-8.2-gd.lib</p>
<h1 id="8-程序测试"><a href="#8-程序测试" class="headerlink" title="8.程序测试"></a>8.程序测试</h1><pre><code>#include &lt;pcl/visualization/cloud_viewer.h&gt;  
#include &lt;iostream&gt;  
#include &lt;pcl/io/io.h&gt;  
#include &lt;pcl/io/pcd_io.h&gt;  
int user_data;
void viewerOneOff(pcl::visualization::PCLVisualizer&amp; viewer)
&#123;
    viewer.setBackgroundColor(1.0, 0.5, 1.0);
    pcl::PointXYZ o;
    o.x = 1.0;
    o.y = 0;
    o.z = 0;
    viewer.addSphere(o, 0.25, &quot;sphere&quot;, 0);
    std::cout &lt;&lt; &quot;i only run once&quot; &lt;&lt; std::endl;
&#125;
void viewerPsycho(pcl::visualization::PCLVisualizer&amp; viewer)
&#123;
    static unsigned count = 0;
    std::stringstream ss;
    ss &lt;&lt; &quot;Once per viewer loop: &quot; &lt;&lt; count++;
    viewer.removeShape(&quot;text&quot;, 0);
    viewer.addText(ss.str(), 200, 300, &quot;text&quot;, 0);
    //FIXME: possible race condition here:  
    user_data++;
&#125;
int main()
&#123;
    pcl::PointCloud&lt;pcl::PointXYZRGBA&gt;::Ptr cloud(new pcl::PointCloud&lt;pcl::PointXYZRGBA&gt;);
    pcl::io::loadPCDFile(&quot;D:\\Microsoft Visual Studio 10.0\\Projects\\pcl\\pcl\\my_point_cloud.pcd&quot;, *cloud);
    pcl::visualization::CloudViewer viewer(&quot;Cloud Viewer&quot;);
    //blocks until the cloud is actually rendered  
    viewer.showCloud(cloud);
    //use the following functions to get access to the underlying more advanced/powerful  
    //PCLVisualizer  
    //This will only get called once  
    viewer.runOnVisualizationThreadOnce(viewerOneOff);
    //This will get called once per visualization iteration  
    viewer.runOnVisualizationThread(viewerPsycho);
    while (!viewer.wasStopped())
    &#123;
        //you can also do cool processing here  
        //FIXME: Note that this is running in a separate thread from viewerPsycho  
        //and you should guard against race conditions yourself...  
        user_data++;
    &#125;
    return 0;
&#125;
</code></pre><p>测试结果：</p>
<p><img src="/blog_img/PCL配置/16.png" alt=""></p>
<hr>
]]></content>
      <categories>
        <category>PCL</category>
      </categories>
  </entry>
  <entry>
    <title>Unable to access &#39;https://gitee.com/自己的项目/&#39;: Could not resolve host: gitee.com问题的解决</title>
    <url>/2020/10/23/Ubuntu/Unable-to-access-https-gitee-com-%E8%87%AA%E5%B7%B1%E7%9A%84%E9%A1%B9%E7%9B%AE-Could-not-resolve-host-gitee-com%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<p>果然玩hexo报错是在所难免，就好像我已经长大，读研以后乃至以后得日子，可能总是繁琐常伴。今天在hexo d推到GITEE上时，报了错。<br><a id="more"></a><br>原因是由于爬梯子代理网络的问题，其实折腾了下。具体哪个步骤解决了这个问题，我也不是很清楚，这次做好记录方便以后继续更新把。</p>
<p>首先我是从这篇<a href="https://blog.csdn.net/weixin_37166398/article/details/101422239?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param">博客</a>里查到了我的ip，然后ping了查到的ip，然后在system32\drives\etc\hosts里添加了   </p>
<pre><code>IP gitee.com
</code></pre><p>然而这并没有继续运行成功。<br>然后我有尝试<br>1.管理员身份运行cmd<br>2.输入 </p>
<pre><code>netsh winsock reset
</code></pre><p>3.重启</p>
<p>还有尝试命令行输入  </p>
<pre><code>git config --global --unset http.proxy 
git config --global --unset https.proxy
</code></pre><p>最后发现还是不行，结果我把第一步添加的IP gitee.com删了居然好了。</p>
<p>所以我觉得问题在以下原因，第一个是我没有在打开代理下hexo d,平时确实是没有注意这个问题，但关闭代理下好像有时候也成功过，但这个问题确实出在了代理的问题上。<br>另外就是我的代理导致了无法上传上去，上述的两个操作我也不知道哪个解决了这个问题，毕竟我先添加了IP，然后再试了这两种清楚的。如果下次再出现这个问题，有了结果再继续补充。</p>
<p>2020/11/17<br>他妈个头的，翻墙今天又部署不上去了，前面的用了也不好使，又试了一下这个更改DNS的方法成功了，<a href="https://blog.csdn.net/weixin_42476786/article/details/82691934?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.add_param_isCf&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.add_param_isCf">链接</a>在这</p>
<hr>
]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
  </entry>
  <entry>
    <title>ubuntu下的firefox无法播放视频解决方案</title>
    <url>/2021/03/14/Ubuntu/ubuntu%E4%B8%8B%E7%9A%84firefox%E6%97%A0%E6%B3%95%E6%92%AD%E6%94%BE%E8%A7%86%E9%A2%91%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h1 id="1-下载flash的tar-gz文件"><a href="#1-下载flash的tar-gz文件" class="headerlink" title="1.下载flash的tar.gz文件"></a>1.下载flash的tar.gz文件</h1><p>直接去<a href="https://www.flash.cn/">官网链接</a>下载<br><a id="more"></a></p>
<h1 id="2-解压tar-gz文件"><a href="#2-解压tar-gz文件" class="headerlink" title="2.解压tar.gz文件"></a>2.解压tar.gz文件</h1><pre><code>tar -zxvf filename.tar.gz
</code></pre><p>注意filename.tar.gz就是你下载的文件的名字，可以直接复制下载包名字。</p>
<h1 id="3-移动解压文件夹"><a href="#3-移动解压文件夹" class="headerlink" title="3.移动解压文件夹"></a>3.移动解压文件夹</h1><p>先进入安装包目录下,然后</p>
<pre><code>sudo cp libflashplayer.so /usr/lib/firefox/browser/plugins
sudo cp -r usr/* /usr
</code></pre><h1 id="4-缺少依赖报错解决"><a href="#4-缺少依赖报错解决" class="headerlink" title="4.缺少依赖报错解决"></a>4.缺少依赖报错解决</h1><pre><code>sudo apt-get install ffmpeg  //ffmpeg支持H.264解码
</code></pre><hr>
]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
  </entry>
  <entry>
    <title>dpkg被中断的解决办法</title>
    <url>/2021/03/14/Ubuntu/dpkg%E8%A2%AB%E4%B8%AD%E6%96%AD%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    <content><![CDATA[<p>linux系统安装软件是有时会碰到“dpkg 被中断,您必须手工运行 sudo dpkg –configure -a解决此问题”，然而按照提示运行却并没能很好的解决问题。其实导致这个问题的主要原因是因为/var/lib/dpkg/updates文件下的文件有问题，可能是其他软件安装过程或是其他原因导致的，这里删除掉然后重建即可。<br><a id="more"></a></p>
<pre><code>sudo rm /var/lib/dpkg/updates/*
sudo apt-get update
sudo apt-get upgrade
</code></pre><p>解释：[<em>]sudo apt-get update指令会重新建立这些资料，所以不必担心删除后会出问题；<br>[</em>]sudo apt-get upgrade会更新你的电脑里面已安装的软件的明细，根据软件的明细更新软件到最新版。<br>PS：“dpkg ”是“Debian Packager ”的简写。为 “Debian” 专门开发的套件管理系统，方便软件的安装、更新及移除。所有源自“Debian”的“Linux ”发行版都使用 “dpkg”</p>
<p>参考<a href="https://blog.csdn.net/coolcooljob/article/details/79964812">博客</a></p>
<hr>
]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
  </entry>
  <entry>
    <title>ubuntu安装gcc依赖关系报错</title>
    <url>/2021/03/14/Ubuntu/ubuntu%E5%AE%89%E8%A3%85gcc%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB%E6%8A%A5%E9%94%99/</url>
    <content><![CDATA[<p>使用aptitude包依赖管理工具替代apt处理，看其他的博客说这个得慎用，不过用来安装gcc倒是没啥问题。<br><a id="more"></a></p>
<pre><code>sudo apt-get install aptitude
sudo aptitude install gcc g++
</code></pre><p>解决方案里选择no,yes,yes.<br>参考<a href="https://blog.csdn.net/CLZHIT/article/details/104508894">博客</a></p>
<hr>
]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
  </entry>
  <entry>
    <title>ubuntu下解决wps2019缺少字体问题</title>
    <url>/2021/03/14/Ubuntu/ubuntu%E4%B8%8B%E8%A7%A3%E5%86%B3wps2019%E7%BC%BA%E5%B0%91%E5%AD%97%E4%BD%93%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>主要参考<a href="https://blog.csdn.net/sunmengke1101/article/details/103436997">博客</a><br><a id="more"></a></p>
<h1 id="1-准备字体包"><a href="#1-准备字体包" class="headerlink" title="1.准备字体包"></a>1.准备字体包</h1><p><a href="https://wws.lanzous.com/iBIiqmwnvve">下载链接</a></p>
<h1 id="2-解压到指定目录下"><a href="#2-解压到指定目录下" class="headerlink" title="2.解压到指定目录下"></a>2.解压到指定目录下</h1><pre><code>sudo unzip wps_symbol_fonts.zip -d /home/&lt;user&gt;/usr/share/fonts
</code></pre><h1 id="3-到解压的根目录下安装"><a href="#3-到解压的根目录下安装" class="headerlink" title="3.到解压的根目录下安装"></a>3.到解压的根目录下安装</h1><p>依次打开每个文件并点击安装即可</p>
<hr>
]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
  </entry>
  <entry>
    <title>ubuntu安装vim依赖关系报错</title>
    <url>/2021/03/14/Ubuntu/ubuntu%E5%AE%89%E8%A3%85vim%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB%E6%8A%A5%E9%94%99/</url>
    <content><![CDATA[<p>按如下步骤进行就可：<br><a id="more"></a></p>
<pre><code>sudo apt-get purge vim-common
sudo apt-get update
sudo apt-get upgrade
sudo apt-get install vim
</code></pre><hr>
]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
  </entry>
  <entry>
    <title>安装snap以及常用命令</title>
    <url>/2021/03/14/Ubuntu/%E5%AE%89%E8%A3%85snap/</url>
    <content><![CDATA[<h1 id="1-安装snap"><a href="#1-安装snap" class="headerlink" title="1.安装snap"></a>1.安装snap</h1><a id="more"></a>
<pre><code>sudo apt-get install snapd
sudo apt-get install snapcraft
</code></pre><h1 id="2-常用命令"><a href="#2-常用命令" class="headerlink" title="2.常用命令"></a>2.常用命令</h1><pre><code>//列出已经安装的snap包
sudo snap list

//搜索要安装的snap包
sudo snap find &lt;text to search&gt;

//安装一个snap包
sudo snap install &lt;snap name&gt;

//更新一个snap包，如果你后面不加包的名字的话那就是更新所有的snap包
sudo snap refresh &lt;snap name&gt;

//把一个包还原到以前安装的版本
sudo snap revert &lt;snap name&gt;

//删除一个snap包
sudo snap remove &lt;snap name&gt;
</code></pre><hr>
]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
  </entry>
  <entry>
    <title>我的Office激活码</title>
    <url>/2020/09/26/%E5%85%B6%E4%BB%96/%E6%88%91%E7%9A%84Office%E6%BF%80%E6%B4%BB%E7%A0%81/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">Enter password to read.</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="03c1ac4465e4cf3a48495d4bf2e5305f5459e5aa002e29362a916042d55d3feb">a40b706f3ef3cecdee82bde9ce2bd4514c0daefd2ecc9a0471c6dd32fb89c21dd33d989c9838561713a671711864b0b1a1a4480b4508e9ff8837f455c5dce0fe5f300a44bdd7e4e87f4cf4ad6a977b3a2e1fb4941673530eba42a436b7ddbc2a833161220ce856a9c50b0f0a00948c6120e291cacc8235d9112cea2d0ff237ff547ad3c0557cede69bb6e0acac70ff7e8dfd7357b4b0819f29e0b32a89991ff85dbb291e5440a99f3e89272087d1a7bad163b67007c9db378d5b7519efb4bc6adfc98224fb4ce577a17143fe36acb2235be6db2fbdd89c6784c0966f78aecbf7df789c5ac3fbdc42aad6b3332ae1ff1e862ad8340e40571113b1a0f03023896f1f4e9d0282ddc48e33f8992ebced357dfafab8477f1b7ddb0c479b4ef223cd7aa6c3b47bac939edf42c2ea6eeb5976a6c37e76ad4ac9a7c25cf6e5f0161cbe47578cd75de43b1fb65e794e1b15d764b9</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <tags>
        <tag>-office</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu配置C/C++开发环境</title>
    <url>/2021/03/14/Ubuntu/ubuntu%E9%85%8D%E7%BD%AEC-C-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<h1 id="1-在代码文件夹下建立两个文件"><a href="#1-在代码文件夹下建立两个文件" class="headerlink" title="1.在代码文件夹下建立两个文件"></a>1.在代码文件夹下建立两个文件</h1><p>launch.json 以及 tasks.json<br><a id="more"></a></p>
<h1 id="2-给这个两个文件配置文件"><a href="#2-给这个两个文件配置文件" class="headerlink" title="2.给这个两个文件配置文件"></a>2.给这个两个文件配置文件</h1><p>launch.json:</p>
<pre><code>&#123;    // Use IntelliSense to learn about possible attributes.
    // Hover to view descriptions of existing attributes.
    // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387
    &quot;version&quot;: &quot;0.2.0&quot;,
    &quot;configurations&quot;: [
        &#123;
            &quot;name&quot;: &quot;(gdb) Launch&quot;,
            &quot;type&quot;: &quot;cppdbg&quot;,
            &quot;request&quot;: &quot;launch&quot;,
            &quot;program&quot;: &quot;$&#123;workspaceFolder&#125;/$&#123;fileBasenameNoExtension&#125;.out&quot;,
            &quot;args&quot;: [],
            &quot;stopAtEntry&quot;: false,
            &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;&quot;,
            &quot;environment&quot;: [],
            &quot;externalConsole&quot;: true,    //如果不要窗口弹出，在ide中显示，就设置成 false
            &quot;MIMode&quot;: &quot;gdb&quot;,
            &quot;preLaunchTask&quot;: &quot;build&quot;,   //表示预先生成一个中间文件，用于g++运行
            &quot;setupCommands&quot;: [
                &#123;
                    &quot;description&quot;: &quot;Enable pretty-printing for gdb&quot;,
                    &quot;text&quot;: &quot;-enable-pretty-printing&quot;,
                    &quot;ignoreFailures&quot;: true
                &#125;
            ]
        &#125;
    ]
&#125;
</code></pre><p>tasks.json:</p>
<pre><code>&#123;
    // See https://go.microsoft.com/fwlink/?LinkId=733558
    // for the documentation about the tasks.json format
    &quot;version&quot;: &quot;2.0.0&quot;,
    &quot;tasks&quot;: [
        &#123;
            &quot;label&quot;: &quot;build&quot;,
            &quot;type&quot;: &quot;shell&quot;,
            &quot;command&quot;: &quot;g++&quot;,
            &quot;args&quot;: [&quot;-g&quot;, &quot;$&#123;file&#125;&quot;, &quot;-std=c++11&quot;, &quot;-o&quot;, &quot;$&#123;fileBasenameNoExtension&#125;.out&quot;]    //相当于 g++ -g main.cpp -std=c++11 -o main.out
        &#125;
    ]
&#125;
</code></pre><p>参考<a href="https://blog.csdn.net/suiyueruge1314/article/details/106125949">博客</a></p>
<hr>
]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
  </entry>
  <entry>
    <title>资源</title>
    <url>/2020/10/04/%E5%85%B6%E4%BB%96/%E8%B5%84%E6%BA%90/</url>
    <content><![CDATA[<p>准备把一些资源都放在这个博客下，持续更新，有需要得自取。</p>
<h1 id="1-Linux学习笔记"><a href="#1-Linux学习笔记" class="headerlink" title="1.Linux学习笔记"></a>1.Linux学习笔记</h1><p><a href="https://wws.lanzous.com/iKIZfh7eeuh">链接</a></p>
<a id="more"></a>
<h1 id="2-cloud-compare中文版使用手册"><a href="#2-cloud-compare中文版使用手册" class="headerlink" title="2.cloud compare中文版使用手册"></a>2.cloud compare中文版使用手册</h1><p><a href="https://wws.lanzous.com/imyXlh3nide">链接</a></p>
<hr>
<h1 id="3-深度学习"><a href="#3-深度学习" class="headerlink" title="3.深度学习"></a>3.深度学习</h1><p><a href="https://www.bilibili.com/video/BV164411m79z?from=search&amp;seid=8194466955642792600">吴恩达深度学习课程</a></p>
<p><a href="https://www.kesci.com/home/project/5e20243e2823a10036b542da">吴恩达课程配套科目</a></p>
<p><a href="http://www.ai-start.com/dl2017/">吴恩达深度学习笔记</a></p>
<hr>
<h1 id="4-壁纸"><a href="#4-壁纸" class="headerlink" title="4.壁纸"></a>4.壁纸</h1><p><a href="https://wallhaven.cc/">地址</a></p>
<h1 id="5-1080p下载"><a href="#5-1080p下载" class="headerlink" title="5.1080p下载"></a>5.1080p下载</h1><p><a href="https://www.y2mate.com/en60/">下载地址</a></p>
<hr>
<h1 id="6-视频字幕下载"><a href="#6-视频字幕下载" class="headerlink" title="6.视频字幕下载"></a>6.视频字幕下载</h1><p><a href="https://www.findyoutube.net/">下载地址</a><br>版权限制，目前下载为VTT格式，需要在Subtitle Edit里将VTT转为SRT格式。</p>
<hr>
<h1 id="7-Subtitle-Edit-vvt-srt"><a href="#7-Subtitle-Edit-vvt-srt" class="headerlink" title="7.Subtitle Edit(vvt-srt)"></a>7.Subtitle Edit(vvt-srt)</h1><p><a href="https://www.nikse.dk/subtitleedit/">下载地址</a><br>可以VTT2SRT SRT2VTT,有强大的字幕编辑功能。</p>
<hr>
<h1 id="8-Arctime-制作内嵌字幕视频"><a href="#8-Arctime-制作内嵌字幕视频" class="headerlink" title="8.Arctime(制作内嵌字幕视频)"></a>8.Arctime(制作内嵌字幕视频)</h1><p><a href="https://arctime.org/">下载地址</a></p>
<h1 id="9-Snipaste"><a href="#9-Snipaste" class="headerlink" title="9.Snipaste"></a>9.Snipaste</h1><p>微软商店免费下载，可以截图、取图、可以取色。</p>
]]></content>
      <categories>
        <category>资源</category>
      </categories>
  </entry>
  <entry>
    <title>IDEA快捷键</title>
    <url>/2021/05/24/Java%E5%9F%BA%E7%A1%80/IDEA%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<p>查看类的结构：ctrl+f12</p>
<p>查看类的继承图：ctrl+alt+shift+u</p>
<p>查看函数参数：ctrl+p</p>
<p>查看函数介绍：ctrl+q</p>
<p>格式化代码：ctrl+shift+l</p>
<p>代码补全：alt+/</p>
<p>提示关键字：alt+shift+/</p>
<p>万能结错/生成返回值变量：alt+enter</p>
<p>查看继承结构：ctrl+h</p>
<p>反撤销：ctrl+shift+z</p>
<p>大小写转换：ctrl+shift+u</p>
<p>收起所有的方法：ctrl+shift+-</p>
<p>打开所有的方法：ctrl+shfit++</p>
<p>重命名：shift+f6</p>
<p>打开文件所在位置：ctrl+shift+x</p>
<p>生成try-catch等：ctrl+alt+t</p>
<p>局部变量抽取为成员变量：ctrl+alt+f</p>
<p>添加到收藏夹：alt+shift+f</p>
<p>搜索类中的错误：f2</p>
<p>复制选取：ctrl+shift+v</p>
<p>显示方法在哪调用过：ctrl+shift+h</p>
<p>快写构造函数：alt+insert</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title>面向对象高级部分</title>
    <url>/2021/05/24/Java%E5%9F%BA%E7%A1%80/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/</url>
    <content><![CDATA[<h1 id="1-类变量和类方法"><a href="#1-类变量和类方法" class="headerlink" title="1.类变量和类方法"></a>1.类变量和类方法</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><img src="https://raw.githubusercontent.com/zzygeo/images/master/image-20210512202025523.5b1j2jak19s0.png" alt="image-20210512202025523"></p>
<p>==类变量可以通过类名直接来访问==</p>
<p>==堆区 or 静态域==，需要看jdk的版本</p>
<p><img src="https://raw.githubusercontent.com/zzygeo/images/master/image-20210512203343915.2grguwvuy960.png" alt="image-20210512203343915"></p>
<p>==不管static变量在哪里，共识（1）static变量是同一个类所有对象共享 （2）static类变量，在类加载的时候就生成了==</p>
<pre><code class="lang-java">package com.zzy.static_;

public class VisitStatic &#123;
    public static void main(String[] args) &#123;
        //类变量是随着类的加载创建的,不创建对象实例也可以访问
        System.out.println(A.name);
    &#125;
&#125;

class A&#123;
    public static String name = &quot;韩顺平教育&quot;;

&#125;
</code></pre>
<p>==加上static称为类变量或静态变量，否则称为实例变量/普通变量/非静态变量==</p>
<p>==类方法也可以通过类名进行访问==</p>
<h2 id="类方法的使用场景"><a href="#类方法的使用场景" class="headerlink" title="类方法的使用场景"></a>类方法的使用场景</h2><p><img src="https://raw.githubusercontent.com/zzygeo/images/master/image-20210512210404632.1v296c255aw0.png" alt="image-20210512210404632"></p>
<h2 id="类方法的细节"><a href="#类方法的细节" class="headerlink" title="类方法的细节"></a>类方法的细节</h2><p><img src="https://raw.githubusercontent.com/zzygeo/images/master/image-20210512210636540.46e97zs0p440.png" alt="image-20210512210636540"></p>
<p><img src="https://raw.githubusercontent.com/zzygeo/images/master/image-20210512210908683.46g10ymx9a00.png" alt="image-20210512210908683"></p>
<p>==根据加载的时间来的，类在创建的时候，类变量和类方法就已经有了==，而普通变量和普通方法是在类实例的时候才出现</p>
<h1 id="2-理解main方法语法"><a href="#2-理解main方法语法" class="headerlink" title="2.理解main方法语法"></a>2.理解main方法语法</h1><p><img src="https://raw.githubusercontent.com/zzygeo/images/master/image-20210512213729148.5ze5kknxs200.png" alt="image-20210512213729148"></p>
<p><img src="https://raw.githubusercontent.com/zzygeo/images/master/image-20210512213846089.6jjxl371zzw0.png" alt="image-20210512213846089"></p>
<p>如果想在idea中也给args字符串数组传入字符串，需要在以下的窗口去传入</p>
<p><img src="https://raw.githubusercontent.com/zzygeo/images/master/image-20210512214659162.478kzo8tjtw0.png" alt="image-20210512214659162"></p>
<h1 id="3-代码块"><a href="#3-代码块" class="headerlink" title="3.代码块"></a>3.代码块</h1><h2 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h2><p><img src="https://raw.githubusercontent.com/zzygeo/images/master/image-20210512215021484.7ems24jyeeo0.png" alt="image-20210512215021484"></p>
<p><img src="https://raw.githubusercontent.com/zzygeo/images/master/image-20210512215117763.74f7ofaugik0.png" alt="image-20210512215117763"></p>
<pre><code class="lang-java">package com.zzy.codeblock_;

public class CodeBlock01 &#123;
    public static void main(String[] args) &#123;
        Movie movie1 = new Movie(&quot;你好，李焕英&quot;);
    &#125;
&#125;

class Movie&#123;
    private String name;
    private double price;
    private String director;
    //3个构造器，函数重载
    //3个构造器都有相同的语句，代码看起来比较冗余
    //可以将相同的语句放入代码块中,不管调用哪个构造器创建对象，都会先调用代码块的内容
    //代码块调用的顺序优先于构造器
    &#123;
        System.out.println(&quot;电影屏幕打开...&quot;);
        System.out.println(&quot;广告开始...&quot;);
        System.out.println(&quot;电影正式开始...&quot;);
    &#125;
    public Movie(String name) &#123;
        System.out.println(&quot;Movie(String name)构造器被调用&quot;);
        this.name = name;
    &#125;

    public Movie(double price, String director) &#123;
        this.price = price;
        this.director = director;
    &#125;

    public Movie(String name, double price, String director) &#123;
        this.name = name;
        this.price = price;
        this.director = director;
    &#125;
&#125;
</code></pre>
<p>输出结果</p>
<p><img src="https://raw.githubusercontent.com/zzygeo/images/master/image-20210512220748122.4iqixdml1fu0.png" alt="image-20210512220748122"></p>
<h2 id="代码块使用注意事项"><a href="#代码块使用注意事项" class="headerlink" title="代码块使用注意事项"></a>代码块使用注意事项</h2><p>（1）static代码块也叫静态代码块，作用就是对类进行初始化，==而且它随着类的加载而执行，并且只会执行一次。如果是普通代码块，每创建一个对象，就执行。==</p>
<p>（2）类什么时候被加载（重要）</p>
<ol>
<li>==创建对象实例时（new）==</li>
<li>==创建子类对象实例，父类也被会加载,父类先被加载，子类后被加载==</li>
<li>==使用类的静态成员时（静态属性，静态方法）==</li>
</ol>
<p>创建一个对象时，在一个类调用的顺序是：</p>
<ol>
<li>==调用静态代码块和静态属性初始化（静态代码块和静态属性初始化调用的优先级一样，如果有多个静态代码块和多个静态变量初始化，则按他们定义的顺序调用）==</li>
<li>==调用普通代码块和普通属性的初始化（普通代码块和普通属性初始化调用的优先级一样，如果有多个普通代码块和多个普通属性初始化，则按定义顺序调用）==</li>
<li>==调用构造方法==</li>
<li>==构造器的最前面其实隐含了super()和调用普通代码块==</li>
<li>当创建一个子类对象时（继承关系），他们的静态代码块，静态属性初始化，普通代码块，普通属性初始化，构造方法的调用顺序如下：</li>
</ol>
<ul>
<li>==父类的静态代码块和静态属性（优先级一样，按定义顺序执行）==</li>
<li>==子类的静态代码块和静态属性（优先级一样，按定义顺序执行）==</li>
<li>==父类的普通代码块和普通属性初始化（优先级一样，按定义顺序执行）==</li>
<li>==父类的构造方法==</li>
<li>==子类的普通代码块和普通属性初始化（优先级一样，按定义顺序执行）==</li>
<li>==子类的构造方法==</li>
</ul>
<pre><code class="lang-java">package com.zzy.codeblock_;

public class CodeBlockDetail03 &#123;
    public static void main(String[] args) &#123;
        B b = new B();
    &#125;
&#125;


class A&#123;
    public A()&#123;
        System.out.println(&quot;A的无参构造器调用&quot;); //6
    &#125;
    public static int n1 = getN1();

    public static int getN1()&#123;
        System.out.println(&quot;A的静态属性的调用&quot;); //1
        return 100;
    &#125;

    static &#123;
        System.out.println(&quot;A类的静态代码块的调用&quot;); //2
    &#125;
    &#123;
        System.out.println(&quot;A类的普通代码块调用&quot;); //5
    &#125;
&#125;

class B extends A&#123;
    public B()&#123;
        System.out.println(&quot;B类的无参构造器&quot;); //8
    &#125;
    public static int N2 = getN2();
    public static int getN2()&#123;
        System.out.println(&quot;B类的静态属性调用&quot;); //3
        return 200;
    &#125;

    static &#123;
        System.out.println(&quot;B类的静态代码块调用&quot;); //4
    &#125;

    &#123;
        System.out.println(&quot;B类的普通代码块调用&quot;); //7
    &#125;

&#125;
</code></pre>
<h1 id="4-设计模式"><a href="#4-设计模式" class="headerlink" title="4.设计模式"></a>4.设计模式</h1><h2 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h2><p>静态方法和属性的经典使用</p>
<p>设计模式是在大量的实践中总结和理论化之后优选的代码结构、编程风格、以及解决问题的思考方式。设计模式就像是经典的棋谱，不同的棋局，我们用不同的棋谱，免去我们自己再思考和摸索。</p>
<p>单例模式</p>
<p>1.所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能==存在一个对象实例==，并且该类==只提供一个取得其对象实例==的方法</p>
<p>2.单例模式有两种 1）饿汉式 2）懒汉式</p>
<h2 id="饿汉式的单例模式"><a href="#饿汉式的单例模式" class="headerlink" title="饿汉式的单例模式"></a>饿汉式的单例模式</h2><p>步骤如下:</p>
<p>1)构造器私有化 =》防止直接new</p>
<p>2)类的内部创建对象</p>
<p>3)向外暴露一个静态的公共方法</p>
<p>4)代码实现</p>
<pre><code class="lang-java">package com.zzy.Single_;

public class SingleTon01 &#123;
    public static void main(String[] args) &#123;
        GirlFriend instance1 = GirlFriend.getInstance();
        System.out.println(instance1);
        GirlFriend instance2 = GirlFriend.getInstance();
        System.out.println(instance2);
    &#125;
&#125;


//只能有一个女朋友

class GirlFriend&#123;
    private String name;
    //内部创建一个私有的
    private static GirlFriend girl = new GirlFriend(&quot;小红&quot;);
    //如何防止只能创建一个女朋友
    private GirlFriend(String name)&#123;
        this.name = name;
    &#125;
    public static GirlFriend getInstance()&#123;
        return girl;
    &#125;

    @Override
    public String toString() &#123;
        return &quot;GirlFriend&#123;&quot; +
                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +
                &#39;&#125;&#39;;
    &#125;
&#125;
</code></pre>
<h2 id="懒汉式的单例模式"><a href="#懒汉式的单例模式" class="headerlink" title="懒汉式的单例模式"></a>懒汉式的单例模式</h2><p>1)仍然构造器私有化</p>
<p>2)定义一个静态属性对象</p>
<p>3)提供一个public的static方法，可以返回一个Cat对象</p>
<p>4)只有当用户使用getInstance时，才返回cat对象，后面再次调用时，会返回上次创建的cat对象</p>
<p>饿汉式VS懒汉式</p>
<ol>
<li>二者最主要的区别在于创建对象的时机不同：饿汉式是在类加载就创建了对象实例，而懒汉式是在使用时（调用instance）才创建。</li>
<li>饿汉式不存在线程安全的问题，懒汉式存在线程安全的问题（后面学习线程后，在进行完善）</li>
<li>饿汉式存在浪费资源的可能。因为如果一个程序员一个对象实例都没有使用，那么饿汉式创建的对象就浪费了，懒汉式是使用时才创建，不存在这个问题。</li>
<li>在javaSE标准中, java.lang.Runtime就是经典的单例模式</li>
</ol>
<h1 id="5-final关键字"><a href="#5-final关键字" class="headerlink" title="5.final关键字"></a>5.final关键字</h1><h2 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h2><p>final可以修饰类、属性、方法和局部变量</p>
<p>在某些情况下，程序员可能有以下需求，就会使用到final：</p>
<p>1)当==不希望类被继承==时，可以用final修饰</p>
<p>2)当==不希望父类的某个方法被子类覆盖/重写==时，可以使用final关键字修饰。</p>
<p>3)当==不希望类的某个属性的值被修改==，可以用final修饰</p>
<p>4)当==不希望某个局部变量被修改==（比如函数里），可以使用final修饰</p>
<h2 id="final的使用细节"><a href="#final的使用细节" class="headerlink" title="final的使用细节"></a>final的使用细节</h2><p>1）final修饰的属性又叫常量，一般用XX_XX_XX来命名</p>
<p>2）final修饰的属性==在定义时，必须赋初值==，并且==以后不能再修改==，赋值可以加在如下位置之一【选择一个位置赋初值即可】</p>
<ul>
<li>==定义时==，如 public final double TAX_RATE = 0.08;</li>
<li>==在构造器中==</li>
<li>==在代码块中==</li>
</ul>
<p>3）如果==final修饰的属性是静态的==，则初始化的位置只能是 ==1. 定义时 2. 在静态代码块== 而不能在构造器中赋值(==参考类加载的先后顺序==)。</p>
<p>4）==final类不能继承，但是可以实例化对象==</p>
<p>5）如果类不是final类，但是含有final方法，则该方法虽然不可以重写，但是可以被继承。</p>
<pre><code class="lang-java">package com.zzy.final_;

public class Final01 &#123;
    public static void main(String[] args) &#123;
        //final不可以继承，但是可以实例化对象
        System.out.println(Test02.num);
        //final方法虽然不能被重写，但是可以被继承
        Test04 test04 = new Test04();
        test04.say();
    &#125;
&#125;

class Test01&#123;
    public final double TAX_RATE = 0.08; //1.在定义时赋值
    public final double TAX_RATE1;
    public final double TAX_RATE2;
    public static final double TAX_RATE3 = 0.01; //修饰静态属性，可以在定义时赋值
    public static final double TAX_RATE4; //修饰静态属性，可以在定义时赋值

    public Test01()&#123;//2.在构造器中赋值
        TAX_RATE1 = 0.8;
    &#125;
    static&#123;
        TAX_RATE4 = 0.04; //在静态代码块中可行
    &#125;

    &#123;
        //3.在代码块中赋值
        TAX_RATE2 = 0.1;
    &#125;
&#125;

final class Test02&#123;
    public static int num = 5;
&#125;

class Test03&#123;
    public final void say()&#123;
        System.out.println(&quot;Test03类的say方法&quot;);
    &#125;
&#125;

class Test04 extends Test03&#123;
    public double val = 5.0;
&#125;
</code></pre>
<p>5）一般来说，如果==一个类已经是final类了，就没有必要再将方法修饰成final==方法。</p>
<p>6）==final不能修饰构造器==</p>
<p>7）==final和static往往搭配使用==，效率更高，不会导致类加载，底层编译器做了优化处理</p>
<p>8）包装类（Integer,Double，Float, Boolean等都是final），String也是final方法</p>
<pre><code class="lang-java">package com.zzy.final_;

public class Final &#123;
    public static void main(String[] args) &#123;
        //不会导致类加载
        System.out.println(Test05.num);
    &#125;
&#125;

class Test05&#123;
    public final static int num = 5;
    static&#123;
        System.out.println(&quot;Test05的静态代码块&quot;);
    &#125;
&#125;
</code></pre>
<h1 id="6-抽象类"><a href="#6-抽象类" class="headerlink" title="6.抽象类"></a>6.抽象类</h1><h2 id="介绍-4"><a href="#介绍-4" class="headerlink" title="介绍"></a>介绍</h2><p>当父类的一些方法不能确定时，可以用abstract关键字来修饰该方法，这个方法就是抽象方法，用abstract来修饰该类就是抽象类</p>
<p>1）用abstract关键字来修饰一个类时，这个类就叫抽象类</p>
<p>2）用abstract关键字来修饰一个方法时，这个方法就是抽象方法</p>
<p>访问修饰符 abstract 返回类型 方法名(参数列表)； //没有方法体</p>
<p>3）==抽象类的价值更多作用是在于设计，是设计者设计好后，让子类继承并实现抽象类==</p>
<p>4）抽象类，是面试比较爱问的知识点，在框架和设计模式使用较多</p>
<h2 id="抽象类的细节"><a href="#抽象类的细节" class="headerlink" title="抽象类的细节"></a>抽象类的细节</h2><p>1）抽象类==不能被实例化==</p>
<p>2）抽象类不一定要包含abstract方法。也就是说，抽象类可以没有abstract方法</p>
<p>3）一旦类==包含了abstract方法，则这个类必须声明为abstract==</p>
<p>4）abstract==只能修饰类和方法，不能修饰属性和其他的==</p>
<p>5）抽象类可以由任意成员【因为抽象类还是类】，比如：非抽象方法，构造器，静态属性等</p>
<p>6）==抽象方法不能有主体==，即不能实现</p>
<p>7）如果==一个类继承了抽象类，则它必须实现抽象类的所有抽象方法==，==除非它自己也声明为abstract类==。</p>
<p>8）抽象方法不能使用private、final、static来修饰，因为这些关键字都是和重写违背的</p>
<pre><code class="lang-java">package com.zzy.Animal;

public class AbstractDetails &#123;
    public static void main(String[] args) &#123;
        //抽象类，不能被初始化
        //new A();
    &#125;
&#125;

abstract class A&#123;//抽象类的方法可以不抽象化
    public void hi()&#123;
        System.out.println(&quot;hi&quot;);
    &#125;
&#125;

//一旦类包含了abstract方法，则这个类必须声明为abstract
abstract class B&#123;
    public abstract void hi();
&#125;

class C&#123;
    //abstract只能修饰类和方法，不能修饰其他的
    //public abstract int n1 = 5;
&#125;
</code></pre>
<pre><code class="lang-java">package com.zzy.Animal;

public class AbstractDetails01 &#123;
    public static void main(String[] args) &#123;

    &#125;
&#125;

abstract class E&#123;
    public abstract void hi();
&#125;

abstract class F extends E&#123;
    //除非自己也声明为abstract类
&#125;

class G extends E&#123;
    @Override
    public void hi() &#123;//这里相当于重写父类E的抽象方法
        System.out.println(&quot;话不投机，说你妈逼&quot;);
    &#125;
&#125;
</code></pre>
<h2 id="抽象类最佳实践-模板设计模式"><a href="#抽象类最佳实践-模板设计模式" class="headerlink" title="抽象类最佳实践-模板设计模式"></a>抽象类最佳实践-模板设计模式</h2><p>需求</p>
<p>1）有多个类，完成不同的任务job</p>
<p>2）要求能够得到各自完成任务的时间</p>
<p>感情的自然流露</p>
<ol>
<li>先用最容易想到的方法</li>
<li>分析问题，提出使用模板设计模式</li>
</ol>
<p>父类</p>
<pre><code class="lang-java">package com.zzy.Animal;

abstract public class Template &#123;

    public abstract void job();

    public void calculateTime()&#123;
        long start = System.currentTimeMillis();
        job(); //这里涉及到动态绑定机制
        long end = System.currentTimeMillis();
        System.out.println(&quot;任务运行时间为：&quot; + (end - start));
    &#125;
&#125;
</code></pre>
<p>父类AA</p>
<pre><code class="lang-java">package com.zzy.Animal;

public class AA extends Template&#123;
    //计算任务
    //从1加到10000

    public void job()&#123;
        long num = 0;
        for (long i = 1; i &lt;= 800000; i++) &#123;
            num += i;
        &#125;
    &#125;
&#125;
</code></pre>
<p>子类BB</p>
<pre><code class="lang-java">package com.zzy.Animal;

public class BB extends Template&#123;

    public void job()&#123;
        long num = 0;
        for (long i = 1; i &lt;= 80000; i++) &#123;
            num *= i;
        &#125;
    &#125;
&#125;
</code></pre>
<p>测试类</p>
<pre><code class="lang-java">package com.zzy.Animal;

public class TestTemplate &#123;
    public static void main(String[] args) &#123;
        AA aa = new AA();
        aa.calculateTime();

        BB bb = new BB();
        bb.calculateTime();
    &#125;
&#125;
</code></pre>
<h1 id="7-接口"><a href="#7-接口" class="headerlink" title="7.接口"></a>7.接口</h1><h2 id="介绍-5"><a href="#介绍-5" class="headerlink" title="介绍"></a>介绍</h2><p><img src="https://raw.githubusercontent.com/zzygeo/images/master/1621823722.5mjdgmqmdco0.jpg" alt="1621823722"></p>
<h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><p>1）接口不能被实例化</p>
<p>2）接口中的所有方法是public方法，接口中抽象方法，可以不用abstract修饰</p>
<p>3）一个普通类实现接口，就必须将该接口的所有方法都实现</p>
<p>4）抽象了实现接口，可以不用实现接口的方法</p>
<p>5）一个类同时可以实现多个接口</p>
<p>6）接口中的属性，只能是final的，而且是public static final 修饰符，因此必须初始化</p>
<p>7）接口中属性的访问形式：接口名.属性名</p>
<p>8）接口不能继承其他的类，但是可以继承多个别的接口</p>
<p>9）接口的修饰符只能是public和默认，这一点和类的修饰符是一样的</p>
<p>接口和继承解决的问题不同</p>
<p>继承的价值主要在于：解决代码的复用性和可维护性</p>
<p>接口的价值主要在于：设计，设计好各种规范，让其他类去实现这些方法。即更加的灵活</p>
<p>接口比继承更加灵活</p>
<p>接口比继承更加灵活，继承是满足is -a的关系, 而接口只 需满足 like -a的关系</p>
<p>接口在一定程度上实现代码解耦（即：接口规范性+动态绑定机制）</p>
<h2 id="接口的多态特性"><a href="#接口的多态特性" class="headerlink" title="接口的多态特性"></a>接口的多态特性</h2><p>接口既可以接受A对象，又可以接受相机对象，就体现了接口，多态</p>
<p>一个接口的数组里，既可以存放A对象，也可以存放B对象，也体现了多态特性，这里还设计到向上转型和向下转型</p>
<p>接口存在多态传递现象</p>
<h1 id="8-内部类"><a href="#8-内部类" class="headerlink" title="8.内部类"></a>8.内部类</h1><h2 id="介绍-6"><a href="#介绍-6" class="headerlink" title="介绍"></a>介绍</h2><p>如果定义类在局部位置（方法/代码块）：（1）局部内部类 （2）匿名内部类</p>
<p>定义在成员位置：（1）成员内部类 （2）静态内部类</p>
<p>一个类的内部类又完整的嵌套了另一个类结构 。被嵌套的类称为内部类（inner class），嵌套其他类的类称为外部类（outer class）。是我们类的第五大成员，内部类的最大特点就是可以直接访问私有属性，并且可以体现类和类之间的包含关系，是学习的难点。</p>
<p>入门代码：</p>
<pre><code class="lang-java">package com.zzy.innerclass;

public class InnerClass01 &#123;//外部其他类
    public static void main(String[] args) &#123;

    &#125;
&#125;

class Outer&#123;//外部类
    private int n1 = 100;
    public void m1()&#123;
        System.out.println(&quot;m1()&quot;);
    &#125;

    public Outer(int n1) &#123;
        this.n1 = n1;
    &#125;

    &#123;
        System.out.println(&quot;Outer的代码块哦&quot;);
    &#125;

    class Inner&#123;
        //内部类
    &#125;
&#125;
</code></pre>
<h2 id="局部内部类的使用"><a href="#局部内部类的使用" class="headerlink" title="局部内部类的使用"></a>局部内部类的使用</h2><p>局部内部类是定义在外部类的局部位置，比如方法中，并且有类名</p>
<ol>
<li>可以直接访问外部类的所有成员，包含私有的</li>
<li>不能添加访问修饰符，因为它的地位就是一个局部变量。局部变量是不能使用修饰符的。但是可以使用final修饰，因为局部变量也可以使用final</li>
<li>作用域：仅仅在定义它的方法或者代码块中</li>
<li>局部访问类—访问外部类的成员—可以==直接访问==</li>
<li>外部类—访问—局部内部类成员   访问方式：创建对象，再访问</li>
<li>外部其他类—不能访问—局部内部类（因为局部内部类也是一个局部变量）</li>
<li>如果外部类和局部内部类的成员重名，默认遵守就近原则，如果想访问外部类的成员，可以使用（外部类名.this.成员）去访问</li>
</ol>
<p>记住：</p>
<ul>
<li>局部内部类定义在方法中/代码块</li>
<li>作用域在方法体或者代码块中</li>
<li>本质仍然是一个类</li>
</ul>
<pre><code class="lang-java">package com.zzy.innerclass;
/*
演示局部内部类
 */
public class LocalInnerClass &#123;
    public static void main(String[] args) &#123;
        Outer02 outer02 = new Outer02();
        outer02.m1();
        System.out.println(&quot;outer02 hashcode = &quot; + outer02);
    &#125;
&#125;

class Outer02&#123;
    private int n1 = 100;
    private void m2()&#123;
        System.out.println(&quot;m2()&quot;);
    &#125;
    public void m1()&#123;//方法
        //局部内部类是定义在外部类的局部位置，通常在方法
        class Inner02&#123;
            //局部内部类
            //可以直接访问外部内的所有成员，包含私有的
            //局部内部类的作用域在定义的方法或者代码块里面
            private int n1 = 800;
            public void f1()&#123;
                System.out.println(&quot;n1 = &quot; + n1 + &quot; n1 = &quot; + Outer02.this.n1);
                System.out.println(&quot;Outer02.this hashcode = &quot; + Outer02.this);
                m2();
            &#125;
        &#125;

        //外部类在方法中，可以创建Inner02对象的实例，然后调用方法
        Inner02 inner02 = new Inner02();
        inner02.f1();

    &#125;
&#125;
</code></pre>
<h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><p>（1）本质是类 （2）内部类 （3）该类没有名字（其实是类名加$） (4)同时还是一个对象</p>
<p>匿名内部类是定义在外部类的局部位置，比如方法中，并且没有类名</p>
<pre><code class="lang-java">package com.zzy.innerclass;

/**
 * 演示匿名内部类的使用
 */
public class AnonymousInnerClass &#123;
    public static void main(String[] args) &#123;
        Outer04 outer04 = new Outer04();
        outer04.method();
    &#125;
&#125;

class Outer04&#123;//外部类
    private int n1 = 10;

    public void method()&#123;
        //基于接口的匿名内部类
        //这个基于接口的类我只使用一次就不用了,则在其他外部类去写这个类有点浪费
        //可以使用匿名内部类来简化开发
        //编译类型？ IA
        //运行类型：是系统自动分配的，但是可以用类.getclass()进行查看
        //jdk底层在创建匿名内部类的时候，立马就创建了Outer$1的实例，并且把地址返回给接收new对象的对象
        //匿名内部类只能使用一次，注意区别实例和匿明内部类的区别
        IA tiger = new  IA()&#123;
            @Override
            public void cry()&#123;
                System.out.println(&quot;老虎叫唤...&quot;);
            &#125;
        &#125;;
        System.out.println(&quot;tiger的运行类型：&quot; + tiger.getClass());
        tiger.cry();

        //基于类的匿名内部类
        Father baba = new Father(&quot;baba&quot;)&#123;
            @Override
            public void test() &#123;
                System.out.println(&quot;匿名内部类重写了test方法&quot;);
            &#125;
        &#125;;
        System.out.println(&quot;baba的运行类型&quot; + baba.getClass());
        baba.test();
    &#125;
&#125;

interface IA&#123;//接口
    public abstract void cry();

&#125;

class Father&#123;
    public Father(String name)&#123;//构造器

    &#125;

    public void test()&#123;//方法
        System.out.println(&quot;父类的test方法&quot;);
    &#125;
&#125;
</code></pre>
<h2 id="匿名内部类的使用细节"><a href="#匿名内部类的使用细节" class="headerlink" title="匿名内部类的使用细节"></a>匿名内部类的使用细节</h2><ol>
<li>匿名内部类的语法比较奇特，它既是一个类的定义，同时本身也是一个对象，从语法上，它既有定义类的特征，也有创建对象的特征</li>
<li>可以直接访问外部类的所有成员，包含私有的</li>
<li>不能添加访问修饰符，因为它的地位就是一个局部变量</li>
<li>作用域：仅仅定义在它的方法或者代码块中</li>
<li>匿名内部类—访问—&gt;外部类成员【直接访问】</li>
<li>外部其他类—不能访问—&gt;匿名内部类【因为匿名内部类地位是一个局部变量】</li>
<li>如果外部类和匿名内部类的成员重名时，匿名内部类访问的话，遵循就近一致原则，如果想访问外部类的成员，可以使用（外部类名.this.成员）去访问</li>
</ol>
<pre><code class="lang-java">package com.zzy.innerclass;

public class AnonymousInnerClassDetails &#123;
    public static void main(String[] args) &#123;
        Outer05 outer05 = new Outer05();
        outer05.f1();
    &#125;
&#125;

class Outer05&#123;
    private int n1 = 99;
    public void f1()&#123;
        //创建一个基于类的匿名内部类
        Person person = new Person()&#123;//编译类型Person,运行类型是匿名对象
            @Override
            public void hi()&#123;
                System.out.println(&quot;匿名内部类重写了 hi方法&quot;);
            &#125;
        &#125;;
        person.hi();

        new Person()&#123;//编译类型Person,运行类型是匿名对象
            @Override
            public void hi()&#123;
                System.out.println(&quot;匿名内部类重写了 hi方法&quot;);
            &#125;

            @Override
            public void ok(String name) &#123;
                super.ok(name);
            &#125;
        &#125;.ok(&quot;小周&quot;);
    &#125;
&#125;
class Person&#123;
    public void hi()&#123;
        System.out.println(&quot;Person hi()&quot;);
    &#125;

    public void ok(String name)&#123;
        System.out.println(&quot;name = &quot; + name);
    &#125;

&#125;
</code></pre>
<h2 id="匿名内部类的最佳实践"><a href="#匿名内部类的最佳实践" class="headerlink" title="匿名内部类的最佳实践"></a>匿名内部类的最佳实践</h2><p>当做实参直接传递，简洁高效</p>
<pre><code class="lang-java">package com.zzy.innerclass;

public class InnerClassExercise01 &#123;
    public static void main(String[] args) &#123;
        f1(new AA() &#123;//当做实参直接传递，简洁高效
            @Override
            public void show() &#123;
                System.out.println(&quot;匿名内部类&quot;);
            &#125;
        &#125;);
    &#125;

    //静态方法,形参是接口类型
    public static void f1(AA aa)&#123;
        aa.show();
    &#125;
&#125;

interface AA&#123;
    public abstract void show();
&#125;
</code></pre>
<pre><code class="lang-java">package com.zzy.innerclass;

public class InnerClassExercise02 &#123;
    public static void main(String[] args) &#123;
        alarmclock(new Bell() &#123;//匿名内部类作为实参
            @Override
            public void ring() &#123;
                System.out.println(&quot;懒猪起床了&quot;);
            &#125;
        &#125;);

        alarmclock(new Bell() &#123;
            @Override
            public void ring() &#123;
                System.out.println(&quot;小伙伴上课了&quot;);
            &#125;
        &#125;);
    &#125;

    public static void alarmclock(Bell bell)&#123;
        bell.ring();
    &#125;
&#125;

interface Bell&#123;
    public abstract void ring();
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title>C++知识点</title>
    <url>/2021/05/31/C++/C++%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<h1 id="1-cin-clear"><a href="#1-cin-clear" class="headerlink" title="1. cin.clear()"></a>1. cin.clear()</h1><p>是用来更改cin的状态标示符的。</p>
<p>cin.sync（）是用来清除缓存区的数据流的。<br>如果标示符没有改变那么即使清除了数据流也无法输入。所以两个要联合起来使用。</p>
<p>我们定义要输入到的变量是整型,但如果我们输入了英文字母或者汉字,那就会发生错误,cin里有个方法能检测这个错误,就是cin.rdstate(); 当cin.rdstate()返回0(即ios::goodbit)时表示无错误,可以继续输入或者操作,若返回4则发生非致命错误即ios::failbit,则不能继续输入或操作.而cin.clear则可以控制我们此时cin里对这个问题的一个标识.语发如下: cin.clear(标识符); 标识符号为:</p>
<p>goodbit 无错误<br>Eofbit 已到达文件尾<br>failbit 非致命的输入/输出错误，可挽回<br>badbit　致命的输入/输出错误,无法挽回 若在输入输出类里.需要加ios::标识符号<br>通过cin.clear,我们能确认它的内部标识符,如果输入错误则能重新输入.结合真正的清空数据流方法cin.sync(),请看下例:</p>
<pre><code class="lang-c++">include &lt;iostream&gt;
using namespace std; 
int main()  
&#123;         
    int a;         
    while(1)         
    &#123;                 
        cin&gt;&gt;a;                 
        if(!cin)            //条件可改写为cin.fail()                 
        &#123;                         
            cout&lt;&lt;&quot;输入有错!请重新输入&quot;&lt;&lt;endl;                         
            cin.clear();                          
            cin.sync();   //清空流                 
        &#125;                 
        else                 
        &#123;                         
            cout&lt;&lt;a;                         
            break;                 
        &#125;         
    &#125;         
    system(&quot;pause&quot;); 
&#125;
</code></pre>
<p>上面的cin.clear()默认参数为0,即无错误,正常操作.当我们输入英文字母’k’时,它的状态标识改为fail,即错误,用cout对用户输出信息,再用cin.clear让错误标识改回为0,让我们可以继续输入,再清空流数据继续输入.如果我们没有了cin.clear,则会进入死循环,其过程为我们输入了英文字母,它的状态标识便为fail,当运行到条件判断时,便总是回到错误的条件表示里,并且我们再也没办法输入,因为错误的表示关闭了cin,所以会进入死循环.</p>
<h1 id="2-常量指针和指针常量"><a href="#2-常量指针和指针常量" class="headerlink" title="2. 常量指针和指针常量"></a>2. 常量指针和指针常量</h1><p>在第一次听黑马C++的时候，是按老师的说法自己记忆的，而在回顾C++ primer plus时，对这个的理解才更加深刻，先看两者的声明。</p>
<pre><code class="lang-c++">int sloth =3;
const int* ps = &amp;sloth;        // a pointer to const int
int* const finger = &amp;sloth;    // a const pointer to int
</code></pre>
<p>根据英文的理解比中文好的多， a pointer to const int 代表这个指针指向的常量是不可以改变的，但是这个指针是指向却是可以改变的。</p>
<p>第二个表明这个指针它是一个常量，它是没法改变的，但是他指向的值却是可以改变的，记住这个英文的注解就可以了。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>JavaScript基础</title>
    <url>/2021/06/10/Cesium/Cesiun%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="1-Cesium下载及安装"><a href="#1-Cesium下载及安装" class="headerlink" title="1. Cesium下载及安装"></a>1. Cesium下载及安装</h1><p>先会用到node和git两个软件.</p>
<p>在运行以下代码之前，先安装gulp.</p>
<p><a href="https://www.gulpjs.com.cn/">gulp</a></p>
<pre><code class="lang-bash">git clone https://github.com/CesiumGS/cesium.git    //源码下载
npm install    //安装cesium所需的一些依赖
npm run release    //会把所有的东西封装成一个文件
</code></pre>
<h1 id="2-cesiumWidget"><a href="#2-cesiumWidget" class="headerlink" title="2. cesiumWidget"></a>2. cesiumWidget</h1><p>CesiumWidget内部创建的对象主要有以下几个部分：</p>
<pre><code class="lang-mermaid">graph LR
A[Cesium]--&gt;B[cesiumWidget]
B--&gt;C[clock]
B--&gt;D[container]
B--&gt;E[canvas]
B--&gt;F[screenSpaceEvenHandler]
B--&gt;G[scene]
G--&gt;H[global]--&gt;I[_surface]
G--&gt;J[primitives]
G--&gt;K[groundPrimitives]
G--&gt;Y[环境对象]
Y--&gt;a[skyBox]
Y--&gt;b[skyAtmosphere]
Y--&gt;c[sun]
Y--&gt;d[sunBloom]
Y--&gt;e[moon]
Y--&gt;f[background]
</code></pre>
<p>clock用来记录时间，毕竟三维场景需要进行动态展示，需要通过时间来确定某一帧的绘制内容。container则是构造函数的参数，也就是传入的div。canvas则是在container上构建的Canvas的对象，可以据此获取WebGL绘制的比划。screenSpaceEventHandler则是对Canvas对象上各种鼠标的交互时间的封装，方便传递给三维场景。三维场景干之后可以据此改变相机姿态等。scene最重要，它承载着整个三维场景中的对象。</p>
<p>Scene中装载了所有的三维对象</p>
<p>Scene中有一些==内置==的图元对象：地球（Global）、skyBox（天空盒）、sun、moon等，另外还有两个用来由用户自行控制存放对象的数组：primitives和groundPrimitives, ==scene里本身是没有时间的概念的==</p>
<h1 id="3-cesium搭建发布环境"><a href="#3-cesium搭建发布环境" class="headerlink" title="3. cesium搭建发布环境"></a>3. cesium搭建发布环境</h1><p>先安装express</p>
<pre><code class="lang-bash">npm install express
</code></pre>
<p>创建server.js文件</p>
<pre><code class="lang-javascript">var http = require(&quot;http&quot;);
var express = require(&quot;express&quot;);
const path = require(&#39;path&#39;);

var app = express();
app.use(express.static(path.join(__dirname, &#39;&#39;)));

app.listen(4111, () =&gt; &#123;
  console.log(`http://localhost:4111`)
&#125;)
</code></pre>
]]></content>
      <categories>
        <category>Cesiun</category>
      </categories>
  </entry>
  <entry>
    <title>JavaScript基础</title>
    <url>/2021/06/10/%E5%89%8D%E7%AB%AF3%E5%A4%A7%E4%BB%B6/HTML%E5%92%8CCSS/</url>
    <content><![CDATA[<h1 id="网页"><a href="#网页" class="headerlink" title="网页"></a>网页</h1><p>网站是指因特网上根据一定的规则，使用html等制作的用于展示特定内容相关的网页集合。</p>
<p>网页是网站中的一页，通常是HTML格式的文件，它要通过浏览器来阅读。</p>
<p>网页是构成网站的基本元素，它通常由图片、链接、文字、声音、视频等元素组成。</p>
<p>什么是HTML：HTML指的是超文本标记语言，它是用来描述网页的一种语言。</p>
<p>标记语言是一套标记标签（markup tag）</p>
<p>所谓超文本，有两层含义：</p>
<ol>
<li><p>它可以加入图片、声音、动画、多媒体等内容（超越了文本限制）。</p>
</li>
<li><p>它还可以从一个文件跳转到另一个文件，与世界各地主机链接。</p>
</li>
</ol>
<p>前端==》浏览器渲染==》web端展示</p>
<p>Web标准是由W3C组织和其他标准化制定的一系列标准的集合。</p>
<p>Web标准的构成：</p>
<p>主要包括结构(Structure)、表现(Presentation)、行为(Behavior)三个方面</p>
<p>结构：结构用于对网页元素进行整理和分类，现阶段主要学的是HTML。</p>
<p>表现：表现用于设置网页元素的版式、颜色、大小等外观样式，主要是指CSS</p>
<p>行为：行为是指网页模型的定义及交互的编写，现阶段主要学的是JavaScript</p>
<p>Web标准提出的最佳体验方案：结构、样式、行为相分离。</p>
<p>也就是：结构写到HTML文件中，表现写到CSS文件中，行为写到JavaScript文件中。</p>
<p>相比较而言，三者中结构最重要。</p>
<h1 id="HTML语法"><a href="#HTML语法" class="headerlink" title="HTML语法"></a>HTML语法</h1><p>所有的标签都包含在&lt;&gt;里，而且大部分情况下都是成对出现的</p>
<pre><code class="lang-html">&lt;html&gt;&lt;/html&gt;  //双标签

&lt;br /&gt;      //单标签
</code></pre>
<p>包含关系：可以简单理解为父子关系</p>
<pre><code class="lang-html">&lt;head&gt;
   &lt;title&gt;&lt;/title&gt;
&lt;/head&gt;
</code></pre>
<p>并列关系：理解为兄弟关系</p>
<pre><code class="lang-html">&lt;head&gt;&lt;/head&gt;

&lt;body&gt;&lt;/body&gt;
</code></pre>
<h1 id="HTML基本结构标签"><a href="#HTML基本结构标签" class="headerlink" title="HTML基本结构标签"></a>HTML基本结构标签</h1><p>每个网页都会有一个基本的结构标签（也称为骨架标签），页面内容也是在这些基本标签上书写。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>html</th>
<th>HTML标签</th>
<th>HTML标签</th>
</tr>
</thead>
<tbody>
<tr>
<td>head</td>
<td>文档的头部</td>
<td>注意在head标签中我们必须设置的标签是title</td>
</tr>
<tr>
<td>title</td>
<td>文档的标题</td>
<td>让页面拥有一个属于自己的网页标题</td>
</tr>
<tr>
<td>body</td>
<td>文档的主体</td>
<td>元素包含文档的所有内容，页面内容基本都是放到body里面的</td>
</tr>
</tbody>
</table>
</div>
<h2 id="标题标签"><a href="#标题标签" class="headerlink" title="标题标签"></a>标题标签</h2><pre><code>&lt;h1&gt; - &lt;h6&gt;    //标题标签
&lt;p&gt;    //段落标签
&lt;br /&gt;    //换行标签,它是一个单标签
</code></pre><h2 id="文本格式化标签"><a href="#文本格式化标签" class="headerlink" title="文本格式化标签"></a>文本格式化标签</h2><pre><code>&lt;strong&gt;或者&lt;b&gt;    //加粗文字
&lt;em&gt;或者&lt;i&gt;    //文字倾斜
&lt;del&gt;或者&lt;s&gt;    //删除线
&lt;ins&gt;或者&lt;u&gt;    //下划线
</code></pre><h2 id="盒子标签"><a href="#盒子标签" class="headerlink" title="盒子标签"></a>盒子标签</h2><pre><code>&lt;div&gt;    //division的缩写，表示分割
&lt;span&gt;    //跨度、跨距
</code></pre><p>特点：</p>
<p>1.div标签用来布局，==但是一行只能放一个div==,大盒子</p>
<p>2.span标签用来布局，一行上可以写多个span。小盒子</p>
<h2 id="图像标签"><a href="#图像标签" class="headerlink" title="图像标签"></a>图像标签</h2><pre><code>&lt;img src=&quot;图像URL&quot; /&gt;    //这是一个单标签
</code></pre><p>src是img标签的必须属性，它用于指定图像文件的路径和文件名</p>
<p>还有一些其他的属性值：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>alt</th>
<th>文本</th>
<th>替换文本。图像不能显示的文字</th>
</tr>
</thead>
<tbody>
<tr>
<td>title</td>
<td>文本</td>
<td>提示文本。鼠标放到图像上，显示的文字</td>
</tr>
<tr>
<td>width</td>
<td>像素</td>
<td>设置图像的宽度</td>
</tr>
<tr>
<td>height</td>
<td>像素</td>
<td>设置图像的高度</td>
</tr>
<tr>
<td>border</td>
<td>像素</td>
<td>设置图像的边框粗细</td>
</tr>
</tbody>
</table>
</div>
<p>细节：</p>
<ol>
<li>图像标签可以拥有多个属性这，必须卸载标签名的后面。</li>
<li>属性之间部分先后顺序，标签名和属性、属性和属性之间均以空格分开。</li>
<li>属性采取键值对的格式。</li>
</ol>
<h2 id="超链接标签"><a href="#超链接标签" class="headerlink" title="超链接标签"></a>超链接标签</h2><pre><code>//在HTML中，a标签用于定义超链接，作用是从一个页面链接到另一个页面
&lt;a href=&quot;跳转目标&quot; target=&quot;目标窗口的弹出方法&quot;&gt; 文本或图像&lt;/a&gt;
</code></pre><pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h4&gt;1.外部链接&lt;/h4&gt;
    target 打开窗口的方式 默认的值是_self 当前窗口打开页面 _blank 新窗口打开页面
    &lt;a href=&quot;http://qq.com&quot; target=&quot;_blank&quot;&gt;腾讯&lt;/a&gt;

    &lt;h4&gt;2.空链接&lt;/h4&gt;
    &lt;a href=&quot;#&quot;&gt;公司地址&lt;/a&gt;

    &lt;h4&gt;3.下载链接&lt;/h4&gt;
    如果href里面地址是一个文件或者压缩包，会下载这个文件
    &lt;a href=&quot;filename.zip&quot;&gt;&lt;/a&gt;

    &lt;h4&gt;4.网页元素链接&lt;/h4&gt;
    &lt;a href=&quot;http://baidu.com&quot;&gt;&lt;img src=&quot;img.jpg&quot;/&gt;&lt;/a&gt;

    &lt;h4&gt;5.锚点链接&lt;/h4&gt;
    实现跳转的效果,先设置id,然后通过#号进行链接
    &lt;a href=&quot;#two&quot;&gt;个人生活&lt;/a&gt;
    &lt;h4 id=&quot;two&quot;&gt;&lt;/h4&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h2 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h2><p>代码后的;打了显示不出来，下面的代码都需要加;</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>特殊字符</th>
<th>描述</th>
<th>代码</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>空格符</td>
<td>&amp;nbsp</td>
</tr>
<tr>
<td>&lt;</td>
<td>小于号</td>
<td>&amp;lt</td>
</tr>
<tr>
<td>&gt;</td>
<td>大于号</td>
<td>&amp;gt</td>
</tr>
<tr>
<td>&amp;</td>
<td>和号</td>
<td>&amp;amp</td>
</tr>
<tr>
<td>￥</td>
<td>人民币</td>
<td>&amp;yen</td>
</tr>
<tr>
<td>©</td>
<td>版权</td>
<td>&amp;copy</td>
</tr>
<tr>
<td>®</td>
<td>注册商标</td>
<td>&amp;reg</td>
</tr>
<tr>
<td>℃</td>
<td>摄氏度</td>
<td>&amp;deg</td>
</tr>
<tr>
<td>±</td>
<td>正负号</td>
<td>&amp;plusm</td>
</tr>
<tr>
<td>x</td>
<td>乘号</td>
<td>&amp;times</td>
</tr>
<tr>
<td>+</td>
<td>除号</td>
<td>&amp;divide</td>
</tr>
<tr>
<td>²</td>
<td>平方</td>
<td>&amp;sup2</td>
</tr>
<tr>
<td>³</td>
<td>立方</td>
<td>&amp;sup3</td>
</tr>
</tbody>
</table>
</div>
<h2 id="表格标签"><a href="#表格标签" class="headerlink" title="表格标签"></a>表格标签</h2><p>表格是用来布局页面的，而不是来展示数据的。</p>
<pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;table&gt;
        &lt;tr&gt;&lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt;&lt;/tr&gt;
        &lt;tr&gt;&lt;td&gt;刘德华&lt;/td&gt; &lt;td&gt;男&lt;/td&gt; &lt;td&gt;23&lt;/td&gt;&lt;/tr&gt;
        &lt;tr&gt;&lt;td&gt;张学友&lt;/td&gt; &lt;td&gt;男&lt;/td&gt; &lt;td&gt;22&lt;/td&gt;&lt;/tr&gt;
    &lt;/table&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>1.table是用于定义表格的标签。</p>
<p>2.tr标签用于定义表格中的行，必须嵌套在table标签中</p>
<p>3.th标签表示HTML表格的表头部分</p>
<p>4.td用于定义表格中的单元格，必须嵌套在tr</p>
<h2 id="表格属性"><a href="#表格属性" class="headerlink" title="表格属性"></a>表格属性</h2><div class="table-container">
<table>
<thead>
<tr>
<th>属性名</th>
<th>属性值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>align</td>
<td>left、center、right</td>
<td>规定表格相对周围元素的对齐</td>
</tr>
<tr>
<td>border</td>
<td>1或者””</td>
<td>规定表格单元是否拥有边框，默认为””，表示没有边款</td>
</tr>
<tr>
<td>cellpadding</td>
<td>像素值</td>
<td>规定单元边沿与其内容之间的空白，默认1像素</td>
</tr>
<tr>
<td>cellspacing</td>
<td>像素值</td>
<td>规定单元格之间的空白，默认2像素</td>
</tr>
<tr>
<td>width</td>
<td>像素值或百分比</td>
<td>规定表格的宽度</td>
</tr>
</tbody>
</table>
</div>
<pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;!-- 属性要写到表格标签table里面去--&gt;
    &lt;table align=&quot;center&quot; border=&quot;1&quot; cellspacing = 0 width =&quot;500&quot; height=&quot;300&quot;&gt;
        &lt;tr&gt;&lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt;&lt;/tr&gt;
        &lt;tr&gt;&lt;td&gt;刘德华&lt;/td&gt; &lt;td&gt;男&lt;/td&gt; &lt;td&gt;23&lt;/td&gt;&lt;/tr&gt;
        &lt;tr&gt;&lt;td&gt;张学友&lt;/td&gt; &lt;td&gt;男&lt;/td&gt; &lt;td&gt;22&lt;/td&gt;&lt;/tr&gt;
        &lt;tr&gt;&lt;td&gt;郭富城&lt;/td&gt; &lt;td&gt;男&lt;/td&gt; &lt;td&gt;&lt;a href=&quot;http://baidu.com&quot;&gt;百度&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;
    &lt;/table&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h2 id="表格结构标签"><a href="#表格结构标签" class="headerlink" title="表格结构标签"></a>表格结构标签</h2><p>thead：用于定义表格的头部。thead内部必须拥有tr标签。一般是位于第一行</p>
<p>tbody：用于定义表格的主体，主要用于放数据本体。</p>
<p>以上标签都是放在table标签中的</p>
<pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;!-- 属性要写到表格标签table里面去--&gt;
    &lt;table align=&quot;center&quot; border=&quot;1&quot; cellspacing = 0 width =&quot;500&quot; height=&quot;300&quot;&gt;
    &lt;thead&gt;
        &lt;tr&gt;
            &lt;th&gt;姓名&lt;/th&gt;
            &lt;th&gt;性别&lt;/th&gt;
            &lt;th&gt;年龄&lt;/th&gt;
        &lt;/tr&gt;
    &lt;/thead&gt;
    &lt;tbody&gt;
        &lt;tr&gt;
            &lt;th&gt;姓名&lt;/th&gt;
            &lt;th&gt;性别&lt;/th&gt;
            &lt;th&gt;年龄&lt;/th&gt;
        &lt;/tr&gt;

        &lt;tr&gt;
            &lt;th&gt;姓名&lt;/th&gt;
            &lt;th&gt;性别&lt;/th&gt;
            &lt;th&gt;年龄&lt;/th&gt;
        &lt;/tr&gt;

        &lt;tr&gt;
            &lt;th&gt;姓名&lt;/th&gt;
            &lt;th&gt;性别&lt;/th&gt;
            &lt;th&gt;年龄&lt;/th&gt;
        &lt;/tr&gt;
    &lt;/tbody&gt; 
    &lt;/table&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h2 id="合并单元格"><a href="#合并单元格" class="headerlink" title="合并单元格"></a>合并单元格</h2><p>合并单元格方式：</p>
<p>跨行合并：rowspan = “合并单元格的个数”</p>
<p>跨列合并：colspan= “合并单元格的个数”</p>
<p>目标单元格：</p>
<p>跨行：最上侧单元格为目标单元格，写合并代码</p>
<p>跨列：最左侧单元格为目标单元格，写合并代码</p>
<p>合并单元格三部曲：</p>
<p>1.先确定时跨行还是跨列合并</p>
<p>2.找到目标单元格，写上合并方式</p>
<p>3.删除多余的单元格</p>
<pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;!-- 属性要写到表格标签table里面去--&gt;
    &lt;table align=&quot;center&quot; border=&quot;1&quot; cellspacing = 0 width =&quot;500&quot; height=&quot;250&quot;&gt;
        &lt;tr&gt;
            &lt;th&gt;&lt;/th&gt;
            &lt;th colspan=&quot;2&quot;&gt;&lt;/th&gt;
        &lt;/tr&gt;

        &lt;tr&gt;
            &lt;th rowspan=&quot;2&quot;&gt;&lt;/th&gt;
            &lt;th&gt;&lt;/th&gt;
            &lt;th&gt;&lt;/th&gt;
        &lt;/tr&gt;

        &lt;tr&gt;
            &lt;th&gt;&lt;/th&gt;
            &lt;th&gt;&lt;/th&gt;
        &lt;/tr&gt;
    &lt;/table&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h2 id="列表标签"><a href="#列表标签" class="headerlink" title="列表标签"></a>列表标签</h2><p>表格是用来显示数据的，那么列表就是用来布局的</p>
<p>列表最大的特点就是整齐、整洁、有序，它作为布局会更加自由和方便</p>
<p>根据使用的场景，列表可以分为三大类：无序列表、有序列表和自定义列表</p>
<p>==无序列表：==</p>
<p>ur标签表示HTML页面中项目的无序列表，一般会以项目符号呈现列表项，而列表项使用li标签定义</p>
<pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h4&gt;您喜欢的食物？&lt;/h4&gt;
    &lt;ur&gt;
        &lt;li&gt;菠萝&lt;/li&gt;
        &lt;li&gt;西瓜&lt;/li&gt;
        &lt;li&gt;荔枝&lt;/li&gt;
    &lt;/ur&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>细节：ur里只能放li标签，li相当于一个容器，可以容纳所有元素，无序列表会带有自己的样式属性，但在实际使用时，我们会使用css来设置。</p>
<p>==有序列表：==</p>
<p>ol标签用于定义有序列表，列表排序以数字来显示，li用来定义列表项</p>
<pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h4&gt;您喜欢的食物？&lt;/h4&gt;
    &lt;ol&gt;
        &lt;li&gt;菠萝&lt;/li&gt;
        &lt;li&gt;西瓜&lt;/li&gt;
        &lt;li&gt;荔枝&lt;/li&gt;
    &lt;/ol&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>==定义列表：==</p>
<p>自定义列表的使用场景：</p>
<p>自定义列表常用于对术语或名词进行解释和描述，定义列表的列表项前没有任何项目符号。</p>
<p>在HTML中，dl标签用于定义描述列表，该标签与dt和dd一起使用</p>
<pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;dl&gt;
        &lt;dt&gt;关注我们&lt;/dt&gt;
        &lt;dd&gt;新浪微博&lt;/dd&gt;
        &lt;dd&gt;官方微信&lt;/dd&gt;
        &lt;dd&gt;联系我们&lt;/dd&gt;
    &lt;/dl&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>细节：</p>
<p>1.dl里面只能放dt和dd</p>
<p>2.dt和dd个数没有限制，经常是一个dt对应多个dd</p>
<h2 id="表单标签"><a href="#表单标签" class="headerlink" title="表单标签"></a>表单标签</h2><p>为什么需要表单：</p>
<p>使用表单目的是为了收集用户信息。</p>
<p>表单的组成：</p>
<p>在HTML中，一个完整的表单通常由表单域、表单控件和提示信息三个部分组成</p>
<p>表单域：</p>
<p>表单域是一个包含表单元素的区域。</p>
<p>在HTML标签中，form标签用于定义表单域，以实现用户信息的收集和传递。</p>
<p>form会把它范围内的表单元素信息提交给服务器</p>
<pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;form action=&quot;demo.php&quot; method=&quot;POST&quot; name=&quot;name1&quot;&gt;

    &lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="input"><a href="#input" class="headerlink" title="input"></a>input</h3><p>input标签中，包含一个type属性，根据不同的type属性，输入字段拥有很多种形式。它是一个==单标签==。</p>
<p>type属性值：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>属性值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>button</td>
<td>定义可点击按钮</td>
</tr>
<tr>
<td>checkbox</td>
<td>定义复选框</td>
</tr>
<tr>
<td>file</td>
<td>定义输入字段和“浏览”按钮，供文件上传</td>
</tr>
<tr>
<td>hidden</td>
<td>定义隐藏的输入字段</td>
</tr>
<tr>
<td>image</td>
<td>定义图像形式的提交按钮</td>
</tr>
<tr>
<td>password</td>
<td>定义密码字段。该字段中的字符被掩码</td>
</tr>
<tr>
<td>radio</td>
<td>定义单选按钮</td>
</tr>
<tr>
<td>reset</td>
<td>定义重置按钮。重置按钮会清楚表单中的所有数据</td>
</tr>
<tr>
<td>submit</td>
<td>定义提交按钮。提交按钮会把表单数据发送到服务器</td>
</tr>
<tr>
<td>text</td>
<td>定义单行的输入字段，用户可在其中输入文本。默认宽度为20个字符</td>
</tr>
</tbody>
</table>
</div>
<pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;form&gt;
        用户名：&lt;input type=&quot;text&quot;&gt; &lt;br&gt;
        密码：&lt;input type=&quot;password&quot;&gt;
    &lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;form&gt;
        用户名：&lt;input type=&quot;text&quot;&gt; &lt;br&gt;
        密码：&lt;input type=&quot;password&quot;&gt; &lt;br&gt;
        &lt;!-- radio 单选按钮 可以实现多选1 --&gt;
        性别：男 &lt;input type=&quot;radio&quot;&gt; 女 &lt;input type=&quot;radio&quot;&gt; &lt;br&gt;
        &lt;!-- checkbox 多选按钮 --&gt;
        性别：男 &lt;input type=&quot;checkbox&quot;&gt; 女 &lt;input type=&quot;checkbox&quot;&gt; &lt;br&gt;

    &lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>除type属性外，input标签还有很多其他的属性</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>属性</th>
<th>属性值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>name</td>
<td>由用户自定义</td>
<td>定义input元素的名称</td>
</tr>
<tr>
<td>value</td>
<td>由用户自定义</td>
<td>规定input元素的值</td>
</tr>
<tr>
<td>checked</td>
<td>checked</td>
<td>规定此input元素首次加载时应当被选中</td>
</tr>
<tr>
<td>maxlength</td>
<td>正整数</td>
<td>规定输入字段中的字符的最大长度</td>
</tr>
</tbody>
</table>
</div>
<pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;form&gt;
        用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;请输入您的姓名&quot;&gt; &lt;br&gt;
        密码：&lt;input type=&quot;password&quot; name=&quot;pwd&quot;&gt; &lt;br&gt;
        &lt;!-- radio 单选按钮 可以实现多选1 --&gt;
        &lt;!-- name 是表单元素名字，这里性别单选按钮必须有相同的名字name,才能实现多选1 --&gt;
        性别：男 &lt;input type=&quot;radio&quot; name=&quot;username&quot; value=&quot;男&quot;&gt; 女 &lt;input type=&quot;radio&quot; name=&quot;username&quot; value=&quot;女&quot;&gt; &lt;br&gt;
        &lt;!-- checkbox 多选按钮 --&gt;
        爱好：吃饭 &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; checked=&quot;checked&quot;&gt; 睡觉 &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot;&gt; &lt;br&gt;
        &lt;!-- 点击了提交按钮，可以把 表单域form里面的表单元素里面的值提交给后台服务器 --&gt;
        &lt;input type=&quot;submit&quot; value=&quot;免费注册&quot;&gt;
         &lt;br&gt;
        &lt;!-- 重置按钮可以还原表单元素初始的默认状态 --&gt;
        &lt;input type=&quot;reset&quot; value=&quot;重新编写&quot;&gt;
        &lt;br&gt;
        &lt;!-- 普通按钮 botton 后期结合js 搭配使用 --&gt;
        &lt;input type=&quot;button&quot; value=&quot;获取短信验证码&quot;&gt;
        &lt;br&gt;
        &lt;!-- 文件域 使用场景 上传文件使用的 --&gt;
        上传头像： &lt;input type=&quot;file&quot;&gt;
    &lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<ol>
<li>单选和复选按钮必须名字相同</li>
<li>name和value是每个表单元素都有的属性值，主要给后台人员使用</li>
</ol>
<h3 id="label"><a href="#label" class="headerlink" title="label"></a>label</h3><p>label标签用于绑定一个表单元素，当点击label标签内的文本时，浏览器就会自动将焦点（光标）转到或者选择对应的表单元素上，用来增加用户体验。</p>
<pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;label for=&quot;name&quot;&gt; 用户名：&lt;/label&gt; &lt;input type=&quot;text&quot; id = &quot;name&quot; &gt;
    &lt;br&gt;
    性别：&lt;label for=&quot;male&quot;&gt;男&lt;/label&gt; &lt;input type=&quot;radio&quot; name=&quot;sex&quot; id=&quot;male&quot;&gt; 
        &lt;label for=&quot;female&quot;&gt;女&lt;/label&gt; &lt;input type=&quot;radio&quot; name=&quot;sex&quot; id=&quot;female&quot;&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p>使用场景：在页面中，如果有多个选项让用户选择，并且想要节约页面空间时，可以使用select标签控件定义下拉列表。</p>
<pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;form&gt;
   籍贯：
   &lt;select &gt;
       &lt;option&gt;山东&lt;/option&gt;
       &lt;option&gt;北京&lt;/option&gt;
       &lt;option&gt;天津&lt;/option&gt;
       &lt;option selected=&quot;selected&quot;&gt;广东&lt;/option&gt;
   &lt;/select&gt;
    &lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>细节：</p>
<p>select中至少包含一对option</p>
<p>在option中定义selected = “selected”时，当前项即为默认选择项</p>
<h3 id="textarea"><a href="#textarea" class="headerlink" title="textarea"></a>textarea</h3><p>使用场景：当用户输入内容较多时，我们就不能使用文本框表单了，此时我们可以使用textarea标签。</p>
<p>使用多行文本输入控件，可以输入更多的文字，该控件常用于留言板、评论。</p>
<pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;form&gt;
        今日反馈：
        &lt;textarea cols=&quot;50&quot; rows=&quot;5&quot;&gt;&lt;/textarea&gt;
    &lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>细节：</p>
<p>通过textarea标签可以轻松地创建多行文本输入框</p>
<p>cols=”每行中的字符数”, rows=”显示的行数”, 我们在实际开发中不会使用，都是用CSS来改变大小。</p>
<h2 id="综合练习"><a href="#综合练习" class="headerlink" title="综合练习"></a>综合练习</h2><pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;form&gt;
        &lt;h4&gt;青春不常在，抓紧谈恋爱&lt;/h4&gt;
        &lt;table width=&quot;500&quot; border=&quot;1&quot; cellspacing=&quot;0&quot;&gt;
            &lt;tr&gt;
                &lt;td&gt;性别&lt;/td&gt;
                &lt;td&gt;&lt;input type=&quot;radio&quot; id=&quot;male&quot; name=&quot;sex&quot;&gt; &lt;label for=&quot;male&quot;&gt;男&lt;/label&gt; 
                    &lt;input type=&quot;radio&quot; id=&quot;female&quot; name=&quot;sex&quot;&gt; &lt;label for=&quot;female&quot;&gt;女&lt;/label&gt;
                &lt;/td&gt;
            &lt;/tr&gt;

            &lt;tr&gt;
                &lt;td&gt;生日&lt;/td&gt;
                &lt;td&gt;
                    &lt;!-- 年 --&gt;
                    &lt;select&gt;
                        &lt;option selected=&quot;selected&quot;&gt;请选择年份--&lt;/option&gt;
                        &lt;option&gt;1998&lt;/option&gt;
                        &lt;option&gt;1999&lt;/option&gt;
                        &lt;option&gt;2000&lt;/option&gt;
                        &lt;option&gt;2001&lt;/option&gt;
                        &lt;option&gt;2002&lt;/option&gt;
                        &lt;option&gt;2003&lt;/option&gt;
                        &lt;option&gt;2004&lt;/option&gt;
                        &lt;option&gt;2005&lt;/option&gt;
                        &lt;option&gt;2006&lt;/option&gt;
                        &lt;option&gt;2007&lt;/option&gt;
                        &lt;option&gt;2008&lt;/option&gt;
                    &lt;/select&gt;
                    &lt;!-- 月 --&gt;
                    &lt;select&gt;
                        &lt;option selected=&quot;selected&quot;&gt;请选择月份--&lt;/option&gt;
                        &lt;option&gt;1&lt;/option&gt;
                        &lt;option&gt;2&lt;/option&gt;
                        &lt;option&gt;3&lt;/option&gt;
                        &lt;option&gt;4&lt;/option&gt;
                        &lt;option&gt;5&lt;/option&gt;
                        &lt;option&gt;6&lt;/option&gt;
                        &lt;option&gt;7&lt;/option&gt;
                        &lt;option&gt;8&lt;/option&gt;
                        &lt;option&gt;9&lt;/option&gt;
                        &lt;option&gt;10&lt;/option&gt;
                        &lt;option&gt;11&lt;/option&gt;
                        &lt;option&gt;12&lt;/option&gt;
                    &lt;/select&gt;
                    &lt;!-- 日 --&gt;
                    &lt;select&gt;
                        &lt;option selected=&quot;selected&quot;&gt;请选择日--&lt;/option&gt;
                        &lt;option&gt;1&lt;/option&gt;
                        &lt;option&gt;2&lt;/option&gt;
                        &lt;option&gt;3&lt;/option&gt;
                        &lt;option&gt;4&lt;/option&gt;
                        &lt;option&gt;5&lt;/option&gt;
                        &lt;option&gt;6&lt;/option&gt;
                        &lt;option&gt;7&lt;/option&gt;
                        &lt;option&gt;8&lt;/option&gt;
                        &lt;option&gt;9&lt;/option&gt;
                        &lt;option&gt;10&lt;/option&gt;
                        &lt;option&gt;11&lt;/option&gt;
                        &lt;option&gt;12&lt;/option&gt;
                        &lt;option&gt;13&lt;/option&gt;
                        &lt;option&gt;14&lt;/option&gt;
                        &lt;option&gt;15&lt;/option&gt;
                        &lt;option&gt;16&lt;/option&gt;
                        &lt;option&gt;17&lt;/option&gt;
                        &lt;option&gt;18&lt;/option&gt;
                        &lt;option&gt;19&lt;/option&gt;
                        &lt;option&gt;20&lt;/option&gt;
                        &lt;option&gt;21&lt;/option&gt;
                    &lt;/select&gt;
                &lt;/td&gt;
            &lt;/tr&gt;

            &lt;tr&gt;
                &lt;td&gt;所在地区&lt;/td&gt;
                &lt;td&gt;
                    &lt;input type=&quot;text&quot; value=&quot;中大&quot;&gt;
                &lt;/td&gt;
            &lt;/tr&gt;

            &lt;tr&gt;
                &lt;td&gt;学历&lt;/td&gt;
                &lt;td&gt;
                    &lt;input type=&quot;text&quot; value=&quot;幼儿园&quot;&gt;
                &lt;/td&gt;
            &lt;/tr&gt;

            &lt;tr&gt;
                &lt;td&gt;喜欢的类型&lt;/td&gt;
                &lt;td&gt;
                    &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot;&gt; 妩媚的
                    &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot;&gt; 可爱的
                    &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot;&gt; 老腊肉
                    &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot;&gt; 小鲜肉
                    &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot;&gt; 都喜欢
                &lt;/td&gt;
            &lt;/tr&gt;

            &lt;tr&gt;
                &lt;td&gt;自我介绍&lt;/td&gt;
                &lt;td&gt;
                    &lt;textarea&gt;&lt;/textarea&gt;
                &lt;/td&gt;
            &lt;/tr&gt;

            &lt;tr&gt;
                &lt;td&gt;&lt;/td&gt;
                &lt;td&gt;
                    &lt;input type=&quot;submit&quot; value=&quot;免费注册&quot;&gt;
                &lt;/td&gt;
            &lt;/tr&gt;

            &lt;tr&gt;
                &lt;td&gt;&lt;/td&gt;
                &lt;td&gt;
                    &lt;input type=&quot;checkbox&quot; checked=&quot;checked&quot; name=&quot;agreement&quot;&gt; 我同意注册条款和会员加入标准
                &lt;/td&gt;
            &lt;/tr&gt;

            &lt;tr&gt;
                &lt;td&gt;&lt;/td&gt;
                &lt;td&gt;
                    &lt;a href=&quot;https://zzygeo.cn&quot; target=&quot;_blank&quot;&gt;我是会员，立即登录&lt;/a&gt;
                &lt;/td&gt;
            &lt;/tr&gt;

            &lt;tr&gt;
                &lt;td&gt;&lt;/td&gt;
                &lt;td&gt;
                    &lt;h5&gt;我承诺&lt;/h5&gt;
                    &lt;ul&gt;
                        &lt;li&gt;年满18岁、单身&lt;/li&gt;
                        &lt;li&gt;抱着严肃的态度&lt;/li&gt;
                        &lt;li&gt;真诚寻找另外一半&lt;/li&gt;
                    &lt;/ul&gt;
                &lt;/td&gt;
            &lt;/tr&gt;
        &lt;/table&gt;

    &lt;/form&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><p>CSS的主要使用场景就是美化页面、布局页面的。</p>
<p>1.HTML的局限性</p>
<p>HTML它只关注内容的语义，虽然HTML可以做简单的样式，但是带来的是无尽的臃肿和繁琐。</p>
<p>2.CSS也是一种标记语言，CSS主要用于设置HTML页面中的文本内容（字体、大小、对齐方式）、图片的外形（宽高、边框样式、边距等）以及版面的布局和外观显示样式。</p>
<h2 id="css语法规范"><a href="#css语法规范" class="headerlink" title="css语法规范"></a>css语法规范</h2><p>css规则由两个主要的部分构成：选择器以及一条或多条声明。</p>
<pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
    &lt;style&gt;
        /* 选择器&#123;样式&#125; */
        /* 给谁改样式&#123;改成什么样式&#125; */
        p&#123;
            color: red;
            font-size: 12px;
        &#125;
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;p&gt;有点意思&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<ul>
<li>选择器是用于指定css样式的HTML标签，花括号内是对该对象设置的具体样式</li>
<li>属性和属性值以“键值对”的形式出现</li>
<li>属性是对指定的对象设置的样式属性，例如字体大小、文本颜色等</li>
<li>属性和属性值之间用英文“；”分开</li>
</ul>
<h2 id="css的代码风格"><a href="#css的代码风格" class="headerlink" title="css的代码风格"></a>css的代码风格</h2><p>1.样式格式书写</p>
<p>推荐展开式书写，因为更加直观。</p>
<p>2.样式大小写</p>
<p>推荐以小写字母书写</p>
<p>3.空格规范</p>
<ol>
<li>属性值前面，冒号后面，保留一个空格</li>
<li>选择器（标签）和大括号中间保留空格</li>
</ol>
<h2 id="css选择器"><a href="#css选择器" class="headerlink" title="css选择器"></a>css选择器</h2><p>选择器就是根据不同需求把不同的标签选出来，这就是选择器的作用。简单来说，就是选择标签用的。</p>
<p>选择器分为==基础选择器==和==复合选择器==两个大类。</p>
<p>基础选择器是由单个选择器组成的</p>
<p>基础选择器又包括：标签选择器、类选择器、id选择器和通配符选择器。</p>
<h3 id="标签选择器"><a href="#标签选择器" class="headerlink" title="标签选择器"></a>标签选择器</h3><pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
    &lt;style&gt;
        /* 标签选择器：写上标签名 */
        p &#123;
            color: green;
        &#125;
        div &#123;
            color: pink;
        &#125;
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;p&gt;男生&lt;/p&gt;
    &lt;p&gt;男生&lt;/p&gt;
    &lt;p&gt;男生&lt;/p&gt;
    &lt;div&gt;女生&lt;/div&gt;
    &lt;div&gt;女生&lt;/div&gt;
    &lt;div&gt;女生&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>作用：</p>
<p>标签选择器可以把某一类标签全部选择出来，比如所有的div标签和所有的span标签。</p>
<p>优点：</p>
<p>能快速为页面中同一类型的标签统一设置样式。</p>
<p>缺点：</p>
<p>不能设计差异化样式，只能选择全部的当前标签。</p>
<h3 id="类选择器"><a href="#类选择器" class="headerlink" title="类选择器"></a>类选择器</h3><p>如果想要差异化选择不同的标签，单独选一个或者某几个标签，可以使用类选择器。</p>
<p>类选择器在HTML中以class属性表示，在css中，类选择器以一个点“.”号显示。</p>
<pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
    &lt;style&gt;
         /* 类选择器口诀：样式点定义 结构类调用 */
       .red &#123;
            color: red;
       &#125;
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;p&gt;男生&lt;/p&gt;
    &lt;p&gt;男生&lt;/p&gt;
    &lt;p&gt;男生&lt;/p&gt;
    &lt;div class=&quot;red&quot;&gt;女生&lt;/div&gt;
    &lt;div&gt;女生&lt;/div&gt;
    &lt;div&gt;女生&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
    &lt;style&gt;
        /* 类选择器口诀：样式点定义 结构类调用 */
       .red &#123;
            width: 100px;
            height: 100px;
            /* 背景颜色 */
            background-color: red;
       &#125;
       .green &#123;
           width: 100px;
           height: 100px;
           background-color: green;
       &#125;
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class=&quot;red&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;green&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;red&quot;&gt;&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="多类名"><a href="#多类名" class="headerlink" title="多类名"></a>多类名</h3><p>我们可以给一个标签指定多个类名，从而达到更多的选择目的。这些类名都可以选出这个标签。简单理解就是一个标签有多个名字。</p>
<p>多类名的使用方式：</p>
<pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
    &lt;style&gt;
        /* 类选择器口诀：样式点定义 结构类调用 */
       .red &#123;
           color: red;
       &#125;
       .green &#123;
           color: green;
       &#125;
       .font35 &#123;
           font-size: 35px;
       &#125;
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class=&quot;red font35&quot;&gt;刘德华&lt;/div&gt;
&lt;/html&gt;
</code></pre>
<p>1.在标签class属性中写多个类名</p>
<p>2.多个类名中间必须用空格分开</p>
<p>3.这个标签就可以分别具有这些类名的样式</p>
<p>多类名开发中使用场景：</p>
<p>1.可以把一些标签元素相同的样式（共同的部分）放到一个类里面</p>
<p>2.这些标签都可以调用这个公共的类，然后再调用自己独有的类。</p>
<h3 id="id选择器"><a href="#id选择器" class="headerlink" title="id选择器"></a>id选择器</h3><p>id选择器可以为标有特定id的HTML元素指定特定的样式。</p>
<p>HTML元素以id属性来设置id选择器，CSS中id选择器以“#”来定义。</p>
<pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
    &lt;style&gt;
       #pink &#123;
           color: pink;
       &#125;
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;pink&quot;&gt;Jack&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>重点：==id属性只能在每个HTML文档中出现一次。==</p>
<h3 id="通配符选择器"><a href="#通配符选择器" class="headerlink" title="通配符选择器"></a>通配符选择器</h3><p>在CSS中，通配符选择器使用*定义，它表示选取页面中的所有元素。</p>
<pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
    &lt;style&gt;
       * &#123;
           color: red;
       &#125;
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div&gt;Jack&lt;/div&gt;
    &lt;span&gt;我的&lt;/span&gt;
    &lt;ul&gt;
        &lt;li&gt;还是我的&lt;/li&gt;
    &lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>细节：</p>
<p>通配符选择器不需要调用，自动就给所有的元素使用样式</p>
<p>特殊情况下才使用，清除所有的元素标签的内外边距</p>
<h2 id="css字体属性"><a href="#css字体属性" class="headerlink" title="css字体属性"></a>css字体属性</h2><p>css字体属性用于定义字体系列、大小、粗细和文字样式。</p>
<h3 id="字体系列："><a href="#字体系列：" class="headerlink" title="字体系列："></a>字体系列：</h3><p>css使用font-family属性定义文本的字体系列</p>
<ol>
<li>各种字体之间必须使用英文状态下的逗号隔开</li>
<li>一般情况下，如果有空格隔开的多个单词组成的字体，加引号</li>
<li>尽量使用系统默认自带字体，保证在任何用户的浏览器中都能正确显示</li>
<li>一般写在body标签</li>
</ol>
<h3 id="字体大小"><a href="#字体大小" class="headerlink" title="字体大小"></a>字体大小</h3><p>css使用font-size属性定义字体大小</p>
<ol>
<li>px（像素）大小是我们网页的最常用的单位</li>
<li>谷歌浏览器默认的文字大小为16px</li>
<li>不同浏览器可能默认显示的字号大小不一致，我们尽量给一个明确值大小，不要默认大小</li>
<li>可以body指定整个页面文字的大小</li>
</ol>
<pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
    &lt;style&gt;
        body &#123;
            font-size: 18px;
            font-family: &#39;Times New Roman&#39;, Times, serif;
        &#125;
        /* 标题大小比较特殊，需要单独去设置大小 */
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h2&gt;今天天气真好&lt;/h2&gt;
    &lt;p&gt;多云&lt;/p&gt;
    &lt;p&gt;多云&lt;/p&gt;
    &lt;p&gt;多云&lt;/p&gt;
    &lt;p&gt;多云&lt;/p&gt;
    &lt;p&gt;多云&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="字体粗细"><a href="#字体粗细" class="headerlink" title="字体粗细"></a>字体粗细</h3><p>css使用font-weight属性设置文本字体的粗细</p>
<p>属性值有normal和bold</p>
<h3 id="字体样式"><a href="#字体样式" class="headerlink" title="字体样式"></a>字体样式</h3><p>font-style</p>
<p>属性值有三个：noraml、italic、oblique</p>
<h3 id="简写字体属性"><a href="#简写字体属性" class="headerlink" title="简写字体属性"></a>简写字体属性</h3><p>格式固定：font：font-style    font-weight    font-size/line-height    font-family</p>
<pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
    &lt;style&gt;
        div &#123;
            font: italic normal 16px/30px &#39;Microsoft yahei&#39;;
        &#125;
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div&gt;我要实现深圳中产&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<ol>
<li>使用font属性时，必须按上面语法格式中的顺序书写，不能更换顺序，并且各个属性间以空格隔开</li>
<li>不需要设置的属性可以省略（取默认值），但==必须保留font-size和font-family属性==，否则font属性将不起作用</li>
</ol>
<h2 id="css文本属性"><a href="#css文本属性" class="headerlink" title="css文本属性"></a>css文本属性</h2><p>css属性可定义文本的外观，比如文本的颜色、对齐文本、装饰文本、文本缩进、行间距等。</p>
<h3 id="文本颜色"><a href="#文本颜色" class="headerlink" title="文本颜色"></a>文本颜色</h3><p>color属性用于定义文本的颜色</p>
<p>表示形式：预定义的颜色值、十六进制、RGB代码</p>
<pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
    &lt;style&gt;
        div &#123;
            /* color: #e21cd2; */
            color: rgb(221, 33, 158);
        &#125;
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div&gt;我要实现深圳中产&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="对齐文本"><a href="#对齐文本" class="headerlink" title="对齐文本"></a>对齐文本</h3><p>text-align属性用于设置元素内文本内容的==水平对齐方式==，属性值有left、right、center</p>
<pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
    &lt;style&gt;
        h2 &#123;
            text-align: center;
        &#125;
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h2&gt;居中对齐的文本&lt;/h2&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="装饰文本"><a href="#装饰文本" class="headerlink" title="装饰文本"></a>装饰文本</h3><p>text-decoration属性规定添加到文本的修饰。可以给文本添加下划线、删除线、上划线等。</p>
<p>属性值有none、underline、overline、line-through。分别为默认、下划线、上划线、删除线</p>
<pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
    &lt;style&gt;
        div &#123;
            text-decoration: underline;
        &#125;
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div&gt;粉红色的回忆&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="文本缩进"><a href="#文本缩进" class="headerlink" title="文本缩进"></a>文本缩进</h3><p>text-indent属性用来==指定文本的第一行的缩进==，通常是将段落的首行缩进。</p>
<p>em是一个相对单位，就是当前元素（font-size）1个文字大小，如果当前元素</p>
<p>没有设置大小，则会按照父元素的1个文字大小。</p>
<pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
    &lt;style&gt;
        p &#123;
           text-indent: 2em;
        &#125;
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;p&gt;这是第一段&lt;/p&gt;
    &lt;p&gt;这是第二段&lt;/p&gt;
    &lt;p&gt;这是第三段&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="行间距"><a href="#行间距" class="headerlink" title="行间距"></a>行间距</h3><p>line-height属性用于设置行间的距离（行高）。可以控制文字行与行之间的距离。</p>
<p>行高由三部分组成，上间距、字高、下间距。</p>
<h2 id="css三种样式表"><a href="#css三种样式表" class="headerlink" title="css三种样式表"></a>css三种样式表</h2><p>按照css样式书写的位置，css样式表可以分为三大类</p>
<ol>
<li>行内样式表（行内式）</li>
<li>内部样式表（嵌入式）</li>
<li>外部样式表（链接式）</li>
</ol>
<h3 id="内部样式表"><a href="#内部样式表" class="headerlink" title="内部样式表"></a>内部样式表</h3><p>内部样式表是写到html页面内部，是将所有的css代码抽取出来，单独放到一个style标签中。</p>
<pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
    &lt;style&gt;
        p &#123;
           text-indent: 2em;
        &#125;
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;p&gt;这是第一段&lt;/p&gt;
    &lt;p&gt;这是第二段&lt;/p&gt;
    &lt;p&gt;这是第三段&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<ol>
<li>style标签理论上可以放在HTML文档的任何地方，但一般会放在文档的head标签中</li>
<li>通过此种方式，可以方便控制当前整个页面中的元素样式设置</li>
<li>代码的结构非常清晰，但是并没有实现结构与样式的完全分离</li>
</ol>
<h3 id="行内样式表"><a href="#行内样式表" class="headerlink" title="行内样式表"></a>行内样式表</h3><p>行内样式表（内联样式表）是在元素标签内部的style属性中设定css样式。适合修改简单样式</p>
<pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div style=&quot;color: red; font-size: 12px;&quot;&gt;给我一个粉红色的回忆&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<ol>
<li>style其实就是标签的属性值</li>
<li>在双引号之间，写法要符合css规范</li>
<li>可以控制当前的标签设置样式</li>
<li>书写繁琐，并没有体现出结构与样式相分离的思想，不推荐大量使用，只有对当前元素添加简单样式的时候，可以考虑使用</li>
</ol>
<h3 id="外部样式表"><a href="#外部样式表" class="headerlink" title="外部样式表"></a>外部样式表</h3><p>实际开发都是外部样式表，适合于样式比较多的情况，核心是：样式单独写到css文件之间，之后把css文件引入到HTMl页面中使用。</p>
<ol>
<li>新建一个后缀名为.css的样式文件，把所有css代码都放入此文件中。</li>
<li>在HTML页面中，使用link标签引入这个文件。</li>
</ol>
<pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;./styles/test.css&quot;&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div&gt;毕业快乐&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<pre><code class="lang-css">/* 这个css文件里面只有样式，没有标签 */
div &#123;
    color: deeppink;
&#125;
</code></pre>
<h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
    &lt;style&gt;
        body &#123;
            font: 16px/28px &#39;Microsoft yahei&#39;;
        &#125;
        h1 &#123;
            text-align: center;
            font-weight: normal;
        &#125;
        .gray &#123;
            text-align: center;
            color: #888888;
        &#125;
        a &#123;
            text-decoration: none;
        &#125;
        p &#123;
            text-indent: 2em;
        &#125;
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;总书记挂念的红色老区｜花茂村的“美丽乡愁”&lt;/h1&gt;
    &lt;div class=&quot;gray&quot;&gt;
        2021-06-15 来源:&lt;a href=&quot;https://zzygeo.cn&quot; target=&quot;_blank&quot;&gt; 中国天气网&lt;/a&gt;&amp;nbsp;&amp;nbsp;&lt;input type=&quot;text&quot;&gt; 
        &lt;input type=&quot;button&quot; value=&quot;搜索&quot;&gt;
    &lt;/div&gt;
    &lt;p&gt;编者按：老区苏区孕育了中国革命，是中国共产党的初心之源。习近平总书记曾深情地说：“我是在这样的氛围中耳濡目染走过来的，工作过的很多地方都是老区，对老区的感情是很深厚的。”
    &lt;/p&gt;
    &lt;p&gt; 习近平总书记出生于革命军人家庭，成长在陕北黄土高坡，“红色基因”深深融入他的血脉。在地方工作期间，他就一直关注当地老区发展和老区人民生活情况。党的十八大以来，总书记对老区的挂念一如既往，他频频踏上红色土地，看望慰问老区人民。中国共产党成立100周年之际，央视网《天天学习》栏目推出特别策划《总书记挂念的红色老区》，讲述红色故事，展现老区的发展与变迁。
    &lt;/p&gt;   
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h2 id="Emmet语法"><a href="#Emmet语法" class="headerlink" title="Emmet语法"></a>Emmet语法</h2><p>Emmet语法的前身是Zen coding，他使用缩写来提高html/css的编写速度，VsCode内部已经集成该语法</p>
<p>1.快速生成HTML结构语法</p>
<ul>
<li>生成标签，直接输入标签名，按tab键即可</li>
<li>如果想要生成多个相同标签，加上*号就可以</li>
<li>如果有父子级关系的标签，可以用&gt; 比如ul&gt;li就可以了</li>
<li>如果有兄弟关系的标签，用+就可以了，比如div+p</li>
<li>如果生成带有类名或者id名字的，直接写.demo或者#two tab键就可以了</li>
<li>如果生成的div类名是有顺序的，可以用自增符号￥</li>
<li>如果想要在生成的标签内部写内容可以用{}表示</li>
</ul>
<p>2.快速生成css样式语法</p>
<p>css基本采取简写形式即可</p>
<ul>
<li>比如w200 按tab 可以生成width:200px;</li>
<li>比如lh26 按tab 可以生成 line-height:26px;</li>
</ul>
<h2 id="css复合选择器"><a href="#css复合选择器" class="headerlink" title="css复合选择器"></a>css复合选择器</h2><p>在css中，可以把选择器分为基础选择器和复合选择器，复合选择器是建立在基础选择器之上，对基础选择器进行组合的。</p>
<ul>
<li>复合选择器可以更准确、更高效的选择目标元素（标签）</li>
<li>复合选择器是由两个或多个基础选择器，通过不同的方式组合而成的</li>
<li>常用的复合选择器包括：后代选择器、子选择器、并集选择器、伪类选择器等</li>
</ul>
<h3 id="后代选择器（重要）"><a href="#后代选择器（重要）" class="headerlink" title="后代选择器（重要）"></a>后代选择器（重要）</h3><p>后代选择器又称为包含选择器，可以选择父元素里面子元素。其写法就是把==外层标签写在前面，内层标签写在后面，中间用空格分隔==。当标签发生嵌套时，内层标签就称为外层标签的后代。</p>
<pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;

&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
    &lt;style&gt;
        /* 我想把ol里面的小li选出来改为pink */
        ol li &#123;
            color: deeppink;
        &#125;
        ol li a &#123;
            text-decoration: none;
            color: greenyellow;
        &#125;
        .yellow li a &#123;
            color: aqua;
        &#125;
    &lt;/style&gt;
&lt;/head&gt;

&lt;body&gt;
    &lt;ol&gt;
        &lt;li&gt;我是ol的孩子&lt;/li&gt;
        &lt;li&gt;我是ol的孩子&lt;/li&gt;
        &lt;li&gt;我是ol的孩子&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;#&quot;&gt;我是孙子&lt;/a&gt;&lt;/li&gt;
    &lt;/ol&gt;
    &lt;ul&gt;
        &lt;li&gt;我是ul的孩子&lt;/li&gt;
        &lt;li&gt;我是ul的孩子&lt;/li&gt;
        &lt;li&gt;我是ul的孩子&lt;/li&gt;
    &lt;/ul&gt;
    &lt;ol class=&quot;yellow&quot;&gt;
        &lt;li&gt;我是ol的孩子&lt;/li&gt;
        &lt;li&gt;我是ol的孩子&lt;/li&gt;
        &lt;li&gt;我是ol的孩子&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;#&quot;&gt;我是孙子&lt;/a&gt;&lt;/li&gt;
    &lt;/ol&gt;
&lt;/body&gt;

&lt;/html&gt;
</code></pre>
<p>细节：</p>
<ol>
<li>元素1和元素2中间用空格隔开</li>
<li>元素1是父级，元素2是子级，最终选择的是元素2</li>
<li>元素2可以是儿子，也可以是孙子，只要是元素1的后代即可</li>
<li>元素1和元素2可以是任意基础选择器</li>
</ol>
<h3 id="子选择器（重要）"><a href="#子选择器（重要）" class="headerlink" title="子选择器（重要）"></a>子选择器（重要）</h3><p>子元素选择器只能选择作为某元素的最近一级子元素。简单理解就是选亲儿子元素。</p>
<pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;

&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
    &lt;style&gt;
        .nav&gt;a &#123;
            color: deeppink;
        &#125;
    &lt;/style&gt;
&lt;/head&gt;

&lt;body&gt;
    &lt;div class=&quot;nav&quot;&gt;
        &lt;a href=&quot;#&quot;&gt;我是儿子&lt;/a&gt;    
        &lt;p&gt;
            &lt;a href=&quot;#&quot;&gt;我是孙子&lt;/a&gt;
        &lt;/p&gt;
    &lt;/div&gt;
&lt;/body&gt;

&lt;/html&gt;
</code></pre>
<p>细节：</p>
<ol>
<li>元素1和元素2中间用大于号隔开</li>
<li>元素1是父级，元素2是子级，最终选择的是元素2</li>
<li>元素2必须是亲儿子，其孙子、重孙之类都不归他管</li>
</ol>
<h3 id="并集选择器"><a href="#并集选择器" class="headerlink" title="并集选择器"></a>并集选择器</h3><p>并集选择器可以选择多组标签，同时为他们定义相同的样式。通常用于集体声明。</p>
<p>并集选择器是各选择器通过英文逗号连接而成，任何形式的选择器都可以作为并集选择器的一部分。</p>
<pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;

&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
    &lt;style&gt;
        /* 约定的语法规范，并集选择器喜欢竖着写 */
      a,
      p &#123;
          color: red;
      &#125;
    &lt;/style&gt;
&lt;/head&gt;

&lt;body&gt;
   &lt;div class=&quot;hot&quot;&gt;
       &lt;a href=&quot;#&quot;&gt;大肘子&lt;/a&gt;
       &lt;ul&gt;
           &lt;li&gt;&lt;a href=&quot;#&quot;&gt;猪头&lt;/a&gt;&lt;/li&gt;
           &lt;li&gt;&lt;a href=&quot;#&quot;&gt;猪尾巴&lt;/a&gt;&lt;/li&gt;
       &lt;/ul&gt;
       &lt;p&gt;四川凉菜&lt;/p&gt;
   &lt;/div&gt;
&lt;/body&gt;

&lt;/html&gt;
</code></pre>
<p>细节：</p>
<ol>
<li>元素1和元素2中间用逗号隔开</li>
<li>逗号可以理解为和的意思</li>
<li>并集选择器通常用于集体声明</li>
</ol>
<h3 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h3><p>伪类选择器用于向某些选择器添加特殊的效果，比如给链接添加特殊效果，或选择第1个，第n个元素。</p>
<p>伪类选择器书写的最大特点是用冒号：表示。</p>
<p>==链接伪类选择器：==</p>
<pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;

&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
    &lt;style&gt;
        /* 未访问的链接 a:link */
        a:link &#123;
            color: #333;
            text-decoration: none;
        &#125;
        /* 访问过的链接 a:visited */
        a:visited &#123;
            color: orange;
        &#125;  
        /* 选择鼠标经过的链接 a:hover */
        a:hover &#123;
            color: skyblue;
        &#125;
        /* 选择的是我们鼠标正在按下还没有弹起鼠标的那个链接 */
        a:active &#123;
            color: green;
        &#125;
    &lt;/style&gt;
&lt;/head&gt;

&lt;body&gt;
   &lt;a href=&quot;#&quot;&gt;小猪佩奇&lt;/a&gt;
   &lt;br&gt;
   &lt;a href=&quot;https://zzygeo.cn&quot;&gt;myblog&lt;/a&gt;
&lt;/body&gt;

&lt;/html&gt;
</code></pre>
<p>链接伪类选择器注意事项</p>
<ol>
<li>为了确保生效，按照LVHA顺序声明：link-visited-hover-active</li>
<li>因为a链接在浏览器中具有默认样式，所以在实际工作中都需要给链接单独指定样式</li>
</ol>
<p>==focus伪类选择器==</p>
<p>focus伪类选择器用于选取获得焦点的表单元素。</p>
<p>焦点就是光标，一般情况下 input类表单元素才能获取，因此这个选择器也主要针对于表单元素来说。</p>
<pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;

&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
    &lt;style&gt;
        input:focus &#123;
            background-color: blue;
        &#125;
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
   &lt;input type=&quot;text&quot;&gt;
   &lt;input type=&quot;text&quot;&gt;
   &lt;input type=&quot;text&quot;&gt;
&lt;/body&gt;

&lt;/html&gt;
</code></pre>
<h2 id="css的元素显示模式"><a href="#css的元素显示模式" class="headerlink" title="css的元素显示模式"></a>css的元素显示模式</h2><p>了解元素的显示模式可以更好的让我们布局页面。</p>
<p>什么是元素的显示模式</p>
<p>作用：网页的标签非常多，在不同的地方会用到不同类型的标签，了解他们的特点可以更好的布局我们的网页。</p>
<p>元素显示模式就是==标签以什么方式进行显示==，比如div自己占一行，比如一个可以放多个span</p>
<p>HTML元素一般分为==块元素==和==行内元素==两种类型。</p>
<h3 id="块元素"><a href="#块元素" class="headerlink" title="块元素"></a>块元素</h3><p>常见的块元素有h1-h6、p、div、ul、ol、li等，其中div标签是最典型的块元素。</p>
<p>块级元素的特点：</p>
<ol>
<li>比较霸道，自己独占一行。</li>
<li>高度、宽度、外边距以及内边距都可以控制。</li>
<li>宽度默认是容器（父级宽度）的100%。</li>
<li>是一个容器及盒子，里面可以放行内或块级元素。</li>
</ol>
<p>注意：</p>
<ol>
<li>文字类的元素内不能使用块级元素</li>
<li>p标签主要用于存放文字，因为p里面不能放块级元素，特别是不能放div</li>
<li>同理，h1-h6等都是文字类块级标签，里面也不能放其他块级元素</li>
</ol>
<h3 id="行内元素"><a href="#行内元素" class="headerlink" title="行内元素"></a>行内元素</h3><p>常见的行内元素有a、strong、b、em、i、del、s、ins、u、span等，其中span标签是最典型的行内元素。有的地方也将行内元素称为内联元素。</p>
<p>行内元素的特点：</p>
<ol>
<li>相邻行内元素在一行上，一行可以显示多个。</li>
<li>高宽直接设置是无效的。</li>
<li>默认宽度就是它本身内容的宽度。</li>
<li>行内元素只能容纳文本或者其他行内元素。</li>
</ol>
<p>注意：</p>
<ol>
<li>链接里面不能再放链接</li>
<li>==特殊情况下a里面可以放块级元素，但是给a转换一下块级模式最安全==</li>
</ol>
<h3 id="行内块元素"><a href="#行内块元素" class="headerlink" title="行内块元素"></a>行内块元素</h3><p>在行内元素中有几个特殊的标签 image、input、td，他们同时具有块元素和行内元素的特点。有些资料称它们为行内块元素。</p>
<pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;

&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
    &lt;style&gt;
        input &#123;
            width: 200px;
            height: 30px;
        &#125;
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;input type=&quot;text&quot;&gt;
    &lt;input type=&quot;text&quot;&gt;
&lt;/body&gt;

&lt;/html&gt;
</code></pre>
<p>行内块元素的特点：</p>
<ol>
<li>和相邻行内元素（行内块）在一行上，但是他们之间会有空白缝隙。一行可以显示多个（行内元素的特点）</li>
<li>默认高度就是它本身内容的宽度（行内元素的特点）</li>
<li>高度、行高、外边距以及内边距都可以控制（块级元素的特点）</li>
</ol>
<h2 id="元素显示模式转换"><a href="#元素显示模式转换" class="headerlink" title="元素显示模式转换"></a>元素显示模式转换</h2><p>特殊情况下，我们需要元素模式的转行，简单理解：一个模式的元素需要另外一种模式的特性</p>
<p>比如想要增加链接a的触发范围。</p>
<pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;

&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
    &lt;style&gt;
        a &#123;
            width: 200px;
            height: 50px;
            background-color: rgb(224, 41, 215);
            /* 把行内元素a转行为块级元素 */
            display: block;
        &#125;
        div &#123;
            width: 200px;
            height: 100px;
            background-color: rgb(255, 0, 0);
            /* 把块级元素转行为行内元素 */
            display: inline;
        &#125;
        span &#123;
            width: 200px;
            height: 50px;
            background-color: rgb(98, 0, 255);
            display: inline-block;
        &#125;
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;!-- 想把a变大，但是行内元素不能设置宽和高 --&gt;
    &lt;a href=&quot;#&quot;&gt;金星阿姨&lt;/a&gt;
    &lt;a href=&quot;#&quot;&gt;金星阿姨&lt;/a&gt;
    &lt;div&gt;我是块级元素&lt;/div&gt;
    &lt;div&gt;我是块级元素&lt;/div&gt;
    &lt;span&gt;行内元素&lt;/span&gt;
    &lt;span&gt;行内元素&lt;/span&gt;
&lt;/body&gt;

&lt;/html&gt;
</code></pre>
<p>转换为块元素：display:block</p>
<p>转换为行内元素：display:inline</p>
<p>转行为行内块元素：display:inline-block</p>
<p>练习：</p>
<p>css没有给我们提供文字垂直居中的代码，但是可以通过让文字的行高等于盒子的高度，就可以让文字在当前盒子内垂直居中。行高小于盒子高度，文字会偏上，如果行高大于盒子高度，则文字会偏下。</p>
<pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;

&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
    &lt;style&gt;
       a &#123;
           width: 230px;
           height: 40px;
           display: block;
           background-color:#535758 ;
           font-size: 14px;
           color: #fff;
           text-decoration: none;
           text-indent: 2em;
           line-height: 40px;
       &#125;
       a:hover &#123;
           background-color: #ff6f00;
       &#125;
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;a href=&quot;#&quot;&gt;手机 电话卡&lt;/a&gt;
    &lt;a href=&quot;#&quot;&gt;电视 盒子&lt;/a&gt;
    &lt;a href=&quot;#&quot;&gt;笔记本 平板&lt;/a&gt;
    &lt;a href=&quot;#&quot;&gt;出行 穿搭&lt;/a&gt;
    &lt;a href=&quot;#&quot;&gt;智能 路由器&lt;/a&gt;
    &lt;a href=&quot;#&quot;&gt;健康 儿童&lt;/a&gt;
    &lt;a href=&quot;#&quot;&gt;耳机 音响&lt;/a&gt;
&lt;/body&gt;

&lt;/html&gt;
</code></pre>
<h2 id="css的背景"><a href="#css的背景" class="headerlink" title="css的背景"></a>css的背景</h2><p>通过css背景属性，可以给页面元素添加背景样式。</p>
<p>背景属性可以设置背景颜色、背景图片、背景平铺、背景图片位置、背景图像固定等。</p>
<h3 id="背景颜色："><a href="#背景颜色：" class="headerlink" title="背景颜色："></a>背景颜色：</h3><p>background-color      transparent为透明色</p>
<h3 id="背景图片："><a href="#背景图片：" class="headerlink" title="背景图片："></a>背景图片：</h3><p>background-image属性描述了元素的背景图像。实际开发常见于logo或者一些装饰性的小图片或者超大的背景图片，==优点是非常便于控制位置==。</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;

&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
    &lt;style&gt;
       div &#123;
           width: 300px;
           height: 300px;
           background-image: url(&quot;图片&quot;);
       &#125;
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div&gt;&lt;/div&gt;
&lt;/body&gt;

&lt;/html&gt;
</code></pre><h3 id="背景平铺"><a href="#背景平铺" class="headerlink" title="背景平铺"></a>背景平铺</h3><p>如果需要在HTML页面上对背景图像进行平铺，可以使用background-repeat属性。</p>
<pre><code>background-repeat: repeat|no-repeat|repeat-x|repeat-y
</code></pre><h3 id="背景图片位置"><a href="#背景图片位置" class="headerlink" title="背景图片位置"></a>背景图片位置</h3><p>利用background-position属性可以改变图片在背景中的位置</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>参数值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>length</td>
<td>百分数\</td>
<td>由浮点数字和单位标识符组成的长度值</td>
</tr>
<tr>
<td>position</td>
<td>top\</td>
<td>center\</td>
<td>bottom\</td>
<td>left\</td>
<td>center\</td>
<td>right</td>
</tr>
</tbody>
</table>
</div>
<p>1.参数是方位名词：</p>
<p>如果指定的两个值都是方位名词，则两个值前后顺序无关，比如left top和top left效果一致</p>
<p>如果只指定了一个方位名词，另一个值省略，则第二个值默认居中对齐</p>
<p>2.参数是精确坐标：</p>
<p>如果参数值是精确坐标，那么第一个肯定是x坐标，第二个一定是y坐标</p>
<p>如果只指定一个数值，那么该数值一定是x坐标，另一个默认垂直居中</p>
<p>3.参数是混合单位：</p>
<p>如果指定的两个值是精确单位和方位名词混合使用，则第一个值是x坐标，第二个值是y坐标</p>
]]></content>
      <categories>
        <category>HTML-CSS</category>
      </categories>
  </entry>
  <entry>
    <title>JavaScript基础</title>
    <url>/2021/06/08/%E5%89%8D%E7%AB%AF3%E5%A4%A7%E4%BB%B6/JavaScript/</url>
    <content><![CDATA[<h1 id="1-JavaScript介绍"><a href="#1-JavaScript介绍" class="headerlink" title="1.JavaScript介绍"></a>1.JavaScript介绍</h1><p>JavaScript实现包含了三个部分，ECMAScript, DOM和BOM</p>
<p>ECMAScript：JavaScript语法</p>
<p>DOM：页面文档对象模型</p>
<p>BOM：浏览器对象模型</p>
<p>JS的特点</p>
<p>1.解释性语言—写完了直接运行，不用去编译</p>
<p>2.类似于C和Java的语法结构</p>
<p>3.动态语言</p>
<p>4.基于原型的面向对象</p>
<p>浏览器执行JS简介</p>
<p>浏览器分为两部分，渲染引擎和JS引擎</p>
<p>渲染引擎：用来解析HTML和CSS，俗称内核，比如chrome浏览器的blink,老版本的webkit</p>
<p>JS引擎：也称为JS解释器。用来读取网页中的JavaScript代码，对其处理后运行，比如chrome浏览器的V8</p>
<h1 id="2-JS有三种书写位置"><a href="#2-JS有三种书写位置" class="headerlink" title="2. JS有三种书写位置"></a>2. JS有三种书写位置</h1><p>1.行内式JS</p>
<pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;

&lt;/head&gt;
&lt;body&gt;
    &lt;input type=&quot;button&quot; value=&quot;点我试试&quot; onclick=&quot;alert(&#39;hello world&#39;)&quot;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<ol>
<li>可以将单行或者少量JS代码写在HTML标签的事件属性中（以on开头的属性），如onclik</li>
<li>注意单双引号的使用：在HTML中我们推荐使用双引号, JS中我们推荐使用单引号</li>
<li>可读性差，在html中编写JS大量代码时，不方便阅读</li>
<li>引号易错，引号多层嵌套匹配时，非常容易弄混</li>
<li>特殊情况下使用</li>
</ol>
<p>2.内嵌式JS</p>
<pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
    &lt;script&gt;
        alert(&#39;hello world!&#39;)
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<ol>
<li>可以将多行JS代码写到script标签中</li>
<li>内嵌JS是学习时常用的方式</li>
</ol>
<p>3.外部JS文件</p>
<pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
   &lt;script src=&quot;hello.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<ol>
<li>利于HTML页面代码结构化，把大段JS代码独立到HTML页面之外，既美观，也方便文件级别的复用</li>
<li>引用外部JS文件的script标签中间不可以写代码</li>
<li>适用于JS代码量比价大的情况</li>
</ol>
<h1 id="3-JavaScript输入输出语句"><a href="#3-JavaScript输入输出语句" class="headerlink" title="3. JavaScript输入输出语句"></a>3. JavaScript输入输出语句</h1><pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
    &lt;script&gt;
        // 这是一个输入框
        prompt(&#39;请输入年龄&#39;);
        // alert弹出警示框
        alert(&#39;计算的结果是&#39;);
        // console 控制台输出 给程序员测试用的,f12进入开发者模式可见
        console.log(&#39;这是程序员能看到的&#39;);
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h1 id="4-数据类型"><a href="#4-数据类型" class="headerlink" title="4. 数据类型"></a>4. 数据类型</h1><p>JavaScript是一种弱类型或者说动态语言，这意味着不用提前声明变量的类型，==在程序运行过程中，类型会被自动确定。==</p>
<p>JavaScript==拥有动态类型，同时也意味着相同的变量可用作不同的类型==</p>
<p>数值型：==isNaN()==可以用来判断非数字，如果是数字返回的是false, 如果不是数字返回的是true</p>
<pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
    &lt;script&gt;
        console.log(isNaN(5)); //false
        console.log(isNaN(&#39;str&#39;)) //true
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>字符串长度，直接变量名.length，注意==这里没有括号==。</p>
<p>布尔类型参与加法运算当做0或1来看待</p>
<p>变量声明未赋值，就是undefined未定义数据类型</p>
<p>undefined和数字相加，最后的结果是NaN</p>
<p>typeof可以检测变量属于什么类型</p>
<pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
    &lt;script&gt;
        var num = 10;
        var str = &#39;明天会更好！&#39;;
        console.log(typeof(num));
        console.log(typeof(str));
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>prompt取过来的值是 字符型的</p>
<h1 id="5-数据类型转换"><a href="#5-数据类型转换" class="headerlink" title="5. 数据类型转换"></a>5. 数据类型转换</h1><p>转换为字符串型</p>
<p>1.把数值型转换为字符串类型 toString();</p>
<pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;title&lt;/title&gt;
  &lt;script&gt;
    var age = 10;
    var str = age.toString();
    console.log(str);
    console.log(typeof str);
  &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>2.利用String()方法</p>
<p>3.利用+拼接字符串的方法实现转换效果</p>
<p>==一般使用的都是第三种方式进行转换，这一方法也称为隐式转换==</p>
<p>转换为数值型</p>
<p>1.通过parseInt函数进行转换，把String转换成整数类型</p>
<pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;title&lt;/title&gt;
  &lt;script&gt;
    var age = prompt(&#39;请输入您的年龄&#39;);
    console.log(parseInt(age));
    console.log(parseInt(&#39;120px&#39;)); //parseInt方法会直接去掉字母，但必须是以数字打头
  &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>2.通过parseFloat可以把String转换为浮点型</p>
<p>3.可以通过Number()进行转换</p>
<p>4.利用算数运算 - *  / 隐式转换</p>
<pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;title&lt;/title&gt;
  &lt;script&gt;
      console.log(&#39;12&#39; - 0);
      console.log(&#39;123&#39; - &#39;120&#39;);
  &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>转换为布尔型</p>
<p>使用Boolean()函数</p>
<p>代表空、否定的值会被转换为false，如’’、0、NaN、null、undefined</p>
<p>其他的值全部会转换成true</p>
<pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;title&lt;/title&gt;
  &lt;script&gt;
      console.log(Boolean(&#39;&#39;));
      console.log(Boolean(0));
      console.log(Boolean(NaN));
      console.log(Boolean(null));
      console.log(Boolean(undefined));
  &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h1 id="6-运算符"><a href="#6-运算符" class="headerlink" title="6. 运算符"></a>6. 运算符</h1><p>=== </p>
<p>!==     全等 要求值和数据类型都一致</p>
<p>运算符优先级</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>优先级</th>
<th>运算符</th>
<th>顺序</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>小括号</td>
<td>()</td>
</tr>
<tr>
<td>2</td>
<td>一元运算符</td>
<td>++ — !</td>
</tr>
<tr>
<td>3</td>
<td>算数运算符</td>
<td>先 * / % 后+ -</td>
</tr>
<tr>
<td>4</td>
<td>关系运算符</td>
<td>&gt; &gt;= &lt; &lt;=</td>
</tr>
<tr>
<td>5</td>
<td>相等运算符</td>
<td>== != ===  !==</td>
</tr>
<tr>
<td>6</td>
<td>逻辑运算符</td>
<td>先&amp;&amp; 后\</td>
<td>\</td>
<td></td>
</tr>
<tr>
<td>7</td>
<td>赋值运算符</td>
<td>=</td>
</tr>
<tr>
<td>8</td>
<td>逗号运算符</td>
<td>，</td>
</tr>
</tbody>
</table>
</div>
<h1 id="7-流程控制"><a href="#7-流程控制" class="headerlink" title="7. 流程控制"></a>7. 流程控制</h1><p>和Java语法类似</p>
<h1 id="8-数组"><a href="#8-数组" class="headerlink" title="8. 数组"></a>8. 数组</h1><p>创建数组的方式有两种</p>
<pre><code class="lang-javascript">var arr = new Array();
var arr1 = [];
var arr2 = [1, 2, &#39;zzy&#39;, true];
</code></pre>
<p>注意JavaScript里的数组是==可以混用数据类型的==</p>
<pre><code class="lang-javascript">console.log(arr1);    //这里打印的不是地址，包含整个数组的信息
</code></pre>
<p>==新增数组元素：修改索引值，追加数组元素==，push方法也可以</p>
<h1 id="9-函数"><a href="#9-函数" class="headerlink" title="9. 函数"></a>9. 函数</h1><pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;title&lt;/title&gt;
  &lt;script&gt;
      function getsum(num1, num2)&#123;
          var sum = 0;
          for (var i = num1; i &lt;= num2 ; i++) &#123;
              sum += i;
          &#125;
          return sum;
      &#125;

      console.log(getsum(10, 20));
  &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>讲道理，这语法有点无耻</p>
<p>函数与数组</p>
<pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;title&lt;/title&gt;
  &lt;script&gt;
      function getmax(arr)&#123;
          var max = arr[0];
          for (var i = 0; i &lt; arr.length; i++) &#123;
              if (arr[i] &gt; max)&#123;
                  max = arr[i];
              &#125;
          &#125;
          return max;
      &#125;
      var re = getmax([5, 2, 99, 101, 67, 77]);
      console.log(re);
  &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>脚本语言就是有点无耻</p>
<p>return 只能返回一个值，传多个以传入的最后一个值为准</p>
<p>函数都是有返回值的</p>
<p>1.如果有return则返回return后面的值</p>
<p>2.如果没有return则返回undefined</p>
<p>break, continue,return的区别</p>
<p>break:结束当前的循环体</p>
<p>continue:跳出本次循环，继续执行下次循环</p>
<p>return:不仅可以退出循环，还能够返回return语句中的值，同时还可以结束当前的函数体内的代码</p>
<h1 id="10-arguments"><a href="#10-arguments" class="headerlink" title="10. arguments"></a>10. arguments</h1><p>在强调一遍脚本语言很无耻。</p>
<p>当我们==不确定有多少个参数传递时==，可以用arguments来获取。在JavaScript中，arguments实际上它是当前函数的一个内置对象。==所有函数都内置了一个arguments对象，arguments对象中存储了传递的所有实参==</p>
<pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;title&lt;/title&gt;
  &lt;script&gt;
     function fn()&#123;
         console.log(arguments);    //arguments是伪数组，没有一些方法，如pop(),
         console.log(arguments[2]);
     &#125;
     fn(1, 2, 3);
  &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h1 id="11-作用域"><a href="#11-作用域" class="headerlink" title="11. 作用域"></a>11. 作用域</h1><p>就是代码名字（变量）在某个范围内起作用和效果，目的是为了提高程序的可靠性，更重要的是减少命名冲突</p>
<p>全局作用域：整个script标签 或者是一个单数的js文件</p>
<p>局部作用域：在函数内部就是局部作用域，这个代码的名字只在函数内部起效果和作用</p>
<p>==注意：如果在函数内部，没有声明直接赋值的变量也属于全局变量==</p>
<pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;title&lt;/title&gt;
  &lt;script&gt;
     function fn()&#123;
         var num1 =10;
         num2 = 20;
     &#125;
     fn();
     console.log(num2);
  &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h1 id="12-预解析"><a href="#12-预解析" class="headerlink" title="12. 预解析"></a>12. 预解析</h1><p>JavaScript代码是由浏览器中的JavaScript解释器来执行的。JavaScript解析器在运行JavaScript的时候分为两步：==预解析和代码执行==。</p>
<p>预解析 js解释器==会把js里面所有的var还有function提升到当前作用域的最前面==</p>
<p>代码执行：按照代码书写的顺序从上往下执行</p>
<p>预解析分为变量预解析（变量提升）和函数预解析（函数提升）</p>
<p>变量提升就是把所有的变量声明提升到当前的作用域最前面,==不提升赋值操作==</p>
<p>函数提升就是把所有的函数声明（感觉js的声明好像也包含了定义的意思）提升到当前作用域的最前面，==不调用函数==</p>
<pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;title&lt;/title&gt;
  &lt;script&gt;
     var a = 18;
     f1();
     function f1()&#123;
         var b = 9;
         console.log(a);
         console.log(b);
         var a = &#39;123&#39;;
     &#125;

     /*
     var a;
     function f1()&#123;
        var b;
        var a;
        b = 9;
        console.log(a); //undefined
        console.log(b); //9
        a = &#39;123&#39;;
     &#125;
     a =18;
     f1();
      */
  &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;title&lt;/title&gt;
  &lt;script&gt;
    f1();
    console.log(c);
    console.log(b);
    console.log(a);
    function f1()&#123;
        var a = b = c = 9;
        console.log(a);
        console.log(b);
        console.log(c);
    &#125;

    /*
     function f1()&#123;
        //相当于var a =9, b =9, c = 9; 函数内部不声明直接赋值相当于全局变量
        var a;
        a = b = c = 9;
        console.log(a); //9
        console.log(b); //9
        console.log(c); //9
    &#125;
    f1();
    console.log(c); //9
    console.log(b); //9
    console.log(a); //报错
     */
  &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h1 id="13-对象"><a href="#13-对象" class="headerlink" title="13. 对象"></a>13. 对象</h1><p>创建对象的三种方式:</p>
<p>利用对象字面量创建对象{}</p>
<pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;title&lt;/title&gt;
  &lt;script&gt;
      //1.利用对象字面量创建对象&#123;&#125;
      // var obj =&#123;&#125;;
    var obj = &#123;
        uname: &#39;杰克船长&#39;,
        age: 18,
        sex: &#39;男&#39;,
        sayHi: function ()&#123;
            console.log(&#39;hi~&#39;)
        &#125;
    &#125;
    /*
    细节： 里面的属性和方法采用键值对的形式 属性名： 属性值
    多个属性或方法中间用逗号隔开
    方法冒号后面跟的是一个匿名函数
     */
  &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>利用new Object创建对象</p>
<pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;title&lt;/title&gt;
  &lt;script&gt;
     var obj = new Object();
     obj.uname = &#39;杰克船长&#39;;
     obj.age = 18;
     obj.sex = &#39;男&#39;;
     obg.sayHi = function ()&#123;
         console.log(&#39;hi~&#39;);
     &#125;
  &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>利用构造函数创建对象</p>
<p>为什么需要构造函数来创建对象：因为前面两种创建对象的方式一次只能创建一个对象，因此可以利用函数的方法，重复这些相同的代码，我们就把这个函数称为构造函数</p>
<p>构造函数：就是把我们对象里面一些相同的属性和方法抽象出来封装到函数里面</p>
<pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;title&lt;/title&gt;
  &lt;script&gt;
     function Star(uname, age, sex)&#123;
         this.name = uname;
         this.age = age;
         this.sex = sex;
         this.sing = function (sang)&#123;
             console.log(sang)
         &#125;
     &#125;
     var ldh = new Star(&#39;刘德华&#39;, 18, &#39;男&#39;);
     console.log(typeof ldh);
     console.log(ldh.name);
     console.log(ldh.sex);
     ldh.sing(&#39;冰雨&#39;);
     var zxy = new Star(&#39;张学友&#39;, 19, &#39;男&#39;);
     console.log(zxy.name);
     zxy.sing(&#39;吻别&#39;);
  &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>细节：</p>
<p>构造函数名字首字母要大写</p>
<p>==构造函数不需要return就可以返回结果==</p>
<p>调用构造函数，必须使用new</p>
<p>构造函数和对象区别：</p>
<p>构造函数是泛指的某一大类，它类似于java语言里的类</p>
<p>对象是一个具体的事物</p>
<p>遍历对象</p>
<pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;title&lt;/title&gt;
  &lt;script&gt;
     var obj = &#123;
         name: &#39;杰克船长&#39;,
         age: 18,
         sex: &#39;男&#39;
     &#125;

     for (var k in obj)&#123;
         console.log(k);    // 输入k，输出的是属性名
         console.log(obj[k]);   //obj[k], 得到的是属性值
     &#125;
  &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h1 id="14-内置对象"><a href="#14-内置对象" class="headerlink" title="14. 内置对象"></a>14. 内置对象</h1><p>JavaScript的对象分为3种：自定义对象、内置对象、浏览器对象</p>
<p>前面两种对象是JS基础内容，属于ECMAScript；第三个浏览器对象属于我们JS独有的</p>
<p>内置对象就是指JS语言自带的一些对象，这些对象供开发者使用，并提供了一些常用的或是最基本而必要的功能（属性和方法）</p>
<p>MDN：</p>
<p>Mozilla开发者网络提供了有关开放网络技术的信息，包括HTML、CSS和万维网以及HTML5应用的API</p>
<p><a href="https://developer.mozilla.org/zh-CN/">MDN</a></p>
<h2 id="Math对象"><a href="#Math对象" class="headerlink" title="Math对象"></a>Math对象</h2><pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;title&lt;/title&gt;
  &lt;script&gt;
      console.log(Math.floor(5.1)); //向下取整, 5
      console.log(Math.ceil(5.1));  //向上取整, 6
      console.log(Math.round(-3.1));    //就近取整, -3
      console.log(Math.round(-3.5));    //搞个坐标轴从左到右看, -3
      console.log(Math.round(5.5));     //6
      console.log(Math.abs(-2.3));      //2.3
      console.log(Math.random());
      function getRandomIntInclusive(min, max) &#123;
          min = Math.ceil(min);
          max = Math.floor(max);
          return Math.floor(Math.random() * (max - min + 1) + min);
      &#125;

      console.log(getRandomIntInclusive(1, 10));
  &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h2 id="日期对象"><a href="#日期对象" class="headerlink" title="日期对象"></a>日期对象</h2><p>Date日期对象是一个构造函数，必须使用new来调用创建我们的日期对象</p>
<pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;title&lt;/title&gt;
  &lt;script&gt;
     var date = new Date();
     console.log(date);
     var date1 = new Date(1999,1,11); //返回的月份会比输入的多1个月，0-11开始进行计算
     console.log(date1);
     var date2 = new Date(&#39;1998-11-24 22:11:34&#39;);
     console.log(date2);
  &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;title&lt;/title&gt;
  &lt;script&gt;
     var date = new Date();
     console.log(date.getFullYear());
     console.log(date.getMonth() + 1);
     console.log(date.getDate());
     console.log(date.getDay()); //周一返回的是1 周六返回的是6，但是周日返回的是0
  &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>时间戳（指距离1970年1月1号00:00过去的毫秒数）</p>
<p>==var date = +new Date(); 可以直接获取时间戳==</p>
<p>其他方法不再赘述，查阅MDN文档即可</p>
<pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;title&lt;/title&gt;
  &lt;script&gt;
     function conutDown(time) &#123;
         var inputTime = +new Date(time);
         var nowTime = Date.now();
         var times = (inputTime - nowTime) / 1000;
         var d = parseInt( times / 60 / 60 / 24);
         d = d &lt; 10 ? &#39;0&#39; + d : d;
         var h = parseInt(times / 60 / 60 % 24);
         h = h &lt; 10 ? &#39;0&#39; + h : h;
         var m = parseInt(times / 60 % 60);
         m = m &lt; 10 ? &#39;0&#39; + m : m;
         var s = parseInt(times % 60);
         s = s &lt; 10 ? &#39;0&#39; + s : s;
         return d + &#39;天&#39; + h + &#39;时&#39; + m + &#39;分&#39; + s + &#39;秒&#39;;
     &#125;

     console.log(conutDown(&#39;2021-6-7 21:00:00&#39;));
  &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h2 id="数组对象"><a href="#数组对象" class="headerlink" title="数组对象"></a>数组对象</h2><p>push: 尾插 pop: 尾删     unshift: 头插 shift: 头删</p>
<p>sort:排序 reverse: 翻转</p>
<p>==升序降序的写法：==</p>
<pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;title&lt;/title&gt;
  &lt;script&gt;
    var arr1 = [13, 4, 77, 1, 7];
    var arr2 = [13, 3, 77, 7, 1];
    arr1.sort(function (a, b) &#123;//仿函数,升序
        return a - b;
    &#125;);
    arr2.sort(function (a, b) &#123;//仿函数,降序
        return b -a;
    &#125;)
    console.log(arr1);
    console.log(arr2);
  &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>数组去重</p>
<pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;title&lt;/title&gt;
  &lt;script&gt;
    function unique(arr) &#123;//利用indexOf去判断
        var arr1 = [];
        for (var i = 0; i &lt; arr.length; i++) &#123;
            if (arr1.indexOf(arr[i]) == -1)&#123;
                arr1.push(arr[i]);
            &#125;
        &#125;
        return arr1;
    &#125;
    var arr = unique([1, 2, 3, 5, 1, 2, 2, 7 ,8 ,9]);
    console.log(arr);
  &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>数组转换成字符串</p>
<pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;title&lt;/title&gt;
  &lt;script&gt;
      //1.第一种方法
      var arr = [1, 2, 3];
      console.log(arr.toString());
      //2第二种方法,使用join,可以自己指定分隔符
      console.log(arr.join(&#39;-&#39;));
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h1 id="15-基本包装类型"><a href="#15-基本包装类型" class="headerlink" title="15. 基本包装类型"></a>15. 基本包装类型</h1><pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;title&lt;/title&gt;
  &lt;script&gt;
     var str = &#39;andy&#39;;
     console.log(str.length); //4
     //对象才有属性和方法， 复杂的数据类型才有属性和方法
     //简单数据类型会具有length属性，是因为简单数据类型被包装成了复杂数据类型
     //步骤如下：
     var temp = new String(&#39;andy&#39;);
     //临时变量复制给str
     str = temp;
     //销毁临时变量
     temp = null;
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h1 id="16-字符串的不可变性"><a href="#16-字符串的不可变性" class="headerlink" title="16. 字符串的不可变性"></a>16. 字符串的不可变性</h1><p>字符串不可变性是指里面的值不可变，虽然看上去内容改变了，但其实是地址变了，内存中新开辟了一个内存空间，所以大量使用字符串拼接会出现效率问题。</p>
<p>根据字符返回位置：</p>
<pre><code class="lang-javascript">var str = &#39;春天来了，这是春天的气息&#39;;
console.log(str.indexOf(&#39;春&#39;));
console.log(str.indexOf(&#39;春&#39;, 3));    //从索引号是3的位置开始往后查找
</code></pre>
<pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;title&lt;/title&gt;
    &lt;script&gt;
        var arr = [&#39;red&#39;, &#39;blue&#39;, &#39;red&#39;, &#39;green&#39;, &#39;pink&#39;, &#39;red&#39;];
        var index = arr.indexOf(&#39;red&#39;);
        // console.log(arr.indexOf(&#39;red&#39;));
        var num = 0;
        while (index != -1) &#123;
            console.log(index);
            num++;
            index = arr.indexOf(&#39;red&#39;, index + 1);
        &#125;
        console.log(&#39;red出现的次数为：&#39; + num);
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>根据位置返回字符：</p>
<ol>
<li>charAt(index);    返回指定位置的字符</li>
</ol>
<pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;title&lt;/title&gt;
    &lt;script&gt;
        var str = &#39;andy&#39;;
        for (var i = 0; i &lt; str.length; i++) &#123;
            console.log(str.charAt(i));
        &#125;
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>2.charCodeAt(index)    返回指定位置处的ASCII码,用于判断用户按下了哪个键</p>
<pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;title&lt;/title&gt;
    &lt;script&gt;
        var str = &#39;andy&#39;;
        for (var i = 0; i &lt; str.length; i++) &#123;
            console.log(str.charCodeAt(i));
        &#125;
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>3.str[index];    获取指定位置处字符,H5新增的写法</p>
<pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;title&lt;/title&gt;
    &lt;script&gt;
        var str = &#39;andy&#39;;
        for (var i = 0; i &lt; str.length; i++) &#123;
            console.log(str[i]);
        &#125;
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;title&lt;/title&gt;
    &lt;script&gt;
       var o = &#123;
           age: 18
       &#125;
       if (o[&#39;age&#39;]) &#123;//判断类里是否有该属性
           console.log(&#39;里面有该属性&#39;);
       &#125;else &#123;
           console.log(&#39;没有该属性&#39;);
       &#125;
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;title&lt;/title&gt;
    &lt;script&gt;
      //统计出现次数最多的字符
      var str = &#39;abcoefoxyozzopp&#39;;
      var o = &#123;&#125;;
      for (var i = 0; i &lt; str.length; i++) &#123;
          var val = str[i];
          if (o[val]) &#123;
              o[val]++;
          &#125;else &#123;
              o[val] = 1;
          &#125;
      &#125;
      console.log(o)
      //2. 遍历对象
        var max = 0;
        var ch = &#39;&#39;;
        for (var k in o) &#123;
            if (o[k] &gt; max)&#123;
                max = o[k];
                ch = k;
            &#125;
        &#125;
        console.log(max);
        console.log(ch);
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>字符串操作方法</p>
<p>1.concat(‘字符串1’，’字符串2’);  等效于+, +更常用</p>
<p>2.substr(start, length);    从start位置开始，length取的个数</p>
<p>3.slice(start, end);    从start位置开始，截取到end位置，end取不到</p>
<p>4.substring(start, end);    从start位置开始，截取到end位置，end取不到，基本和slice相同，但是不接受负值</p>
<p>5.替换字符 replace(‘被替换的字符’, ‘替换为的字符’);   它只会替换第一个字符</p>
<p>6.字符转换为数组 split(‘分隔符’);</p>
<pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;title&lt;/title&gt;
    &lt;script&gt;
        var str = &#39;red&#39;;
        console.log(str.concat(&#39;blue&#39;));

        var str1 = &#39;改革春风吹满地&#39;;
        console.log(str1.substr(2, 2)); //第一个2是索引号，第二个2是截取的数量

        var str2 = &#39;andyandy&#39;;
        console.log(str2.replace(&#39;a&#39;, &#39;b&#39;));    //它只会替换第一个字母
        //利用循环可以全部替换
        var str3 = &#39;abcoefoxyozzopp&#39;;
        while (str3.indexOf(&#39;o&#39;) != -1)&#123;//替换后不断复制给自己，继续进行替换
            str3 = str3.replace(&#39;o&#39;, &#39;*&#39;);
        &#125;
        console.log(str3);
        var str4 = &#39;red, pink, blue&#39;;   //字符串转换为数组，前面有join把数组转换为字符串
        console.log(str4.split(&#39;,&#39;));
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h1 id="17-数据类型分配"><a href="#17-数据类型分配" class="headerlink" title="17. 数据类型分配"></a>17. 数据类型分配</h1><p>简单数据类型里有一个是特殊的，就是null,他是一个空对象，在当初设计的时候写错了，后来都使用了，也就这样规定了,一般初始化对象时使用</p>
<pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;title&lt;/title&gt;
    &lt;script&gt;
        var num = null;
        console.log(typeof num);    //返回的是Object
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>堆和栈</p>
<p>1、栈：由操作系统自动分配释放存放函数的参数值、局部变量的值等。</p>
<p>2、堆：存储复杂类型（对象），一般由程序员分配释放，若程序员不释放，由垃圾回收器机制回收</p>
<p>引用类型（复杂数据类型）：通过new关键字创建的对象，如Object、Array、Date等</p>
<p>引用类型变量里（栈空间）里存放的是地址，真正的对象实例存放在堆空间中</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>C++知识点</title>
    <url>/2021/06/21/C++/Visual%20Studio%E6%B7%BB%E5%8A%A0%E5%BA%93/</url>
    <content><![CDATA[<p>为了==能够识别头文件和dll文件==，需要将文件目录位置放入系统变量里</p>
<p>项目属性-》VC++Directions里Include Directions里加入==库所在文件夹==以及==头文件所在文件夹== </p>
<p>项目属性-》VC++Directions里Library Directions里加入存放==lib文件夹目录==：</p>
<p>项目属性-》VC++Directions里Library Directions里加入存放==lib文件夹目录==：</p>
<p>项目属性-》Linker-》Input里加入==lib文件的名称==：</p>
<p>lib和dll简介:</p>
<p>(1)lib是编译时需要的，dll是运行时需要的。<br>如果要完成源代码的编译，有lib就够了。<br>如果也使动态连接的程序运行起来，有dll就够了。<br>在开发和调试阶段，当然最好都有。<br>(2)一般的动态库程序有lib文件和dll文件。lib文件是必须在编译期就连接到应用程序中的，而dll文件是运行期才会被调用的。如果有dll文件，那么对应的lib文件一般是一些索引信息，具体的实现在dll文件中。如果只有lib文件，那么这个lib文件是静态编译出来的，索引和实现都在其中。静态编译的lib文件有好处：给用户安装时就不需要再挂动态库了。但也有缺点，就是导致应用程序比较大，而且失去了动态库的灵活性，在版本升级时，同时要发布新的应用程序才行。<br>(3)在动态库的情况下，有两个文件，一个是引入库（.LIB）文件，一个是DLL文件，引入库文件包含被DLL导出的函数的名称和位置，DLL包含实际的函数和数据，应用程序使用LIB文件链接到所需要使用的DLL文件，库中的函数和数据并不复制到可执行文件中，因此在应用程序的可执行文件中，存放的不是被调用的函数代码，而是DLL中所要调用的函数的内存地址，这样当一个或多个应用程序运行是再把程序代码和被调用的函数代码链接起来，从而节省了内存资源。从上面的说明可以看出，DLL和.LIB文件必须随应用程序一起发行，否则应用程序将会产生错误。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
</search>
