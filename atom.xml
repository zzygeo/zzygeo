<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>立志做个全栈</title>
  
  
  <link href="https://zzygeo.cn/atom.xml" rel="self"/>
  
  <link href="https://zzygeo.cn/"/>
  <updated>2021-09-04T15:44:34.201Z</updated>
  <id>https://zzygeo.cn/</id>
  
  <author>
    <name>Regular</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JS细节</title>
    <link href="https://zzygeo.cn/2021/08/25/%E5%89%8D%E7%AB%AF/JS%E7%BB%86%E8%8A%82/"/>
    <id>https://zzygeo.cn/2021/08/25/%E5%89%8D%E7%AB%AF/JS%E7%BB%86%E8%8A%82/</id>
    <published>2021-08-25T01:45:30.000Z</published>
    <updated>2021-09-04T15:44:34.201Z</updated>
    
    <content type="html"><![CDATA[<h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><p>删除对象中的属性 delete obj.name</p><p>对象的属性名不强制要求遵守标识符的规范，但尽量按照规范使用</p><p>基本数据类型</p><p>String、Number、Boolean、Null、Undefined,存储在栈内存中</p><p>引用数据类型</p><p>Object、它是存储在堆内存中,将一个变量设置为null会断开其指针指向</p><p>基本数据类型比较值，引用数据类型比较地址</p><h2 id="对象字面量"><a href="#对象字面量" class="headerlink" title="对象字面量"></a>对象字面量</h2><pre><code>var obj = &#123;&#125;;var obj2 = &#123;    name:&quot;猪八戒&quot;,    age:18&#125;</code></pre><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>如果return语句后不跟任何值就相当于返回一个undefined，如果函数中不写return,则也会返回undefined</p><p>立即执行函数</p><pre><code>(function(a,b,c)&#123;      console.log(a+b+c);    &#125;)(1,2,3)</code></pre><h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><p>回调函数：由我们自己创建，但是不由我们调用的，称为回调函数</p><h3 id="函数方法call，apply"><a href="#函数方法call，apply" class="headerlink" title="函数方法call，apply"></a>函数方法call，apply</h3><p>函数方法call()、apply(),调用时传入参数，可以改变函数的this指向, call()方法可以将实参在对象之后依次传递，apply()方法需要将实参封装到一个数组中统一传递</p><h3 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h3><p>arguments是一个类数组对象，它也可以通过索引来操作数据，也可以获取长短，在调用函数时，我们所传递的实参都会在arguments中保存</p><h2 id="for-in"><a href="#for-in" class="headerlink" title="for in"></a>for in</h2><pre><code>var obj = &#123;      name:&#39;张三&#39;,      age:18,      gender:&#39;男&#39;    &#125;    for (a in obj)&#123;      console.log(a);      console.log(obj[a]);    &#125;</code></pre><h2 id="in以及hasOwnProperty"><a href="#in以及hasOwnProperty" class="headerlink" title="in以及hasOwnProperty"></a>in以及hasOwnProperty</h2><pre><code>//使用in检查对象中是否含有某个属性时，如果对象中没有但是原型中有，也会返回true    console.log(&quot;name&quot; in mc);    //hasOwnProperty是检查自身有没有这个属性的方法    console.log(mc.hasOwnProperty(&quot;name&quot;));</code></pre><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p>当一个对象不在使用以后，将其设置为null，断开与堆内存的连接，这样垃圾回收机制才会运行</p><h1 id="内建对象"><a href="#内建对象" class="headerlink" title="内建对象"></a>内建对象</h1><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组的存储性能比普通对象要好，在开发中经常使用</p><p>方法：</p><p>arr.join(“-“) arr.join方法可以把数组转成字符串。其中传入的参数是分隔符<br>arr.sort()方法默认会按照Unicode进行排序，在设计到数字的排序时，可能会出现错误，需要自己制定规则排序</p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>fromCharAt()</p><pre><code>var result = String.fromCharCode(72);    console.log(result);</code></pre><h1 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h1><p>DOM操作主要还是寻找相关的API方法，逻辑上不难，主要理解Element、Node、Document的相互关系。</p><p>我们想要操作网页的元素，则必须可以访问到这个元素，html这种树形的结构，我们只要先拿到其文档对象，就可以采用相应的方法对其进行操作。</p><p>浏览器已经为我们提供了文档节点对象，这个对象是winodw属性，可以在页面中直接使用，文档节点代表的是整个网页。</p><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>事件就是用户和浏览器之间的交互行为</p><h2 id="浏览器页面的加载顺序"><a href="#浏览器页面的加载顺序" class="headerlink" title="浏览器页面的加载顺序"></a>浏览器页面的加载顺序</h2><p>浏览器在加载一个页面时，是按照自上向下的顺序加载的，将js代码编写到页面的下部就是为了可以在页面加载完毕以后再执行js代码</p><p>如果想把js代码写在上面，可以给window绑定一个onload事件，该事件对应的响应函数将会在页面加载完成后执行</p><h2 id="事件绑定，获取节点元素"><a href="#事件绑定，获取节点元素" class="headerlink" title="事件绑定，获取节点元素"></a>事件绑定，获取节点元素</h2><p>如果需要读取元素节点属性，直接使用元素.属性名，但class属性不能采用这种方法，读取class属性时需要使用.className</p><pre><code class="lang-html">//获取body标签    var body = document.body;    console.log(body);    //获取Html标签    var html = document.documentElement;    console.log(html);    //document.all代表页面中的所有元素    var all = document.all;    console.log(all.length);    //参数为css选择器，可以查询到对应的元素,但是它只会返回一个元素    var div = document.querySelector(&quot;.box1 div&quot;)    //返回多个元素，以数组形式返回,即使符合条件的元素只有一个，它也会返回数组    var div = document.querySelectorAll(&quot;.box1&quot;)</code></pre><h2 id="Dom练习"><a href="#Dom练习" class="headerlink" title="Dom练习"></a>Dom练习</h2><pre><code class="lang-html">&lt;form action=&quot;&quot;&gt;    你爱好的运动是?&lt;input type=&quot;checkbox&quot; id=&quot;checkedAllBox&quot;&gt; 全选/全不选    &lt;br&gt;    &lt;input type=&quot;checkbox&quot; name=&quot;items&quot; value=&quot;足球&quot;&gt;足球    &lt;input type=&quot;checkbox&quot; name=&quot;items&quot; value=&quot;篮球&quot;&gt;篮球    &lt;input type=&quot;checkbox&quot; name=&quot;items&quot; value=&quot;羽毛球&quot;&gt;羽毛球    &lt;input type=&quot;checkbox&quot; name=&quot;items&quot; value=&quot;兵乓球&quot;&gt;兵乓球    &lt;br&gt;    &lt;input type=&quot;button&quot; id=&quot;checkedAllBtn&quot; value=&quot;全选&quot;&gt;    &lt;input type=&quot;button&quot; id=&quot;checkedNoBtn&quot; value=&quot;全不选&quot;&gt;    &lt;input type=&quot;button&quot; id=&quot;checkedRevBtn&quot; value=&quot;反选&quot;&gt;    &lt;input type=&quot;button&quot; id=&quot;sendBtn&quot; value=&quot;提交&quot;&gt;  &lt;/form&gt;  &lt;script&gt;    var checkedAllBtn = document.getElementById(&quot;checkedAllBtn&quot;)    var items = document.getElementsByName(&quot;items&quot;)    checkedAllBtn.onclick = () =&gt; &#123;      items.forEach((value) =&gt; &#123;        value.checked = true      &#125;)    &#125;    var checkedNoBtn = document.getElementById(&quot;checkedNoBtn&quot;)    checkedNoBtn.onclick = () =&gt; &#123;      items.forEach((value) =&gt; &#123;        value.checked = false      &#125;)    &#125;    var checkedRevBtn = document.getElementById(&quot;checkedRevBtn&quot;)    checkedRevBtn.onclick = () =&gt; &#123;      items.forEach((value) =&gt; &#123;        value.checked = !value.checked      &#125;)    &#125;    var sendBtn = document.getElementById(&quot;sendBtn&quot;)    sendBtn.onclick = () =&gt; &#123;      items.forEach((event) =&gt; &#123;       if (event.checked === true) &#123;          console.log(event.value);       &#125;      &#125;)    &#125;    var checkedAllBox = document.getElementById(&quot;checkedAllBox&quot;)    checkedAllBox.onclick = () =&gt; &#123;      items.forEach((event) =&gt; &#123;        event.checked = checkedAllBox.checked      &#125;)    &#125;    var num = 0    items.forEach((event) =&gt; &#123;      event.onclick = () =&gt; &#123;        checkedAllBox.checked = true        if (!event.checked) &#123;          checkedAllBox.checked = false        &#125;      &#125;    &#125;)  &lt;/script&gt;</code></pre><h2 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h2><pre><code class="lang-html">&lt;ul id=&quot;city&quot;&gt;    &lt;li&gt;上海&lt;/li&gt;    &lt;li&gt;深圳&lt;/li&gt;    &lt;li&gt;武汉&lt;/li&gt;    &lt;li id=&quot;bj&quot;&gt;北京&lt;/li&gt;  &lt;/ul&gt;  &lt;button id=&quot;addCity&quot;&gt;点我添加&lt;/button&gt;  &lt;button id=&quot;deleteCity&quot;&gt;点我删除&lt;/button&gt;  &lt;script&gt;    function myClick(idStr, fun) &#123;      var ele = document.getElementById(idStr)      ele.onclick = fun    &#125;    myClick(&quot;addCity&quot;,() =&gt; &#123;    //获取父元素节点    var city = document.getElementById(&quot;city&quot;);    //创建子元素节点    var li = document.createElement(&quot;li&quot;);    //添加内容    li.innerHTML = &quot;广州&quot;;    //将子元素追加进去    city.appendChild(li)    &#125;)    myClick(&quot;deleteCity&quot;, () =&gt; &#123;      var bj = document.getElementById(&quot;bj&quot;)      //这种方式来进行删除      bj.parentNode.removeChild(bj)    &#125;)  &lt;/script&gt;</code></pre><h2 id="DOM操作css"><a href="#DOM操作css" class="headerlink" title="DOM操作css"></a>DOM操作css</h2><p>拿到element以后直接element.style.height =”300px”修改，在遇见background-color这种时，需要采用驼峰命名backgroundColor，这种设置都是设置的内联样式，有着较高的优先级，在用这种方法进行读取时，也是读的内联样式，因此可能会读取不到样式表中的样式。</p><h1 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h1><p><img src="https://raw.githubusercontent.com/zzygeo/images/master/js运算符优先级.4dxtiok15my0.png" alt="js运算符优先级"></p><h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><p>JS中一共有两种作用域<br>全局作用域：</p><ul><li>直接写到script标签中的JS代码，都在全局作用域</li><li>全局作用域在页面打开时创建，在页面关闭时销毁</li><li>在全局作用域中有一个全局对象window，我们可以直接使用，他代表我们浏览器的窗口</li><li>在全局作用域中，创建的变量都会作为window对象的属性保存</li><li>创建的方法都会作为window对象的方法保存</li></ul><p>函数作用域</p><ul><li>调用函数时创建函数作用域，函数执行完毕以后，函数作用域销毁</li><li>每调用一次函数就会创建一个新的函数作用域，他们之间是相互独立的</li><li>在函数作用域中可以访问到全局作用域的变量</li><li>访问时遵循就近一致原则</li></ul><h2 id="声明提前"><a href="#声明提前" class="headerlink" title="声明提前"></a>声明提前</h2><p>使用var关键字声明的变量，会在所有的代码执行之前被声明</p><pre><code>    //var a;在执行时会先执行这个    console.log(a);    var a = 18</code></pre><p>函数声明提前</p><p>使用函数声明形式创建的函数function 函数(){},它会在所有的代码执行之前就被创建</p><p>使用函数表达式创建的函数，不会被声明提前，所以不能在声明前被调用</p><pre><code>sum1();//3console.log(sum2);//undefinedvar sum2 = function() &#123;    return 2 + 3;&#125;function sum1() &#123;    return 1 + 2;&#125;</code></pre><p>在函数作用域也有声明提前的特性，可以理解为一个小的全局作用域</p><p>没有使用var声明的变量，在方法内部或外部都是全局变量，但如果是在方法内部声明，在方法外部使用之前需要先调用方法，告知系统声明了全局变量后方可在方法外部使用</p><pre><code>function a() &#123;      b = 10    &#125;a()//需要先调用console.log(b);</code></pre><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>解析器在调用函数每次都会向函数内部传递一个隐含的参数，这个隐含的参数就是this</p><p>根据函数的调用方式的不同，this会指向不同的对象</p><p>以函数的形式调用时，this永远指向的都是window</p><p>以方法的形式调用时，this指向的就是调用该方法的对象</p><p> 当以构造函数的形式调用时，this就是新创建的那个对象</p><h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><p>构造函数的执行流程</p><ol><li>立即创建一个对象</li><li>将新建的对象设置为函数中的this</li><li>执行函数中的代码</li><li>将新建的对象作为返回值返回</li></ol><p>所有的对象都是Object的子类</p><h1 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h1><p>原型prototype，我们所创建的每一个函数，解析器都会向函数中添加一个属性prototype，这里存的地址指向这个原型对象</p><p>如果函数作为普通函数调用prototype没有任何作用，当函数通过构造函数调用时，它所创建的对象中都会有一个隐含的属性指向该构造函数的原型对象，可以通过<strong>proto</strong>来访问，原型对象就相当于一个公共的区域，所有同一个类的实例都可以访问到这个原型对象，我们可以将对象中共有的内容，统一设置到原型对象中</p><p>当我们访问对象的一个属性或方法时，它会先在对象自身中寻找，如果有则直接使用，如果没有则会去原型对象中寻找，如果找到则直接使用</p><pre><code>function Person(name, age, gender)&#123;      this.name = name;      this.age = age;      this.gender = gender      console.log(this);    &#125;    var p = new Person(&#39;猪八戒&#39;, 28, &#39;男&#39;);    console.log(Person.prototype);    console.log(p.__proto__);    console.log(Person.prototype == p.__proto__);</code></pre><p>可以和java里的static修饰符做比较</p><h1 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h1><p>JS里有基本数据类型 String、Number、Boolean、Null、Undefined</p><p>引用数据类型Object</p><p>在JS中为我们提供了三个包装类，通过这三个包装类可以将基本数据类型的数据转换成对象</p><p>String()、Number()、Boolean()</p><p>细节：</p><p>方法和属性只能添加给对象，不能添加给基本数据类型，当我们对一些基本数据类型的值去调用属性和方法时，浏览器会临时使用包装类将其转换成对象，然后再调用对象的属性和方法</p><pre><code>var s = 123;s = s.toString();console.log(typeof s);</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;对象&quot;&gt;&lt;a href=&quot;#对象&quot; class=&quot;headerlink&quot; title=&quot;对象&quot;&gt;&lt;/a&gt;对象&lt;/h1&gt;&lt;p&gt;删除对象中的属性 delete obj.name&lt;/p&gt;
&lt;p&gt;对象的属性名不强制要求遵守标识符的规范，但尽量按照规范使用&lt;/p&gt;
&lt;p&gt;基</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>css细节</title>
    <link href="https://zzygeo.cn/2021/08/17/%E5%89%8D%E7%AB%AF/css%E7%BB%86%E8%8A%82/"/>
    <id>https://zzygeo.cn/2021/08/17/%E5%89%8D%E7%AB%AF/css%E7%BB%86%E8%8A%82/</id>
    <published>2021-08-17T14:19:03.000Z</published>
    <updated>2021-08-25T01:45:10.527Z</updated>
    
    <content type="html"><![CDATA[<h1 id="div"><a href="#div" class="headerlink" title="div"></a>div</h1><p>div设置100%依赖于父级，back-img要占满整个屏幕设置background-size: cover; background-repeat: no-repeat;</p><p>要固定div的相对位置，使用absolute属性</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;div&quot;&gt;&lt;a href=&quot;#div&quot; class=&quot;headerlink&quot; title=&quot;div&quot;&gt;&lt;/a&gt;div&lt;/h1&gt;&lt;p&gt;div设置100%依赖于父级，back-img要占满整个屏幕设置background-size: cover; background</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>vue学习</title>
    <link href="https://zzygeo.cn/2021/07/24/%E5%89%8D%E7%AB%AF/vue%E5%AD%A6%E4%B9%A0/"/>
    <id>https://zzygeo.cn/2021/07/24/%E5%89%8D%E7%AB%AF/vue%E5%AD%A6%E4%B9%A0/</id>
    <published>2021-07-24T15:24:52.000Z</published>
    <updated>2021-08-17T15:07:41.799Z</updated>
    
    <content type="html"><![CDATA[<h1 id="入门介绍"><a href="#入门介绍" class="headerlink" title="入门介绍"></a>入门介绍</h1><p>Vue是一套用于构建用户界面的渐进式JavaScript框架</p><p>采用组件化模式，提高代码复用率，且让代码更好维护</p><p>传统采用命令式编码，需要编码人员自己DOM，声明式编码可以直接写入</p><p>使用虚拟DOM +优秀的Diff算法，尽量复用DOM节点</p><p>学习Vue之间要掌握的JavaScript基础知识:</p><p>ES6语法规范、ES6模板化、包管理器、原型、原型链、数组常用方法、axios、promise</p><h1 id="vue2细节"><a href="#vue2细节" class="headerlink" title="vue2细节"></a>vue2细节</h1><h2 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h2><p>v-bind可以动态绑定，将Vue和html属性绑定</p><p>v-model可以完成双向绑定,但是v-model只能用在表单类元素上（输入类元素）</p><p>v-on:click简写为@click v-moel:value简写为v-model</p><p>vue参考了MVVM模型，M：model对应data中的数据 V:view模板  VM:viewModer：vue实例对象</p><h2 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h2><pre><code class="lang-html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;  &lt;title&gt;Document&lt;/title&gt;  &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;  &lt;style&gt;    *&#123;      margin-top: 20px;    &#125;    .demo1&#123;      height: 50px;      background-color: blue;    &#125;    .box1&#123;      padding: 5px;      background-color: pink;    &#125;    .box2&#123;      padding: 5;      background-color: orange;    &#125;    .list&#123;      width: 200px;      height: 200px;      background-color: deeppink;      overflow: auto;    &#125;    .list li&#123;      height: 100px;    &#125;  &lt;/style&gt;&lt;/head&gt;&lt;body&gt;  &lt;!--    Vue中的事件修饰符：    1.prevent: 阻止默认事件    2.stop: 阻止事件冒泡    3.once: 事件只触发一次    4.capture: 使用事件的捕获方式    5.self: 只有event.target是当前操作的元素时才触发事件    6.passive: 事件的默认行为立即执行，无需等待事件回调执行完毕  --&gt;  &lt;div id=&quot;root&quot;&gt;    &lt;h2&gt;欢迎来到&#123;&#123;name&#125;&#125;学习&lt;/h2&gt;    &lt;!-- 组织默认事件 --&gt;    &lt;a href=&quot;http://zzygeo.cn&quot; @click.prevent=&quot;showInfo&quot;&gt;点我提示信息&lt;/a&gt;    &lt;!-- 阻止事件冒泡 --&gt;    &lt;div class=&quot;demo1&quot; @click=&quot;showInfo&quot;&gt;      &lt;button @click.stop=&quot;showInfo&quot;&gt;点我提示信息&lt;/button&gt;    &lt;/div&gt;    &lt;!-- 事件只触发一次 --&gt;    &lt;button @click.once=&quot;showInfo&quot;&gt;点我提示信息&lt;/button&gt;    &lt;!-- 使用事件的捕获模式,捕获阶段是由外往内的，冒泡阶段是由内往外的，先捕获再冒泡,capture就是让其    在捕获阶段就执行    --&gt;    &lt;div class=&quot;box1&quot; @click.capture=&quot;showMessage(1)&quot;&gt;      div1      &lt;div class=&quot;box2&quot; @click=&quot;showMessage(2)&quot;&gt;        div2      &lt;/div&gt;    &lt;/div&gt;    &lt;!-- 只有event.target是当前操作的元素时才触发事件,button导致的冒泡不会影响div --&gt;    &lt;div class=&quot;demo1&quot; @click.self=&quot;showInfo&quot;&gt;      &lt;button @click=&quot;showInfo&quot;&gt;点我提示信息&lt;/button&gt;    &lt;/div&gt;    &lt;!-- 事件的默认行为立即执行，无需等待事件回调执行完毕 --&gt;    &lt;ul @wheel.passive=&quot;demo&quot; class=&quot;list&quot;&gt;      &lt;li&gt;1&lt;/li&gt;      &lt;li&gt;2&lt;/li&gt;      &lt;li&gt;3&lt;/li&gt;      &lt;li&gt;4&lt;/li&gt;    &lt;/ul&gt;  &lt;/div&gt;&lt;/body&gt;  &lt;script&gt;    Vue.config.productionTip = false    const vm = new Vue(&#123;      data:function()&#123;        return&#123;          name:&#39;尚硅谷&#39;        &#125;      &#125;,      methods:&#123;        showInfo:function(e)&#123;          // e.preventDefault()          alert(&#39;同学你好&#39;)        &#125;,        showMessage:function(msg)&#123;        console.log(msg);      &#125;,      demo:function()&#123;//先等待回调，然后再执行，这里会浪费大量的时间        for (let index = 0; index &lt; 100000; index++) &#123;          console.log(&#39;#&#39;);        &#125;        console.log(&#39;@&#39;);      &#125;      &#125;    &#125;)    vm.$mount(&#39;#root&#39;)  &lt;/script&gt;&lt;/html&gt;</code></pre><h2 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h2><pre><code class="lang-html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;  &lt;title&gt;Document&lt;/title&gt;  &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;  &lt;!--     1.Vue中常见的按键别名:    回车=&gt;enter    删除=&gt;delete    退出=&gt;esc    空格=&gt;space    换行=&gt;tab（特殊，配合keydown使用）    上=&gt;up    下=&gt;down    左=&gt;left    右=&gt;right    2.Vue未提供别名的按键，可以使用原始的key值去绑定，但注意要转成keytab-case（短横线命名）    3.系统修饰键（用法特殊）：ctrl、alt、shift、meta    1) 配合keyup使用：按下修饰键的同时，再按下其他键，随后释放其他件，时间才被触发    2) 配合keydown使用：正常触发事件    4.系统修饰按键后还可以跟指定按键   --&gt;  &lt;div id=&quot;root&quot;&gt;    &lt;h2&gt;欢迎来到&#123;&#123;name&#125;&#125;来学习&lt;/h2&gt;    &lt;input type=&quot;text&quot; placeholder=&quot;按下回车提示输入&quot; @keyup.ctrl.y=&quot;showInfo&quot;&gt;  &lt;/div&gt;&lt;/body&gt;  &lt;script&gt;    Vue.config.productionTip = false;    // Vue.config.keyCodes.huiche = 13; //也可以自定义按键    const vm = new Vue(&#123;      data:function()&#123;        return&#123;          name:&#39;Vue&#39;        &#125;      &#125;,      methods:&#123;        showInfo:function(e)&#123;//这个e是键盘事件类          // if (e.keyCode !== 13) return //这个可以用enter代替          console.log(e.target.value);        &#125;      &#125;    &#125;);    vm.$mount(&#39;#root&#39;);  &lt;/script&gt;&lt;/html&gt;</code></pre><h2 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h2><pre><code class="lang-html">computed:&#123;    fullName:&#123;    //fullName被读取时，get就会被调用，且返回值就会作为fullName的值    //get什么时候调用 1.初次读取fullName时  2.所依赖的数据发生变化时，这里用了缓存    get:function()&#123;//计算属性   Vue在这里把this指给了vm这个对象        console.log(&#39;set被调用了&#39;);        return this.firstName + &#39;-&#39; + this.lastName;     &#125;,    //set在fullName被修改的时候被调用    set:function(value)&#123;        console.log(&#39;set&#39;, value);        const arr = value.split(&#39;-&#39;);        this.firstName = arr[0];        this.lastName = arr[1];    &#125;&#125;</code></pre><h2 id="监视属性"><a href="#监视属性" class="headerlink" title="监视属性"></a>监视属性</h2><p>在监视对象里的值改变时，默认的浅层监视监测不到数据变化，因此不能重新解析模板，需要开启深度监视deep:true</p><p>watch和computed在改变属性时候的区别</p><p>watch可以进行异步计算，如时间延迟函数</p><h2 id="class与style绑定"><a href="#class与style绑定" class="headerlink" title="class与style绑定"></a>class与style绑定</h2><pre><code class="lang-html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;  &lt;title&gt;Document&lt;/title&gt;  &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;  &lt;style&gt;    .basic&#123;      height: 100px;      width: 200px;      border: 1px solid black;    &#125;    .happy&#123;      border: 4px solid red;      background-color: rgba( 255, 255, 0, 0.644);      background: linear-gradient(30deg, yellow,pink,orange,yellow);    &#125;    .sad&#123;      border: 4px solid green;      background-color: rgba( 255, 255, 0, 0.644);      background: linear-gradient(30deg, yellow,pink,orange,yellow);    &#125;    .normal&#123;      border: 4px solid blue;      background-color: rgba( 255, 255, 0, 0.644);      background: linear-gradient(30deg, yellow,pink,orange,yellow);    &#125;    .color1&#123;      background-color: antiquewhite;    &#125;    .color2&#123;      background-color: aqua;    &#125;    .color3&#123;      background-color: chartreuse;    &#125;  &lt;/style&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=&quot;root&quot;&gt;    &lt;!-- 绑定class样式--字符串写法，适用于：样式的类名不确定，需要动态指定 --&gt;    &lt;div  class=&quot;basic&quot; :class=&quot;mood&quot; @click=&quot;changeMood&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt; &lt;br&gt; &lt;br&gt;    &lt;!-- 绑定class样式--数组写法,适用于：要绑定的样式个数不确定，名字也不确定 --&gt;    &lt;div  class=&quot;basic&quot; :class=&quot;classArr&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt; &lt;br&gt; &lt;br&gt;    &lt;!-- 绑定class样式--对象写法,适用于：要绑定的样式个数确定，名字也确定，但要动态决定用不用 --&gt;    &lt;div  class=&quot;basic&quot; :class=&quot;classObj&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt; &lt;br&gt; &lt;br&gt;    &lt;!-- 绑定style --&gt;    &lt;div  class=&quot;basic&quot; :style=&quot;styleObj&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt;  &lt;/div&gt;&lt;/body&gt;  &lt;script&gt;    Vue.config.productionTip = false;    const vm = new Vue(&#123;      data:function()&#123;        return&#123;          name:&#39;尚硅谷&#39;,          mood:&#39;happy&#39;,          classArr:[&#39;color1&#39;, &#39;color2&#39;, &#39;color3&#39;],          classObj:&#123;            color1:false,            color2:false          &#125;,          styleObj:&#123;            fontSize:&#39;40px&#39;          &#125;        &#125;      &#125;,      methods:&#123;        changeMood()&#123;          var arr = [&#39;happy&#39;, &#39;sad&#39;, &#39;normal&#39;];          var index = Math.floor(Math.random() * 3);          this.mood = arr[index];        &#125;      &#125;    &#125;);    vm.$mount(&#39;#root&#39;)  &lt;/script&gt;&lt;/html&gt;</code></pre><h2 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h2><pre><code class="lang-html">&lt;!-- 使用v-show做条件渲染,隐藏，频率高的情况下使用 --&gt;&lt;h2 v-show=&quot;false&quot;&gt;欢迎来到&#123;&#123;name&#125;&#125;&lt;/h2&gt;&lt;!-- 使用v-if做条件渲染，彻底删除，频率低的情况下使用 --&gt;&lt;h2 v-if=&quot;false&quot;&gt;欢迎来到&#123;&#123;name&#125;&#125;&lt;/h2&gt;&lt;!-- v-else-if与v-else --&gt;&lt;!-- 需要连着写才有效果 --&gt;&lt;h2 v-if=&quot;n === 1&quot;&gt;n=1&lt;/h2&gt;&lt;h2 v-else-if=&quot;n == 2&quot;&gt;n=2&lt;/h2&gt;&lt;h2 v-else-if=&quot;n == 3&quot;&gt;n=3&lt;/h2&gt;&lt;h2 v-else&gt;哈哈&lt;/h2&gt;&lt;button @click=&quot;n++&quot;&gt;点我n+1&lt;/button&gt;&lt;!-- template可以当div盒子用，但在渲染的时候又不影响页面的布局，但它只能配合v-if用 --&gt;</code></pre><h2 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h2><pre><code class="lang-html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;  &lt;title&gt;Document&lt;/title&gt;  &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=&quot;root&quot;&gt;    &lt;!-- 遍历数组 --&gt;    &lt;h2&gt;人员列表&lt;/h2&gt;    &lt;ul&gt;      &lt;!-- p是值，index是索引,给每个li分不同的id --&gt;      &lt;li v-for=&quot;(p,index) in personArr&quot; :key=&quot;index&quot;&gt;        &#123;&#123;p.name&#125;&#125;-&#123;&#123;p.age&#125;&#125;      &lt;/li&gt;    &lt;/ul&gt;    &lt;br&gt;    &lt;!-- 遍历对象 --&gt;    &lt;h2&gt;汽车属性&lt;/h2&gt;    &lt;ul&gt;      &lt;!-- 第一个是val,第二个是key --&gt;      &lt;li v-for=&quot;(val,key) in Car&quot; :key=&quot;key&quot;&gt;        &#123;&#123;key&#125;&#125; - &#123;&#123;val&#125;&#125;      &lt;/li&gt;    &lt;/ul&gt;    &lt;!-- 遍历字符串 --&gt;    &lt;h2&gt;遍历字符串&lt;/h2&gt;    &lt;ul&gt;      &lt;li v-for=&quot;(val,index) in str&quot; :key=&quot;index&quot;&gt;        &#123;&#123;val&#125;&#125;-&#123;&#123;index&#125;&#125;      &lt;/li&gt;    &lt;/ul&gt;    &lt;!-- 遍历数字 --&gt;    &lt;h2&gt;遍历数字&lt;/h2&gt;    &lt;ul&gt;      &lt;li v-for=&quot;(num,index) in 6&quot; :key=&quot;index&quot;&gt;        &#123;&#123;index&#125;&#125;-&#123;&#123;num&#125;&#125;      &lt;/li&gt;    &lt;/ul&gt;  &lt;/div&gt;&lt;/body&gt;  &lt;script&gt;    Vue.config.productionTip = false;    const vm = new Vue(&#123;      data:function()&#123;        return&#123;          personArr:[            &#123;id:&#39;001&#39;, name:&#39;张三&#39;,age:18&#125;,            &#123;id:&#39;002&#39;, name:&#39;李四&#39;,age:18&#125;,            &#123;id:&#39;003&#39;, name:&#39;王五&#39;,age:19&#125;              ],          Car:&#123;            name:&#39;奥迪A8&#39;,            price:&#39;70万&#39;,            color:&#39;黑色&#39;          &#125;,          str:&#39;hello&#39;        &#125;      &#125;    &#125;);    vm.$mount(&#39;#root&#39;)  &lt;/script&gt;&lt;/html&gt;</code></pre><p>key的原理</p><p><img src="https://raw.githubusercontent.com/zzygeo/images/master/index作为key.7fprri03nn40.png" alt="index作为key"></p><p><img src="https://raw.githubusercontent.com/zzygeo/images/master/id作为key.79a32p8aifk0.png" alt="id作为key"></p><pre><code class="lang-html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;  &lt;title&gt;Document&lt;/title&gt;  &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=&quot;root&quot;&gt;    &lt;!--       虚拟DOM发生改变会存在对比算法，虚拟DOM中内容没变，直接使用之间的真实DOM      若虚拟DOM中内容变了，则生成新的真实DOM，随后替换掉页面中之前的真实DOM      所以对数据不进行逆序添加、逆序删除等操作的时候，使用index作为key是可以的，      一般最好使用每条数据的唯一标识作为key     --&gt;    &lt;!-- 遍历数组 --&gt;    &lt;h2&gt;人员列表&lt;/h2&gt;    &lt;button @click=&quot;add&quot;&gt;点击&lt;/button&gt;    &lt;ul&gt;      &lt;li v-for=&quot;(p,index) in personArr&quot; :key=&quot;index&quot;&gt;        &#123;&#123;p.name&#125;&#125;-&#123;&#123;p.age&#125;&#125;&lt;input type=&quot;text&quot;&gt;      &lt;/li&gt;    &lt;/ul&gt;  &lt;/div&gt;&lt;/body&gt;  &lt;script&gt;    Vue.config.productionTip = false;    const vm = new Vue(&#123;      data:function()&#123;        return&#123;          personArr:[            &#123;id:&#39;001&#39;, name:&#39;张三&#39;,age:18&#125;,            &#123;id:&#39;002&#39;, name:&#39;李四&#39;,age:18&#125;,            &#123;id:&#39;003&#39;, name:&#39;王五&#39;,age:19&#125;              ]        &#125;      &#125;,      methods:&#123;        add()&#123;          const  p = &#123;id:&quot;004&quot;, name:&quot;老刘&quot;,age:30&#125;;          this.personArr.unshift(p);        &#125;      &#125;    &#125;);    vm.$mount(&#39;#root&#39;)  &lt;/script&gt;&lt;/html&gt;</code></pre><p>列表过滤：</p><pre><code class="lang-html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;  &lt;title&gt;Document&lt;/title&gt;  &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;  &lt;!-- watch实现 --&gt;  &lt;!-- &lt;div id=&quot;root&quot;&gt;    &lt;h2&gt;人员列表&lt;/h2&gt;    &lt;input type=&quot;text&quot; placeholder=&quot;请输入名字&quot; v-model=&quot;keyWord&quot;&gt;    &lt;ul&gt;      &lt;li v-for=&quot;(p, index) in filPersonArr&quot; :key=&quot;p.id&quot;&gt;        &#123;&#123;p.name&#125;&#125;-&#123;&#123;p.age&#125;&#125;-&#123;&#123;p.sex&#125;&#125;      &lt;/li&gt;    &lt;/ul&gt;  &lt;/div&gt;&lt;/body&gt;  &lt;script&gt;    Vue.config.productionTip = false;    const vm = new Vue(&#123;      data:function()&#123;        return&#123;          personArr:[            &#123;name:&#39;马冬梅&#39;, age:19, sex:&#39;女&#39;,id:&#39;001&#39;&#125;,            &#123;name:&#39;周冬雨&#39;, age:20, sex:&#39;女&#39;,id:&#39;002&#39;&#125;,            &#123;name:&#39;周杰伦&#39;, age:21, sex:&#39;男&#39;,id:&#39;003&#39;&#125;,            &#123;name:&#39;温兆伦&#39;, age:22, sex:&#39;男&#39;,id:&#39;004&#39;&#125;          ],          keyWord:&#39;&#39;,          filPersonArr:[]        &#125;      &#125;,      watch:&#123;        keyWord:&#123;          immediate:true,          handler(newVal)&#123;            this.filPersonArr = this.personArr.filter((p)=&gt;&#123;            return p.name.indexOf(newVal) &gt; -1;            &#125;)        &#125;            &#125;      &#125;    &#125;);    vm.$mount(&#39;#root&#39;) --&gt;    &lt;!-- computed实现 --&gt;    &lt;div id=&quot;root&quot;&gt;      &lt;h2&gt;人员列表&lt;/h2&gt;      &lt;input type=&quot;text&quot; placeholder=&quot;请输入名字&quot; v-model=&quot;keyWord&quot;&gt;      &lt;ul&gt;        &lt;li v-for=&quot;(p, index) in filPersonArr&quot; :key=&quot;p.id&quot;&gt;          &#123;&#123;p.name&#125;&#125;-&#123;&#123;p.age&#125;&#125;-&#123;&#123;p.sex&#125;&#125;        &lt;/li&gt;      &lt;/ul&gt;    &lt;/div&gt;  &lt;/body&gt;    &lt;script&gt;      Vue.config.productionTip = false;      const vm = new Vue(&#123;        data:function()&#123;          return&#123;            personArr:[              &#123;name:&#39;马冬梅&#39;, age:19, sex:&#39;女&#39;,id:&#39;001&#39;&#125;,              &#123;name:&#39;周冬雨&#39;, age:20, sex:&#39;女&#39;,id:&#39;002&#39;&#125;,              &#123;name:&#39;周杰伦&#39;, age:21, sex:&#39;男&#39;,id:&#39;003&#39;&#125;,              &#123;name:&#39;温兆伦&#39;, age:22, sex:&#39;男&#39;,id:&#39;004&#39;&#125;            ],            keyWord:&#39;&#39;          &#125;        &#125;,        computed:&#123;          filPersonArr:&#123;            get()&#123;              return this.personArr.filter((p)=&gt;&#123;                return p.name.indexOf(this.keyWord) &gt; -1;              &#125;)            &#125;          &#125;        &#125;      &#125;);      vm.$mount(&#39;#root&#39;)  &lt;/script&gt;&lt;/html&gt;</code></pre><p>列表排序</p><pre><code class="lang-html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;  &lt;title&gt;Document&lt;/title&gt;  &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=&quot;root&quot;&gt;    &lt;h2&gt;人员列表&lt;/h2&gt;    &lt;input type=&quot;text&quot; placeholder=&quot;请输入名字&quot; v-model=&quot;keyWord&quot;&gt;    &lt;button @click=&quot;order=1&quot;&gt;年龄升序&lt;/button&gt;    &lt;button @click=&quot;order=2&quot;&gt;年龄降序&lt;/button&gt;    &lt;button @click=&quot;order=0&quot;&gt;原顺序&lt;/button&gt;    &lt;ul&gt;      &lt;li v-for=&quot;(p, index) in filPersonArr&quot; :key=&quot;p.id&quot;&gt;        &#123;&#123;p.name&#125;&#125;-&#123;&#123;p.age&#125;&#125;-&#123;&#123;p.sex&#125;&#125;      &lt;/li&gt;    &lt;/ul&gt;  &lt;/div&gt;&lt;/body&gt;  &lt;script&gt;    Vue.config.productionTip = false;    const vm = new Vue(&#123;      data:function()&#123;        return&#123;          personArr:[            &#123;name:&#39;马冬梅&#39;, age:19, sex:&#39;女&#39;,id:&#39;001&#39;&#125;,            &#123;name:&#39;周冬雨&#39;, age:21, sex:&#39;女&#39;,id:&#39;002&#39;&#125;,            &#123;name:&#39;周杰伦&#39;, age:20, sex:&#39;男&#39;,id:&#39;003&#39;&#125;,            &#123;name:&#39;温兆伦&#39;, age:22, sex:&#39;男&#39;,id:&#39;004&#39;&#125;          ],          keyWord:&#39;&#39;,          order:0        &#125;      &#125;,      computed:&#123;        filPersonArr:&#123;          get()&#123;            const arr = this.personArr.filter((p)=&gt;&#123;              return p.name.indexOf(this.keyWord) &gt; -1;            &#125;)            if (this.order)&#123;              arr.sort((a, b)=&gt;&#123;                return this.order === 1 ? a.age - b.age : b.age - a.age;              &#125;)            &#125;            return arr;          &#125;        &#125;      &#125;,    &#125;);    vm.$mount(&#39;#root&#39;)&lt;/script&gt;&lt;/html&gt;</code></pre><h2 id="Vue监测对象以及数组"><a href="#Vue监测对象以及数组" class="headerlink" title="Vue监测对象以及数组"></a>Vue监测对象以及数组</h2><p>Vue是通过一个递归给data里面的数据增加set和get方法，想给Vue添加一个reactive属性,可以调用Vue.set或者vm.$set，但给Vue添加reactive属性时，不能是Vue或者Vue._date</p><p>对数组进行监测的时候，对直接进行赋值所进行的修改并没有提供set和get方法，而是对操作数组的7组方法进行了包裹，从而在进行虚拟DOM那一套，当然也可以通过Vue.set和vm.$set去数组去进行修改</p><pre><code class="lang-html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;  &lt;title&gt;Document&lt;/title&gt;  &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;  &lt;!--  --&gt;  &lt;div id=&quot;root&quot;&gt;    &lt;h1&gt;学生信息&lt;/h1&gt;    &lt;button @click=&quot;student.age++&quot;&gt;年龄+1岁&lt;/button&gt; &lt;br&gt;    &lt;button @click=&quot;addSex&quot;&gt;添加性别，默认值：男&lt;/button&gt; &lt;br&gt;    &lt;button @click=&quot;addFriend&quot;&gt;在列表首位添加一个朋友&lt;/button&gt; &lt;br&gt;    &lt;button @click=&quot;replacename&quot;&gt;修改第一个朋友的名字为：张三&lt;/button&gt; &lt;br&gt;    &lt;button @click=&quot;addHobby&quot;&gt;添加一个爱好&lt;/button&gt; &lt;br&gt;    &lt;button @click=&quot;spliceHobby&quot;&gt;修改第一个爱好为：开车&lt;/button&gt; &lt;br&gt;    &lt;button @click=&quot;remove&quot;&gt;过滤掉爱好中的抽烟&lt;/button&gt; &lt;br&gt;    &lt;h3&gt;姓名：&#123;&#123;student.name&#125;&#125;&lt;/h3&gt;    &lt;h3&gt;年龄：&#123;&#123;student.age&#125;&#125;&lt;/h3&gt;    &lt;h3 v-if=&quot;student.sex&quot;&gt;性别：&#123;&#123;student.sex&#125;&#125;&lt;/h3&gt;    &lt;h3&gt;爱好：&lt;/h3&gt;    &lt;ul&gt;      &lt;li v-for=&quot;(h,index) in student.hobby&quot; :key=&quot;index&quot;&gt;&#123;&#123;h&#125;&#125;&lt;/li&gt;    &lt;/ul&gt;    &lt;h3&gt;朋友们：&lt;/h3&gt;    &lt;ul&gt;      &lt;li v-for=&quot;(f,index) in student.friends&quot; :key=&quot;index&quot;&gt;&#123;&#123;f.name&#125;&#125;-&#123;&#123;f.age&#125;&#125;&lt;/li&gt;    &lt;/ul&gt;  &lt;/div&gt;&lt;/body&gt;  &lt;script&gt;    Vue.config.productionTip = false;    const vm = new Vue(&#123;      data:function()&#123;        return&#123;          student:&#123;            name:&#39;tom&#39;,            age:18,            hobby:[&#39;抽烟&#39;, &#39;喝酒&#39;, &#39;烫头&#39;],            friends:[              &#123;name:&#39;jerry&#39;,age:35&#125;,              &#123;name:&#39;tony&#39;,age:36&#125;            ]          &#125;        &#125;      &#125;,      methods:&#123;        addSex()&#123;          this.$set(this.student,&#39;sex&#39;,&#39;男&#39;);        &#125;,        addFriend()&#123;          this.student.friends.unshift(&#123;name:&#39;jack&#39;,age:70&#125;);        &#125;,        replacename()&#123;          this.student.friends[0].name = &#39;张三&#39;;        &#125;,        addHobby()&#123;          this.student.hobby.push(&#39;打麻将&#39;);        &#125;,        spliceHobby()&#123;          this.student.hobby.splice(0, 1, &#39;开车&#39;);        &#125;,        remove()&#123;          this.student.hobby = this.student.hobby.filter((p)=&gt;&#123;            return p !== &#39;抽烟&#39;;          &#125;)        &#125;      &#125;    &#125;);    vm.$mount(&#39;#root&#39;)  &lt;/script&gt;&lt;/html&gt;</code></pre><h2 id="收集表单数据"><a href="#收集表单数据" class="headerlink" title="收集表单数据"></a>收集表单数据</h2><pre><code class="lang-html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;  &lt;title&gt;Document&lt;/title&gt;  &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;  &lt;!--     收集表单数据:    若: &lt;input type=&quot;text&quot;/&gt;, 则v-mode1收集的是value值，用户输入的就是value值。    若: &lt;input type=&quot;radio&quot; /&gt;，则v-mode1收集的是value值，且要给标签配置value值。    若: &lt;input type=&quot; checkbox&quot;/&gt;      1.没有配置input的value属性，那么收集的就是checked (勾选or 未勾选，是布尔值)      2.配置input的value属性:        (1)v-mode1的初始值是非数组，那么收集的就是checked (勾选or未勾选，是布尔值)        (2)v-mode1的初始值是数组，那么收集的的就是value组成的数组    备注: v-mode1的 三个修饰符:      lazy:失去焦点再收集数据      number:输入字符串转为有效的数字      trim:输入首尾空格过滤   --&gt;  &lt;div id=&quot;root&quot;&gt;  &lt;form @submit.prevent=&quot;demo&quot;&gt;    &lt;label for=&quot;name&quot; &gt;账号：&lt;/label&gt;    &lt;input type=&quot;text&quot; id=&quot;name&quot; v-model.trim=&quot;userInfo.account&quot;&gt;    &lt;br&gt;    &lt;label for=&quot;password&quot; &gt;密码：&lt;/label&gt;    &lt;input type=&quot;password&quot; id=&quot;password&quot; v-model=&quot;userInfo.password&quot;&gt;    &lt;br&gt;    &lt;label for=&quot;age&quot; &gt;年龄：&lt;/label&gt;    &lt;!-- v-model也是有修饰符的 --&gt;    &lt;input type=&quot;number&quot; id=&quot;age&quot; v-model.number=&quot;userInfo.age&quot;&gt;    &lt;br&gt;    性别：    男&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;male&quot; v-model=&quot;userInfo.sex&quot;&gt;    女&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;female&quot; v-model=&quot;userInfo.sex&quot;&gt;    &lt;br&gt;    爱好：    学习&lt;input type=&quot;checkbox&quot; v-model=&quot;userInfo.hobby&quot; value=&quot;study&quot;&gt;    打游戏&lt;input type=&quot;checkbox&quot; v-model=&quot;userInfo.hobby&quot; value=&quot;game&quot;&gt;    吃饭&lt;input type=&quot;checkbox&quot; v-model=&quot;userInfo.hobby&quot; value=&quot;eat&quot;&gt;    &lt;br&gt;    所属校区    &lt;select v-model=&quot;userInfo.city&quot;&gt;      &lt;option value=&quot;&quot;&gt;请选择校区&lt;/option&gt;      &lt;option value=&quot;bj&quot;&gt;北京&lt;/option&gt;      &lt;option value=&quot;sh&quot;&gt;上海&lt;/option&gt;      &lt;option value=&quot;sz&quot;&gt;深圳&lt;/option&gt;    &lt;/select&gt;    &lt;br&gt;    其他信息：    &lt;textarea v-model.lazy=&quot;userInfo.other&quot;&gt;&lt;/textarea&gt;    &lt;br&gt;    &lt;input type=&quot;checkbox&quot; v-model=&quot;userInfo.agree&quot;&gt; 阅读并接受&lt;a href=&quot;#&quot;&gt;《用户协议》&lt;/a&gt;    &lt;button&gt;提交&lt;/button&gt;  &lt;/form&gt;  &lt;/div&gt;&lt;/body&gt;  &lt;script&gt;    Vue.config.productionTip = false;    const vm = new Vue(&#123;      data:function()&#123;        return&#123;          userInfo:&#123;            account:&#39;&#39;,            password:&#39;&#39;,            sex:&#39;male&#39;,            hobby:[],            city:&#39;bj&#39;,            other:&#39;&#39;,            agree:&#39;&#39;,            age:0          &#125;        &#125;      &#125;,      methods:&#123;        demo()&#123;          console.log(JSON.stringify(this.userInfo));        &#125;      &#125;    &#125;);    vm.$mount(&#39;#root&#39;)  &lt;/script&gt;&lt;/html&gt;</code></pre><h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><pre><code class="lang-html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;  &lt;title&gt;Document&lt;/title&gt;  &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;  &lt;script src=&quot;../js/dayjs.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;  &lt;!--     过滤器:    定义:对要显示的数据进行特定格式化后再显示(适用于一些简单逻辑的处理)。    语法:      1.注册过滤器: Vue.filter(name,callback)或new Vue&#123;filters:&#123;&#125;&#125;      2.使用过滤器: &#123;&#123; XXX | 过滤器名&#125;&#125; 或v-bind:属性= &quot;xx| 过滤器名&quot;    备注:      1.过滤器也可以接收额外参数、多个过滤器也可以串联      2.并没有改变原本的数据，是产生新的对应的数据   --&gt;  &lt;div id=&quot;root&quot;&gt;    &lt;h2&gt;显示格式化后的时间&lt;/h2&gt;    &lt;h3&gt;现在是：&#123;&#123;time | timeFormater&#125;&#125;&lt;/h3&gt;    &lt;h3&gt;现在是：&#123;&#123;time | timeFormater('YYYY年MM月DD日')&#125;&#125;&lt;/h3&gt;    &lt;!-- 这里的mySlice会接受timeFormater返回的值进行处理 --&gt;    &lt;h3&gt;现在是：&#123;&#123;time | timeFormater('YYYY年MM月DD日') | mySlice&#125;&#125;&lt;/h3&gt;    &lt;h3 :x=&quot;msg | mySlice&quot;&gt;演示过滤器在绑定语法中的使用&lt;/h3&gt;  &lt;/div&gt;&lt;/body&gt;  &lt;script&gt;    Vue.config.productionTip = false;    //全局过滤器    Vue.filter(&#39;mySlice&#39;,function(value)&#123;      return value.slice(0, 4);    &#125;)    const vm = new Vue(&#123;      data:function()&#123;        return&#123;          time:1627532248020, //时间戳          msg:&#39;Hello World!&#39;        &#125;      &#125;,      filters:&#123;        timeFormater(value, str=&#39;YYYY年MM月DD日 HH:mm:ss&#39;)&#123;//返回值把整个框替换掉,value就是time值，在上面不写也会传入          return dayjs(value).format(str);        &#125;,        //局部过滤器        // mySlice(value)&#123;        //   return value.slice(0,4);        // &#125;      &#125;    &#125;);    vm.$mount(&#39;#root&#39;);  &lt;/script&gt;&lt;/html&gt;</code></pre><h2 id="内置指令"><a href="#内置指令" class="headerlink" title="内置指令"></a>内置指令</h2><pre><code class="lang-html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;  &lt;title&gt;Document&lt;/title&gt;  &lt;style&gt;    [v-cloak]&#123;      display: none;    &#125;  &lt;/style&gt;&lt;/head&gt;&lt;body&gt;  &lt;!--     v-text直接替换掉文本内容    v-html直接结构的解析,存在安全性问题    v-cloak指令(没有值) :    1.本质是一个特殊属性，Vue实例创建完毕并接管容器后，会删掉v- cloak属性。    2.使用css配合v-cloak可以解决网速慢时页面展示出( &#123;xx&#125; &#125;的问题。    v-pre跳过其所在节点的编译过程，没有使用指令语法，没有使用插值语法的节点   --&gt;  &lt;div id=&quot;root&quot;&gt;    &lt;div&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt;    &lt;div v-cloak&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt;    &lt;div v-text=&quot;name&quot;&gt;&lt;/div&gt;     &lt;div v-html=&quot;str&quot;&gt;&lt;/div&gt;    &lt;h2 v-once=&quot;handle&quot;&gt;初始化的n值是：&#123;&#123;n&#125;&#125;&lt;/h2&gt;     &lt;h2&gt;当前的n值是：&#123;&#123;n&#125;&#125;&lt;/h2&gt;    &lt;button @click=&quot;n++&quot;&gt;点我n+1&lt;/button&gt;  &lt;/div&gt;  &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;  &lt;script&gt;    Vue.config.productionTip = false;    const vm = new Vue(&#123;      data:function()&#123;        return&#123;          name:&#39;尚硅谷&#39;,          str:&#39;&lt;h2&gt;你好啊！&lt;/h2&gt;&#39;,          n:1        &#125;      &#125;    &#125;);    vm.$mount(&#39;#root&#39;)  &lt;/script&gt;&lt;/html&gt;</code></pre><h2 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h2><pre><code class="lang-html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;  &lt;title&gt;Document&lt;/title&gt;  &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=&quot;root&quot;&gt;    &lt;h2&gt;当前的n值是：&lt;span v-text=&quot;n&quot;&gt;&lt;/span&gt;&lt;/h2&gt;    &lt;!-- 指令名由几个单词组成的写法 --&gt;    &lt;h2&gt;放大10倍的n值是：&lt;span v-big-number=&quot;n&quot;&gt;&lt;/span&gt;&lt;/h2&gt;    &lt;button @click=&quot;n++&quot;&gt;点我n+1&lt;/button&gt;    &lt;br&gt;    &lt;input type=&quot;text&quot; v-fbind=&quot;n&quot;&gt;  &lt;/div&gt;&lt;/body&gt;  &lt;script&gt;    Vue.config.productionTip = false;    //全局指令    Vue.directive(&#39;fbind&#39;,&#123;          bind(element, binding)&#123;//绑定时调用            element.value = binding.value;          &#125;,          inserted(element,binding)&#123;//指令所在元素被插入页面时            element.focus();          &#125;,          update(element, binding)&#123;//指令所在模板被重新解析时调用            element.value = binding.value;          &#125;        &#125;)      Vue.directive(&#39;big-number&#39;,function(element,binding)&#123;        element.innerText = binding.value * 10;      &#125;)    const vm = new Vue(&#123;      data:function()&#123;        return&#123;          n:1        &#125;      &#125;,      //这个自定义指令是局部的      // directives:&#123;        //big函数何时被调用，1.指令与元素成功绑定时 2.指令所在的模板被重新解析时        //这里面的this都是window，因为这些操作都是自己做的DOM        // &#39;big-number&#39;(element,binding)&#123;        //   element.innerText = binding.value * 10;        // &#125;,        // fbind:&#123;        //   bind(element, binding)&#123;//绑定时调用        //     element.value = binding.value;        //   &#125;,        //   inserted(element,binding)&#123;//指令所在元素被插入页面时        //     element.focus();        //   &#125;,        //   update(element, binding)&#123;//指令所在模板被重新解析时调用        //     element.value = binding.value;        //   &#125;        // &#125;        // &#125;    &#125;);    vm.$mount(&#39;#root&#39;)  &lt;/script&gt;&lt;/html&gt;</code></pre><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><pre><code class="lang-html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;  &lt;title&gt;Document&lt;/title&gt;  &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;  &lt;!-- 常用的生命周期钩子:    1. mounted: 发送ajax请求、启动定时器、绑定自定义事件、订阅消息等[初始化操作]。    2. beforeDestroy:清除定时器、解绑自定义事件、取消订阅消息等[收尾工作]。    关于销毁Vue实例    1.销毁后借助Vue开发者工具看不到任何信息。    2.销毁后自定义事件会失效，但原生DOM事件依然有效。    3.一般不会在beforeDestroy操作数据，因为即便操作数据，也不会再触发更新流程了。 --&gt;  &lt;div id=&quot;root&quot;&gt;    &lt;h2&gt;当前的n值是：&#123;&#123;n&#125;&#125;&lt;/h2&gt;    &lt;button @click=&quot;add&quot;&gt;点我n+1&lt;/button&gt;    &lt;button @click=&quot;destroy&quot;&gt;点我销毁vm&lt;/button&gt;  &lt;/div&gt;&lt;/body&gt;  &lt;script&gt;    Vue.config.productionTip = false;    new Vue(&#123;      el:&#39;#root&#39;,      data:function()&#123;        return&#123;          n:1        &#125;      &#125;,      methods:&#123;        add()&#123;          this.n++;        &#125;,        destroy()&#123;          this.$destroy();        &#125;      &#125;,      beforeCreate() &#123;        console.log(this);      &#125;,      created() &#123;        console.log(this);      &#125;,      beforeMount() &#123;        console.log(&#39;beforeMount&#39;);      &#125;,      mounted() &#123;        console.log(&#39;mounted&#39;);      &#125;,      beforeUpdate() &#123;        console.log(&#39;beforeUpdate&#39;);      &#125;,      updated() &#123;        console.log(&#39;updated&#39;);      &#125;,      beforeDestroy() &#123;        console.log(&#39;beforedestroy&#39;);        console.log(this.n);      &#125;,      destroyed() &#123;        console.log(&#39;destroy&#39;);      &#125;,    &#125;);  &lt;/script&gt;&lt;/html&gt;</code></pre><h2 id="element-ui"><a href="#element-ui" class="headerlink" title="element-ui"></a>element-ui</h2><p>按需引入</p><pre><code class="lang-javascript">module.exports = &#123;  presets: [    &#39;@vue/cli-plugin-babel/preset&#39;,    [&quot;@babel/preset-env&quot;, &#123; &quot;modules&quot;: false &#125;]  ],  plugins: [    [      &quot;component&quot;,      &#123;        &quot;libraryName&quot;: &quot;element-ui&quot;,        &quot;styleLibraryName&quot;: &quot;theme-chalk&quot;      &#125;    ]  ]&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;入门介绍&quot;&gt;&lt;a href=&quot;#入门介绍&quot; class=&quot;headerlink&quot; title=&quot;入门介绍&quot;&gt;&lt;/a&gt;入门介绍&lt;/h1&gt;&lt;p&gt;Vue是一套用于构建用户界面的渐进式JavaScript框架&lt;/p&gt;
&lt;p&gt;采用组件化模式，提高代码复用率，且让代码更好维护</summary>
      
    
    
    
    
    <category term="vue" scheme="https://zzygeo.cn/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>Java知识点</title>
    <link href="https://zzygeo.cn/2021/07/13/Java%E5%9F%BA%E7%A1%80/Java%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>https://zzygeo.cn/2021/07/13/Java%E5%9F%BA%E7%A1%80/Java%E7%9F%A5%E8%AF%86%E7%82%B9/</id>
    <published>2021-07-13T08:24:14.000Z</published>
    <updated>2021-08-05T15:43:45.017Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java面向对象"><a href="#Java面向对象" class="headerlink" title="Java面向对象"></a>Java面向对象</h1><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口就是制定规范，给出一些没有实现的方法，封装到一起，到某个类要使用的时候，在根据具体情况把这些方法写出来。</p><p>在JDK8.0以后，接口可以有静态方法，默认方法。</p><p>但是在默认方法前面必须加default关键字</p><p>接口细节：</p><p>1.接口不可以被实例化</p><p>2.接口中的所有方法是public方法，接口中抽象方法，可以不用abstract修饰</p><p>3.一个普通类实现接口，就必须将该接口的所有方法都实现</p><p>4.抽象类去实现接口时，可以不实现接口的抽象方法</p><p>5.一个类同时可以实现多个接口</p><p>6.接口中的==属性==，只能是final的，而且是public static final修饰的，如int a =1;实际上是 public static final int a =1;</p><p>7.接口不能继承其他的类，但是可以继承多个别的接口</p><p>8.接口的修饰符，只能是public和默认，这点和类的修饰符是一样的</p><p>接口和类的比较</p><p>接口可以理解为是Java对单继承机制的补充</p><p>一个先天，一个后天</p><pre><code class="lang-java">package com.zzy.interface_;public class Interface02 &#123;    public static void main(String[] args) &#123;        LittleMonkey littleMonkey = new LittleMonkey(&quot;小悟空&quot;);        littleMonkey.climbing();        littleMonkey.swimming();        littleMonkey.flying();    &#125;&#125;class Money &#123;    private String name;    public Money(String name) &#123;        this.name = name;    &#125;    public String getName() &#123;        return name;    &#125;    public void climbing() &#123;        System.out.println( name + &quot;会爬树...&quot;);    &#125;&#125;interface Fishable &#123;    void swimming();&#125;interface Birdable &#123;    void flying();&#125;//继承父类class LittleMonkey extends Money implements Fishable, Birdable&#123;    public LittleMonkey(String name) &#123;        super(name);    &#125;    @Override    public void swimming() &#123;        System.out.println(getName() + &quot;通过学习，学会了游泳...&quot;);    &#125;    @Override    public void flying() &#123;        System.out.println(getName() + &quot;通过学习，学会了飞行...&quot;);    &#125;&#125;</code></pre><p>接口的动态绑定机制案例</p><pre><code class="lang-java">package com.zzy.interface_;public class InterfaceExercise &#123;    public static void main(String[] args) &#123;        Usb_[] usb = new Usb_[2];        usb[0] = new Iphone_();        usb[1] = new Camera_();        for (int i = 0; i &lt; usb.length; i++) &#123;            if (usb[i] instanceof Iphone_) &#123;                ((Iphone_) usb[i]).call();            &#125;            usb[i].work();        &#125;    &#125;&#125;interface Usb_ &#123;    void work();&#125;class Iphone_ implements Usb_ &#123;    @Override    public void work() &#123;        System.out.println(&quot;手机开始工作...&quot;);    &#125;    public void call() &#123;        System.out.println(&quot;手机可以打电话...&quot;);    &#125;&#125;class Camera_ implements Usb_ &#123;    @Override    public void work() &#123;        System.out.println(&quot;相机开始工作&quot;);    &#125;&#125;</code></pre><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>内部类最大的特点就是可以直接访问私有属性，并且可以体现类与类之间的包含关系</p><p>内部类的分类，有4种。</p><p>定义在外部类局部位置上（比如方法内）：</p><p>1.局部内部类（有类名）</p><p>2.匿名内部类（没有类名，重点）</p><p>定义在外部类的成员位置上：</p><p>1.成员内部类</p><p>2.静态内部类</p><h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><pre><code class="lang-java">package com.zzy.InnerClass;public class LocalInnerClass &#123;    public static void main(String[] args) &#123;        //演示        Outer02 outer02 = new Outer02();        outer02.m1();        System.out.println(&quot;Outer02的hashcode&quot; + outer02);    &#125;&#125;class Outer02 &#123;    private int n1 = 100;    public void m2()&#123;        System.out.println(&quot;m2()...&quot;);    &#125;;    public void m1() &#123;        //局部内部类是定义在外部类的局部位置，通常在方法        //不能添加访问修饰符，但是可以使用final修饰，因为局部变量也可以使用final修饰        //作用域：仅仅在定义它的方法或代码块中        final class Inner02 &#123;//局部内部类            //可以直接访问外部类的所有成员，包含私有的            private int n1 = 800;            public void f1() &#123;                //局部内部类可以直接访问外部类的成员                //如果外部类和局部内部类重名时，默认遵循就近原则，如果想访问外部类的成员                // 则可以使用外部类名.this.成员                //这里的Outer02.this就可以理解为对象，谁调用了这个方法，他就代表那个对象                System.out.println(&quot;n1 = &quot; + n1 + &quot; 外部类的n1 = &quot; + Outer02.this.n1);                //证明一下这个Outer02.this的地址                System.out.println(&quot;Outer02.this hashcode = &quot; + Outer02.this);                m2();            &#125;        &#125;        //外部类在方法中，可以创建Inner02对象，然后调用方法调用        Inner02 inner02 = new Inner02();        inner02.f1();    &#125;&#125;</code></pre><h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>本质还是类，还是定义在内部的，它是匿名的，系统会给他分配名字，它同时还是一个对象</p><pre><code class="lang-java">package com.zzy.InnerClass;public class AnonymousInnerClass &#123;    public static void main(String[] args) &#123;        //1.接口的匿名内部类        //原因：当只调用对象一次时，进行接口实现，若存在多个，则会造成多个对象创建，浪费资源        //因此需要用匿名内部类进行简化。        //编译类型看左边：A     运行类型其实是匿名内部类,为外部类$1(系统分配)        //jdk底层在创建匿名内部类时，立马就创建了其实例，并把地址返回给 tiger        //匿名内部类使用一次，就不能再使用        A tiger = new A() &#123;            @Override            public void cry() &#123;                System.out.println(&quot;老虎在叫唤...&quot;);            &#125;        &#125;;        //输出其运行类型采用getclass()方法        System.out.println(&quot;tiger的运行类型为&quot; + tiger.getClass());        tiger.cry();        //2.基于类的匿名内部类        //编译类型：Father，运行类型是匿名内部类        //同时也返回了匿名内部类的对象        //这里的Jack会传给father的构造器        Father father = new Father(&quot;Jack&quot;) &#123;            @Override            public void test() &#123;                System.out.println(&quot;匿名内部类重写了test方法...&quot;);            &#125;        &#125;;        System.out.println(&quot;father对象的运行类型为 &quot; + father.getClass());        father.test();    &#125;&#125;class Outer03 &#123;    private int n1 =10;    public void method() &#123;    &#125;&#125;interface A &#123;    //基于接口的匿名内部类    public void cry();&#125;class Father &#123;    //基于类的匿名内部类    public Father(String name) &#123;    &#125;    public void test() &#123;    &#125;&#125;</code></pre><p>匿名内部类的两种创建方法及细节</p><pre><code class="lang-java">package com.zzy.InnerClass;public class AnonymousInnerClass01 &#123;    public static void main(String[] args) &#123;        Outer04 outer04 = new Outer04();        outer04.f1();        System.out.println(&quot;外部的hashcode = &quot; + outer04);    &#125;&#125;class Outer04 &#123;    private int n1 =99;    public void f1() &#123;        //创建一个基于类的匿名内部类        //第一种调用方法        //不能添加访问修饰符，因为它的地位就是一个局部变量        //作用域：仅仅是在方法或者代码块中        Person p = new Person() &#123;            private int n1 =88;            @Override            public void hi() &#123;                //可以直接访问外部类的所有成员，包含私有的                //如果外部类和匿名内部类的成员重名时，匿名内部类访问的话，                //默认遵循就近原则，如果想访问外部类的成员，则可以使用(外部类名.this.成员)去访问                System.out.println(&quot;匿名内部类重写了hi()方法...&quot;);                System.out.println(&quot;n1 = &quot; + n1);//访问内部的n1                System.out.println(&quot;外部n1 = &quot; + Outer04.this.n1);                System.out.println(&quot;内部的hashcode = &quot; + Outer04.this);            &#125;        &#125;;        p.hi();//动态绑定机制        //第二种调用方法        new Person() &#123;            @Override            public void hi() &#123;                System.out.println(&quot;匿名内部类重写了hi()方法,第二种...&quot;);            &#125;        &#125;.hi();        new Person() &#123;            @Override            public void ok(String name) &#123;                System.out.println(&quot;重写了&quot; + name);            &#125;        &#125;.ok(&quot;Jack&quot;);    &#125;&#125;class Person &#123;    public void hi() &#123;        System.out.println(&quot;Person hi()&quot;);    &#125;    public void ok(String name) &#123;        System.out.println(&quot;Person ok() &quot; + name);    &#125;&#125;</code></pre><p>匿名内部类的实践</p><pre><code class="lang-java">package com.zzy.InnerClass;public class InnerClassExercise02 &#123;    public static void main(String[] args) &#123;        CellPhone cellPhone = new CellPhone();        cellPhone.alarmClock(new Bell() &#123;            @Override            public void ring() &#123;                System.out.println(&quot;懒猪起床了...&quot;);            &#125;        &#125;);        //在这里，编译类型是匿名内部类，重写了ring方法        cellPhone.alarmClock(new Bell() &#123;            @Override            public void ring() &#123;                System.out.println(&quot;小伙伴上课了...&quot;);            &#125;        &#125;);    &#125;&#125;interface Bell &#123;    public void ring();&#125;class CellPhone &#123;    public void alarmClock(Bell bell) &#123;        System.out.println(bell.getClass());        bell.ring();//动态绑定机制    &#125;&#125;</code></pre><h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><p>成员内部类是定义在外部类的成员位置，并且没有static修饰</p><pre><code class="lang-java">package com.zzy.InnerClass;import java.util.PrimitiveIterator;public class MemberInnerClass01 &#123;    public static void main(String[] args) &#123;        Outer05 outer05 = new Outer05();        outer05.m1();        //外部其他类，使用成员内部类的三种方法        //第一种方法        Outer05.Inner05 inner05 = outer05.new Inner05();        inner05.say();        //第二种方式，在外部类中，编写一个方法，可以返回Inner08对象        Outer05.Inner05 inner05instance = outer05.getInner05Instance();        inner05instance.say();        //第三种方式        Outer05.Inner05 inner05_ = new Outer05().new Inner05();        inner05_.say();    &#125;&#125;class Outer05 &#123;    private int n1 = 10;    public String name = &quot;张三&quot;;    //可以添加任意访问修饰符(public、protected、默认、private),因为它的地位就是一个成员    //作用域：和外部类的其他成员一样，为整个类体    public class Inner05 &#123;//成员内部类        private int n1 =66;        private String name = &quot;李四&quot;;        public void say() &#123;            //可以直接访问外部类的所有成员，包含私有的            //如果成员内部类的成员和外部类的成员重名,会遵守就近原则。            System.out.println(&quot;成员内部类的n1 = &quot; + n1 + &quot; 成员内部类类的name = &quot; + name);            System.out.println(&quot;外部类n1=&quot; + Outer05.this.n1 + &quot; 外部类的name=&quot; + Outer05.this.name);        &#125;    &#125;    //方法，返回一个Inner05的实例    public Inner05 getInner05Instance() &#123;        return new Inner05();    &#125;    //调用成员内部类    public void m1() &#123;        Inner05 inner05 = new Inner05();        inner05.say();    &#125;&#125;</code></pre><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><pre><code class="lang-java">package com.zzy.InnerClass;public class StaticInnerClass01 &#123;    public static void main(String[] args) &#123;        Outer6 outer6 = new Outer6();        outer6.m1();        //外部其他类使用静态内部类        //方式1        //因为静态内部类，是可以通过类名直接访问        Outer6.Inner6 inner6 = new Outer6.Inner6();        inner6.say();        //方式2，编写一个普通方法，可以返回静态内部类的对象实例        Outer6.Inner6 inner6_ = outer6.getInner6();        inner6_.say();        //方式3，编写一个静态方法        Outer6.Inner6 inner6_1 = Outer6.getInner6_();        inner6_1.say();    &#125;&#125;class Outer6 &#123;    private int n1 =10;    private static String name = &quot;张三&quot;;    //静态内部类    //放在外部类的成员位置，有static修饰    //可以添加任意的修饰符，因为它的地位就是一个成员    //作用域：整个类体    static class Inner6 &#123;        private static String name = &quot;zzy学java&quot;;        public void say() &#123;            //可以直接访问外部类的所有静态成员，包含私有的，但不能访问非静态成员            //如果成员内部类的成员和外部类的成员重名,会遵守就近原则。但访问外部类不用加this了            System.out.println(name);            System.out.println(Outer6.name);        &#125;    &#125;    public Inner6 getInner6() &#123;        return new Inner6();    &#125;    public static Inner6 getInner6_() &#123;        return new Inner6();    &#125;    //外部内调用    public void m1() &#123;        Inner6 inner6 = new Inner6();        inner6.say();    &#125;&#125;</code></pre><h2 id="枚举和注解"><a href="#枚举和注解" class="headerlink" title="枚举和注解"></a>枚举和注解</h2><p>自定义实现枚举</p><p>1.构造器私有化</p><p>2.本类内部创建一组对象</p><p>3.对外暴露对象（添加public final static修饰符）</p><p>4.可以提供get方法，但是不要提供set方法。</p><pre><code class="lang-java">package com.zzy.enum_;/** * @autho: 周钟炎 * @version: 1.0 */public class Enum02 &#123;    public static void main(String[] args) &#123;        System.out.println(Season_.AUTUMN);    &#125;&#125;//自定义枚举实现class Season_ &#123;    private String name;    private String desc;    //1.将构造器私有化    //2.去掉set方法    //3.在Season内部，直接创建固定的对象    //定义了四个对象    public final static Season_ SPRING = new Season_(&quot;春天&quot;, &quot;温暖&quot;);    public final static Season_ SUMMER = new Season_(&quot;夏天&quot;, &quot;炎热&quot;);    public final static Season_ AUTUMN = new Season_(&quot;秋天&quot;, &quot;凉爽&quot;);    public final static Season_ WINTER = new Season_(&quot;冬天&quot;, &quot;寒冷&quot;);    private Season_(String name, String desc) &#123;        this.name = name;        this.desc = desc;    &#125;    public String getName() &#123;        return name;    &#125;    public String getDesc() &#123;        return desc;    &#125;    @Override    public String toString() &#123;        return &quot;Season_&#123;&quot; +                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +                &quot;, desc=&#39;&quot; + desc + &#39;\&#39;&#39; +                &#39;&#125;&#39;;    &#125;&#125;</code></pre><p>关键字实现枚举</p><p>主要是对类的创建做了简化。</p><pre><code class="lang-java">package com.zzy.enum_;/** * @autho: 周钟炎 * @version: 1.0 */public class Enum03 &#123;    public static void main(String[] args) &#123;        System.out.println(Season1.SPRING);    &#125;&#125;//关键字实现枚举enum Season1 &#123;    //使用关键字来实现enum    //1.使用关键字enum替代class    //2.按照下面的写法，如果有多个常量，使用,间隔即可    //3.如果使用enum来实现枚举，要求将定义常量对象写在最前面    SPRING(&quot;春天&quot;, &quot;温暖&quot;),    SUMMER(&quot;夏天&quot;, &quot;炎热&quot;);    private String name;    private String desc;    private Season1(String name, String desc) &#123;        this.name = name;        this.desc = desc;    &#125;    public String getName() &#123;        return name;    &#125;    public String getDesc() &#123;        return desc;    &#125;    @Override    public String toString() &#123;        return &quot;Season_&#123;&quot; +                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +                &quot;, desc=&#39;&quot; + desc + &#39;\&#39;&#39; +                &#39;&#125;&#39;;    &#125;&#125;</code></pre><p>==Javap可以将编译的class文件反编译，从而看到一些重要的信息。==</p><p>枚举练习</p><pre><code class="lang-java">package com.zzy.enum_;/** * @autho: 周钟炎 * @version: 1.0 */public class EnumExercise &#123;    public static void main(String[] args) &#123;        Gender boy = Gender.BOY;        Gender bou2 = Gender.BOY;        //所有的enum类都继承了Enum类，它的toString方法返回的是名字        System.out.println(boy);        System.out.println(boy == bou2);    &#125;&#125;enum Gender&#123;    BOY,GIRL;&#125;</code></pre><p>枚举方法的使用:</p><pre><code class="lang-java">package com.zzy.enum_;/** * @autho: 周钟炎 * @version: 1.0 */public class EnumMethod &#123;    //演示Enum类的各种方法的使用    public static void main(String[] args) &#123;        Season1 spring = Season1.SPRING;        //输入枚举变量的名字        System.out.println(spring.name());        //输出的是该枚举对象的次序，从0开始编号        System.out.println(spring.ordinal());        //从反编译可以看出，values方法,返回Season1[],含有定义的所有枚举对象        Season1[] values = Season1.values();        for(Season1 i : values) &#123;//简洁的写法            System.out.println(&quot;i = &quot; + i);        &#125;        //valueof：将字符串转换成枚举对象，要求字符串必须为已有的常量名，否则报异常        //1.根据你输入的&quot;SUMMER&quot;到Season1的枚举对象去查找        //2.如果找到了，就返回，如果没找到，就报错        Season1 summer = Season1.valueOf(&quot;SUMMER&quot;);        System.out.println(&quot;autumn = &quot; + summer);        //compareTO:比较两个枚举常量，比较的就是编号        //self.ordinal - other.ordinal        System.out.println(Season1.SPRING.compareTo(Season1.SUMMER));    &#125;&#125;</code></pre><p>枚举练习</p><pre><code class="lang-java">package com.zzy.enum_;/** * @autho: 周钟炎 * @version: 1.0 */public class EnumExercise01 &#123;    public static void main(String[] args) &#123;        Week[] values = Week.values();        System.out.println(&quot;所有输出的信息如下：&quot;);        for (Week i : values) &#123;            System.out.println(i);        &#125;    &#125;&#125;enum Week &#123;    MONDAY(&quot;星期一&quot;),    TUESDAY(&quot;星期二&quot;),    WEDNESDAY(&quot;星期三&quot;),    THURSDAY(&quot;星期四&quot;),    FRIDAY(&quot;星期五&quot;),    SATURDAY(&quot;星期六&quot;),    SUNDAY(&quot;星期日&quot;);    private String week;    private Week(String week) &#123;        this.week = week;    &#125;    @Override    public String toString() &#123;        return week;    &#125;&#125;</code></pre><p>enum细节：</p><p>1.使用enum关键词后，就不能再继承其他类了，因为enum会隐式的继承Enum，而Java是单继承机制。</p><p>2.枚举类和普通类一样，可以实现接口。</p><p>Target是修饰注解的注解，称为元注解。</p><p>@Deprecated修饰某个元素，表示该元素已经过时了，即不推荐使用，但是仍然可以使用。</p><p>当们不希望看到这些警告的时候，可以使用SuppressWarnings注解来抑制警告信息</p><p>元注解：</p><p>1.Retention，指定注解的作用范围</p><p>2.Target，指定注解可以在哪些地方使用</p><p>3.Documented，指定该注解是否会在javadoc体现</p><p>4.Inherited，子类会继承父类注解</p><p>枚举搭配switch使用：</p><pre><code class="lang-java">package com.zzy.annotation;/** * @autho: 周钟炎 * @version: 1.0 */public class Homework07 &#123;    public static void main(String[] args) &#123;        Color green = Color.GREEN;        green.show();        switch (green) &#123;            case YELLOW:                System.out.println(&quot;匹配到黄色...&quot;);                break;            case RED:                System.out.println(&quot;匹配到红色...&quot;);                break;            case BLACK:                System.out.println(&quot;匹配到黑色...&quot;);                break;            case BLUE:                System.out.println(&quot;匹配到蓝色...&quot;);                break;            case GREEN:                System.out.println(&quot;匹配到绿色...&quot;);                break;            default:                System.out.println(&quot;没有匹配到...&quot;);        &#125;    &#125;&#125;enum Color implements IColor&#123;    RED(255,0,0),    BLUE(0,0,255),    BLACK(0,0,0),    YELLOW(255,255,0),    GREEN(0,255,0);    private int redValue;    private int greenValue;    private int blueValue;    Color(int redValue, int greenValue, int blueValue) &#123;        this.redValue = redValue;        this.greenValue = greenValue;        this.blueValue = blueValue;    &#125;    @Override    public void show() &#123;        System.out.println(&quot;redValue = &quot; + redValue);        System.out.println(&quot;redValue = &quot; + greenValue);        System.out.println(&quot;redValue = &quot; + blueValue);    &#125;&#125;interface IColor &#123;    abstract void show();&#125;</code></pre><h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><pre><code class="lang-java">//如果程序员，认为一段代码可能出现异常，可以使用try-catch异常处理机制来解决//从而保证程序的健壮性//如果进行了异常处理，那么即使出现了异常，程序也可以继续执行</code></pre><p>执行过程中所发生的异常事件可分为两大类</p><p>1.Error（错误）：Java虚拟机无法解决的严重问题。如：JVM系统内部错误、资源耗尽等严重情况。</p><p>2.Exception:其他因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理。Exception又分为两大类：运行时异常【程序运行时，发生的异常】和编译时异常【编程时，编译器检查出的异常】。</p><p>常见的运行时异常：</p><p>1.NullPointerException 空指针异常</p><p>2.ArithmeticException 数学运算异常</p><p>3.ArrayIndexOutOfBoundsException 数组下标越界异常</p><p>4.ClassCastException 类型转换异常</p><p>5.NumberFormatException 数字格式不正确异常</p><h2 id="try-catch异常处理"><a href="#try-catch异常处理" class="headerlink" title="try-catch异常处理"></a>try-catch异常处理</h2><pre><code class="lang-java">package com.zzy.exception_;/** * @autho: 周钟炎 * @version: 1.0 */public class Exception02 &#123;    public static void main(String[] args) &#123;        try &#123;//碰到异常以后会跳过后面的代码，直接执行catch块            //如果异常没有发生，则顺序执行try的代码块，不会进入到catch            //如果想不管是否发生异常，都执行以下代码，可以用finally            String str = &quot;zzy学Java&quot;;            int a = Integer.parseInt(str);            System.out.println(&quot;数字：&quot; + a);        &#125; catch (NumberFormatException e) &#123;            System.out.println(&quot;异常信息 = &quot; + e.getMessage());        &#125;finally &#123;            System.out.println(&quot;finally代码块被执行&quot;);        &#125;    &#125;&#125;</code></pre><pre><code class="lang-java">package com.zzy.exception_;/** * @autho: 周钟炎 * @version: 1.0 */public class Exception03 &#123;    public static void main(String[] args) &#123;        //可以使用多个catch分别捕获不同的异常，相应处理        //但是要求子类异常写在前面，父类异常写在后面        try &#123;            Person person = new Person();            person = null;            System.out.println(person.name);            int n1 = 10;            int n2 = 0;            int res = n1 / n2;        &#125; catch (NullPointerException e) &#123;            System.out.println(&quot;异常信息是：&quot; + e.getMessage());        &#125;catch (ArithmeticException e) &#123;            System.out.println(&quot;异常信息是：&quot; + e.getMessage());        &#125;        catch (Exception e) &#123;            e.printStackTrace();        &#125; finally &#123;        &#125;    &#125;&#125;class Person &#123;    public String name = &quot;jack&quot;;    public String getName() &#123;        return name;    &#125;&#125;</code></pre><p>可以使用try-finally配合使用，这种用法相当于没有捕获异常，因为程序会崩溃。应用场景一般是执行一段代码，不管是否发生异常，都必须执行某个业务逻辑。</p><p>异常处理练习题：</p><pre><code class="lang-java">package com.zzy.exception_;/** * @autho: 周钟炎 * @version: 1.0 */public class ExceptionExercise &#123;    public static int method() &#123;        int i = 1;        try &#123;            i++;            String[] names = new String[3];            if (names[1].equals(&quot;tom&quot;)) &#123;                System.out.println(names[1]);            &#125;else &#123;                names[3] = &quot;hspedu&quot;;            &#125;            return 1;        &#125;catch (ArrayIndexOutOfBoundsException e) &#123;            return 2;        &#125;catch (NullPointerException e) &#123;            return ++i; //这里的i会被传给临时变量，最后再返回这个临时变量        &#125;finally &#123;            ++i;            System.out.println(&quot;i = &quot; + i);        &#125;    &#125;    public static void main(String[] args) &#123;        System.out.println(method());    &#125;&#125;</code></pre><p>利用异常控制输入：</p><pre><code class="lang-java">package com.zzy.exception_;import java.util.Scanner;/** * @autho: 周钟炎 * @version: 1.0 */public class ExceptionExercise01 &#123;    public static void main(String[] args) &#123;        Scanner scanner = new Scanner(System.in);        int num = 0;        while (true) &#123;            System.out.println(&quot;请输入一个整数：&quot;);            try &#123;                num = Integer.parseInt(scanner.next());                break;            &#125; catch (NumberFormatException e) &#123;                System.out.println(&quot;你输入的不是一个整数...&quot;);            &#125;        &#125;        System.out.println(&quot;你输入的值：&quot; + num);    &#125;&#125;</code></pre><h2 id="throws异常处理"><a href="#throws异常处理" class="headerlink" title="throws异常处理"></a>throws异常处理</h2><p>1.如果一个方法可能生成某种异常，但是并不能确定如何处理这种异常，则该方法应显示地声明抛出异常，表明该方法将不对这些异常进行处理，而由该方法的调用者负责处理。</p><p>2.在方法声明中用throws语句可以声明抛出异常的列表，throws后面的异常类型可以是方法中产生的异常，也可以是它的父类</p><p>细节：</p><p>==子类重写父类的方法时，对抛出异常的规定：子类重写的方法，所抛出的异常类型要么和父类一样，要么为父类抛出的异常类型的子类==</p><h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><pre><code class="lang-java">package com.zzy.throws_;/** * @autho: 周钟炎 * @version: 1.0 */public class CustomException &#123;    public static void main(String[] args) &#123;        int age = 180;        if (!(age &gt;= 18 &amp;&amp; age &lt;= 120)) &#123;            //这里可以沟通构造器设置它的信息            throw new AgeException(&quot;年龄需要在18-120岁之间...&quot;);        &#125;        System.out.println(&quot;你的年龄范围正确...&quot;);    &#125;&#125;//一般都继承运行时异常，不然是编译时异常，还需要对它进行处理，程序才能跑起来class AgeException extends RuntimeException &#123;    public AgeException(String message) &#123;//构造器        super(message);    &#125;&#125;</code></pre><p>throw和throws的区别</p><div class="table-container"><table><thead><tr><th></th><th>意义</th><th>位置</th><th>后面跟的东西</th></tr></thead><tbody><tr><td>throws</td><td>异常的一种处理方式</td><td>方法声明处</td><td>异常类型</td></tr><tr><td>throw</td><td>自定义异常的关键字</td><td>方法体中</td><td>异常对象</td></tr></tbody></table></div><p>异常案例：</p><p>==finally输出在throw之前==</p><pre><code class="lang-java">package com.zzy.throws_;/** * @autho: 周钟炎 * @version: 1.0 */public class ExceptionExercise &#123;    public static void main(String[] args) &#123;        try &#123;            ReturnExceptionDemo.methodA();        &#125;catch (Exception e) &#123;            System.out.println(e.getMessage());        &#125;        ReturnExceptionDemo.methodB();    &#125;&#125;class ReturnExceptionDemo &#123;    static void methodA() &#123;        try &#123;            System.out.println(&quot;进入方法A...&quot;);            //先输出finally里的内容，再throw            throw new RuntimeException(&quot;制造异常...&quot;);        &#125; finally &#123;            System.out.println(&quot;用A方法的finally...&quot;);        &#125;    &#125;    static void methodB() &#123;        try &#123;            System.out.println(&quot;进入方法B...&quot;);            return;        &#125;finally &#123;            System.out.println(&quot;调用B方法的finally...&quot;);        &#125;    &#125;&#125;</code></pre><pre><code class="lang-java">package com.zzy.throws_;import java.util.Scanner;/** * @autho: 周钟炎 * @version: 1.0 */public class Homework01 &#123;    public static void main(String[] args) &#123;        try &#123;            Scanner scanner = new Scanner(System.in);            System.out.println(&quot;输入第一个数：&quot;);            //可能有输入异常            int num1 = Integer.parseInt(scanner.next());            System.out.println(&quot;输入第二个数：&quot;);            int num2 = Integer.parseInt(scanner.next());            //可能有算数异常            int res = cal(num1, num2);            System.out.println(&quot;输出的结果为：&quot; + res);        &#125; catch (NumberFormatException e) &#123;            System.out.println(&quot;请输入整数...&quot;);        &#125; catch (ArithmeticException e) &#123;            System.out.println(&quot;分母不能为0...&quot;);        &#125;    &#125;    public static int cal(int n1, int n2) &#123;        return n1 / n2;    &#125;&#125;</code></pre><h1 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h1><h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><p>针对8种基本定义相应的引用类型-包装类</p><p>boolean、char这两的父类是Object，byte、short、int、long、float、double的父类是Number</p><p><a href="https://blog.csdn.net/qq_44707077/article/details/116030063">深入浅出Java包装类_TD230的博客-CSDN博客</a></p><h2 id="包装类和-基本数据的转换"><a href="#包装类和-基本数据的转换" class="headerlink" title="包装类和 基本数据的转换"></a>包装类和 基本数据的转换</h2><p>装箱和拆箱</p><pre><code class="lang-java">package com.zzy.wrapper;/** * @autho: 周钟炎 * @version: 1.0 */public class Integer01 &#123;    public static void main(String[] args) &#123;        //int-&gt;Integer的装箱和拆箱        //jdk5前是手动装箱和拆箱        int n1 = 100;        Integer integer = Integer.valueOf(n1);        //手动拆箱        int i = integer.intValue();        //jdk5后，就可以自动装箱和自动拆箱        int n2 = 200;        Integer integer2 = n2; //底层使用的是仍然是 Integer.valueOf(n2)        //自动拆箱        int n3 = integer2; //底层使用的仍然是 int n3 = integer.intValue()    &#125;&#125;</code></pre><p>==三元运算符是一个整体==</p><pre><code class="lang-java">package com.zzy.wrapper;/** * @autho: 周钟炎 * @version: 1.0 */public class Exercise01 &#123;    public static void main(String[] args) &#123;        Object obj1 = true ? new Integer(1) : new Double(2.0);        //这里结果是1.0，三元运算符是一个整体，要先提升优先级        System.out.println(obj1);    &#125;&#125;</code></pre><p>包装类和String的转换</p><pre><code class="lang-java">package com.zzy.wrapper;/** * @autho: 周钟炎 * @version: 1.0 */public class WrapperVsString &#123;    public static void main(String[] args) &#123;        //包装类(Integer)装成String        Integer i1 = 100; //自动装箱        //方式1        String str1 = i1 + &quot;&quot;; //这里只是值传递        //方式二        String str2 = i1.toString();        //方式三        String str3 = String.valueOf(i1);        //把String转成包装类        int i2 = Integer.parseInt(str4); //这里换成Integer可以用到自动装箱        Integer i3 = new Integer(str4);        Integer i4 = Integer.valueOf(str4);    &#125;&#125;</code></pre><p>练习：</p><pre><code class="lang-java">package com.zzy.wrapper;/** * @autho: 周钟炎 * @version: 1.0 */public class Exercise02 &#123;    public static void main(String[] args) &#123;        Integer i = new Integer(1);        Integer j = new Integer(1);        System.out.println(i == j);        //主要看valueOf的源码        Integer m = 1;        Integer n = 1;        System.out.println(m == n);        Integer x = 128;        Integer y = 128;        System.out.println( x == y);    &#125;&#125;</code></pre><h2 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h2><pre><code class="lang-java">package com.zzy.string_;/** * @autho: 周钟炎 * @version: 1.0 */public class String01 &#123;    public static void main(String[] args) &#123;        String name = &quot;zzy&quot;;        //创建String对象的两种方式        //方式1,直接创建        //方式一先从常量池查看是否有&quot;zzy&quot;数据空间，如果有，直接指向；如果没有则重新创建，然后指向        //最终指向的是常量池的空间地址        String s = &quot;zzy&quot;;        //方式2，调用构造器        //先在堆中创建空间，里面维护了value属性，指向常量池的zzy空间，如果常量池没有&quot;zzy&quot;，重新创建，        //如果有，直接通过value指向。最终的是堆中的空间地址        String s1 = new String(&quot;zzy&quot;);        String a = &quot;abc&quot;;        String b = new String(&quot;abc&quot;);        System.out.println(a.equals(b)); //T        System.out.println(a == b); //F        //intern方法就是到常量池去找这个b对象，如果有，直接返回常量池的地址，        // 没有就在常量池创建一个在返回        System.out.println(a == b.intern()); //T        System.out.println(b == b.intern()); //F        //这里在常量池里创建了两个对象        String str1 = &quot;abc&quot;;        str1 = &quot;bcd&quot;;        //这里在常量池创建了一个对象，底层会对其进行优化        String str2 = &quot;hello&quot; + &quot;abc&quot;;        String str3 = &quot;zzy&quot;;        String str4 = &quot;java&quot;;        //下面两条语句有着明细的区别，str5是先在池中创建一个StringBuilder对象，然后append添加进去        // 最后将拼接起来的字符串返回给堆区，堆区再指向str5，所以返回的是堆中的地址        //str6是直接拼接，返回的是池中的地址        String str5 = str3 + str4;        String str6 = &quot;zzy&quot; + &quot;java&quot;;        System.out.println(str5 == str6); //F    &#125;&#125;</code></pre><p>案例</p><pre><code class="lang-java">package com.zzy.string_;/** * @autho: 周钟炎 * @version: 1.0 */public class String02 &#123;    public static void main(String[] args) &#123;        Test01 ex = new Test01();        //这个changes方法会在栈上重新开辟一块区域，运行完就销毁了        ex.changes(ex.str, ex.ch);        System.out.println(ex.str + &quot;and&quot;); //hspand        System.out.println(ex.ch); //hava    &#125;&#125;class Test01 &#123;    String str = new String(&quot;hsp&quot;);    final char[] ch = &#123;&#39;j&#39;, &#39;a&#39;, &#39;v&#39;, &#39;a&#39;&#125;;    public void changes(String str, char ch[]) &#123;        str = &quot;java&quot;;        ch[0] = &#39;h&#39;;    &#125;&#125;</code></pre><p>String类的常用方法</p><p>String类是保存字符串常量的，每次更新都需要重新开辟空间，效率较低，因此Java设计者还提供了StringBuilder和StringBuffer来增强String的功能，并提高效率</p><pre><code class="lang-java">package com.zzy.string_;/** * @autho: 周钟炎 * @version: 1.0 */public class StringMethod &#123;    public static void main(String[] args) &#123;        String str = &quot;春眠不觉晓，处处闻啼鸟，夜来风雨声，花落知多少&quot;;        String[] str1 = str.split(&quot;，&quot;);        for (String i : str1) &#123;            System.out.println(i);        &#125;        //在分割时，碰见特殊字符，则需要进行转义        String str2 = &quot;E:\\aaa\\bbb&quot;;        String[] str3 = str2.split(&quot;\\\\&quot;);        for (String i : str3) &#123;            System.out.println(i);        &#125;        //字符串转成字符数组        String str4 = &quot;happy&quot;;        char[] chars =  str4.toCharArray();        for (char i : chars) &#123;            System.out.println(i);        &#125;        //format可以定义String的输出格式        String name = &quot;Han Shun Ping&quot;;        String[] s = str.split(&quot; &quot;);         String format = String.format(&quot; %s,%s ,%c&quot;, s[2], s[0], s[1].charAt(0));        System.out.println(format);    &#125;&#125;</code></pre><p>StringBuffer类</p><p>StringBuffer代表可变的字符序列，可以对字符串内容进行增删。</p><pre><code class="lang-java">package com.zzy.stringbuffer_;/** * @autho: 周钟炎 * @version: 1.0 */public class StringBuffer01 &#123;    public static void main(String[] args) &#123;        //在父类中 AbstractStringBuilder有属性byte[]，不是final修饰的        //因此它是存放在堆中，不是存放在常量池        //StringBuffer是一个final类，不能被继承        //因为StringBuffer字符内容是存在byte[] value里的 ，因此每次变化内容不用都更换地址，        // 除非是内存不够了，效率高于String        StringBuffer stringBuffer = new StringBuffer(&quot;hello&quot;);    &#125;&#125;</code></pre><p>StringBuffer的几种构造器</p><pre><code class="lang-java">package com.zzy.stringbuffer_;/** * @autho: 周钟炎 * @version: 1.0 */public class StringBuffer02 &#123;    public static void main(String[] args) &#123;        //1.创建一个默认为16大小的char[]，用于存放字符内容        StringBuffer stringBuffer1 = new StringBuffer();        //2.通过构造器指定char[]大小        StringBuffer stringBuffer2 = new StringBuffer(100);        //3.通过给一个String创建StringBuffer        StringBuffer stringBuffer3 = new StringBuffer(&quot;zzy&quot;);    &#125;&#125;</code></pre><p>String与StringBuffer的转换</p><pre><code class="lang-java">package com.zzy.stringbuffer_;/** * @autho: 周钟炎 * @version: 1.0 */public class StringAndStringBuffer &#123;    public static void main(String[] args) &#123;        //String-&gt;StringBuffer        String str = &quot;hello&quot;;        //方式1，使用构造器,但是这里只是stringbuffer做了改变        StringBuffer stringBuffer = new StringBuffer(str);        //方式2，先创建一个空的，在用append去增加        StringBuffer stringBuffer1 = new StringBuffer();        stringBuffer1.append(str);        //StringBuffer-&gt;String        StringBuffer stringBuffer2 = new StringBuffer(&quot;zzy&quot;);        //方式1，使用StringBuffer提供的toString方法        String str1 = stringBuffer2.toString();        //方式2，使用String提供的构造器        String s = new String(stringBuffer2);    &#125;&#125;</code></pre><p>StringBuffer的增删改查</p><p>1.增 append 2.删 delete 3.改 replace 4. indexOf 5. 插 insert 6. 获取长度 length</p><pre><code class="lang-java">package com.zzy.stringbuffer_;/** * @autho: 周钟炎 * @version: 1.0 */public class StringBuferMethod &#123;    public static void main(String[] args) &#123;        StringBuffer stringBuffer = new StringBuffer(&quot;hello&quot;);        //尾插        stringBuffer.append(&quot;,&quot;);        stringBuffer.append(&quot;张三丰&quot;);        stringBuffer.append(&quot;张无忌&quot;).append(100).append(true).append(10.5);        System.out.println(stringBuffer);        //删除        stringBuffer.delete(12, 15);        System.out.println(stringBuffer);//前闭后开        //修改        stringBuffer.replace(9,12,&quot;周芷若&quot;);        System.out.println(stringBuffer);        //查找        int num = stringBuffer.indexOf(&quot;张三丰&quot;);        System.out.println(num);        //插入,在索引为9的位置插入，原来索引为9的内容自动后移        stringBuffer.insert(9, &quot;操&quot;);        System.out.println(stringBuffer);        //长度        System.out.println(stringBuffer.length());    &#125;&#125;</code></pre><p>练习题</p><pre><code class="lang-java">package com.zzy.stringbuffer_;import java.util.Scanner;/** * @autho: 周钟炎 * @version: 1.0 */public class StringBufferExercise &#123;    public static void main(String[] args) &#123;        Scanner scanner = new Scanner(System.in);        String str = scanner.next();        StringBuffer stringBuffer = new StringBuffer(str);        //查        for (int i = stringBuffer.lastIndexOf(&quot;.&quot;) - 3; i &gt; 0 ; i -= 3) &#123;            stringBuffer = stringBuffer.insert(i, &quot;,&quot;);        &#125;        System.out.println(stringBuffer);    &#125;&#125;</code></pre><p>StringBuilder类</p><p>1.一个可变的字符序列。此类提供一个与StringBuffer兼容的API，但不保证同步（有线程安全问题）。该类被设计用作StringBuffer的一个简易替换，用在字符串缓冲区被单个线程使用的时候。如果可能，建议优先采用该类，因为在大多数实现中，它比StringBuffer要快。</p><p>2.在StringBuilder上的主要操作是append和insert方法，可以重载这些方法，以接受任意类型的数据。</p><p>String: 不可变字符序列，效率低，但是复用率高。</p><p>StringBuffer：可变字符序列，效率较高，线程安全。</p><p>StringBuilder:可变字符序列，效率最高，线程不安全。</p><p>使用的原则：</p><p>1.如果字符串存在大量的修改操作，一般使用StringBuffer或者StringBuilder</p><p>2.如果字符串存在大量的修改操作，并在单线程的情况下，使用StringBuilder</p><p>3.如果字符串存在大量的修改操作，并在多线程的情况下，使用StringBuilder</p><p>4.如果我们字符串很少修改，被多个对象引用，使用String,比如配置信息</p><h2 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h2><p>一般都为静态方法</p><pre><code class="lang-java">package com.zzy.math_;import com.sun.jdi.DoubleValue;import java.sql.SQLOutput;/** * @autho: 周钟炎 * @version: 1.0 */public class MathMethod &#123;    public static void main(String[] args) &#123;        //Math常用方法        //abs 绝对值        int abs = Math.abs(-2);        System.out.println(abs);        //pow 求幂        double pow = Math.pow(2, 3);        System.out.println(pow);        //ceil 向上取整 返回最小整数（转成double)        double ceil = Math.ceil(- 3.1);        System.out.println(ceil);        //floor 向下取整,坐标轴右边为上,(装成double)        double floor = Math.floor(-3.1);        System.out.println(floor);        //round 四舍五入        long round = Math.round(4.5);        System.out.println(round);        //开方        double x = Math.sqrt(10);        System.out.println(x);        //返回随机数,返回[0, 1)的数        double y = Math.random();        double z = Math.floor( y * 6 + 2);        System.out.println(z);        //max, min 返回最大值和最小值        int min = Math.min(1, 9);        int max = Math.max(45, 90);        System.out.println(&quot;max = &quot; + max);        System.out.println(&quot;min = &quot; + min);    &#125;&#125;</code></pre><h2 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h2><p>toString方法，打印出数组所有元素</p><pre><code class="lang-java">package com.zzy.array_;import java.util.Arrays;import java.util.Comparator;/** * @autho: 周钟炎 * @version: 1.0 */public class ArrayMethod01 &#123;    public static void main(String[] args) &#123;        Integer[] integers = &#123;1, 20, 90&#125;;        //Arrays的toString方法        System.out.println(Arrays.toString(integers));        //排序        Integer[] arr1 = &#123;1, -1, 7, 0, 89&#125;;        //可以使用冒泡排序，也可以使用Arrays提供的sort方法        //数组是引用类型,所以通过sort排序后，会直接影响到实参 arr        Arrays.sort(arr1);        System.out.println(&quot;排序后...&quot;);        System.out.println(Arrays.toString(arr1));        //定制排序，实现了Comparator接口的匿名内部类        Arrays.sort(arr1, new Comparator&lt;Integer&gt;() &#123;            @Override            public int compare(Integer o1, Integer o2) &#123;                return o2 -o1;            &#125;        &#125;);        System.out.println(Arrays.toString(arr1));    &#125;&#125;</code></pre><p>自己实现排序：</p><pre><code class="lang-java">package com.zzy.array_;import java.util.Arrays;import java.util.Comparator;/** * @autho: 周钟炎 * @version: 1.0 */public class ArraySortCustom &#123;    public static void main(String[] args) &#123;        int[] arr = &#123;1, -1, 8, 0, 20 &#125;;        bubble_sort01(arr, new Comparator() &#123;            @Override            public int compare(Object o1, Object o2) &#123;                int i1 = (Integer) o1; //向下转型加自动拆箱                int i2 = (Integer) o2;                return i1 -i2; //return i2 -i1;            &#125;        &#125;);        System.out.println(Arrays.toString(arr));    &#125;    public static void bubble_sort(int[] arr) &#123;        for (int i = 0; i &lt; arr.length ; i++) &#123;            for (int j = i+1; j &lt;arr.length ; j++) &#123;                if ( arr[i] &gt; arr[j]) &#123;                    int temp = arr[i];                    arr[i] = arr[j];                    arr[j] = temp;                &#125;            &#125;        &#125;    &#125;    //结合冒泡 + 定制    public static void bubble_sort01 (int[] arr, Comparator c) &#123;        for (int i = 0; i &lt; arr.length ; i++) &#123;            for (int j = i+1; j &lt;arr.length ; j++) &#123;                //数组的排序由if里的语句去控制                if ( c.compare(arr[i], arr[j]) &gt; 0) &#123;                    int temp = arr[i];                    arr[i] = arr[j];                    arr[j] = temp;                &#125;            &#125;        &#125;    &#125;&#125;</code></pre><pre><code class="lang-java">package com.zzy.array_;import java.util.Arrays;import java.util.List;/** * @autho: 周钟炎 * @version: 1.0 */public class ArrayMethod02 &#123;    public static void main(String[] args) &#123;        Integer[] arr = &#123;1, 2, 90, 123, 567&#125;;        //使用binarySearch 二叉查找，要求数组是有序的        //如果该数组是无序的，不能使用binarySearch        //如果不存在，就返回 -(low + 1)，low代表他应该存在的位置        int index = Arrays.binarySearch(arr, 568);        System.out.println(index); //-6        //copyOf 数组元素的复制,从arr中拷贝 arr.length个元素到newArr        //如果拷贝的长度 &gt;原来数组，就在原来的数组尾插一个null        Integer[] newArr = Arrays.copyOf(arr, arr.length + 1);        System.out.println(Arrays.toString(newArr));        //fill 数组填充,使用99替换原来的数组        Integer[] num = &#123;9, 3, 2&#125;;        Arrays.fill(num, 99);        System.out.println(&quot;数组填充后...&quot;);        System.out.println(Arrays.toString(num));        //equals 比较两个数组元素内容是否完全一致,如果是则返回true        Integer[] arr1 = &#123;1, 2, 90, 123, 567&#125;;        boolean bool = Arrays.equals(arr, arr1);        System.out.println(bool);        //asList 将一组值，转换成List, List是一个接口        List&lt;Integer&gt; asList = Arrays.asList(2, 3, 4, 5, 6, 1);        System.out.println(&quot;asList = &quot; + asList);    &#125;&#125;</code></pre><h2 id="System"><a href="#System" class="headerlink" title="System"></a>System</h2><p>1.exit退出当前程序</p><p>2.arraycopy：复制数组元素，比较适合底层调用，一般使用Arrays.copyOf完成复制数组</p><p>3.currentTimeMillens:返回当前时间距离1970-1-1的毫秒数</p><p>4.gc:运行垃圾回收机制System.gc();</p><h2 id="BigInteger和BigDecimal"><a href="#BigInteger和BigDecimal" class="headerlink" title="BigInteger和BigDecimal"></a>BigInteger和BigDecimal</h2><pre><code class="lang-java">package com.zzy.bignum_;import java.math.BigInteger;/** * @autho: 周钟炎 * @version: 1.0 */public class bigInteger &#123;    public static void main(String[] args) &#123;        //编程中处理很大的整数,用BigInteger        BigInteger bigInteger = new BigInteger(&quot;2321546576824343&quot;);        System.out.println(bigInteger);        //在对BigInteger进行加减乘除的时候，需要使用对应的方法，不能直接进行+ - * /        BigInteger bigInteger1 = new BigInteger(&quot;100&quot;);        BigInteger add = bigInteger.add(bigInteger1);        System.out.println(add);        BigInteger subtract = bigInteger.subtract(bigInteger1);        System.out.println(subtract);        BigInteger multiply = bigInteger.multiply(bigInteger1);        System.out.println(multiply);        BigInteger divide = bigInteger.divide(bigInteger1);        System.out.println(divide);    &#125;&#125;</code></pre><pre><code class="lang-java">package com.zzy.bignum_;import java.math.BigDecimal;import java.math.RoundingMode;/** * @autho: 周钟炎 * @version: 1.0 */public class bigDecimal_ &#123;    public static void main(String[] args) &#123;        //当我们需要保存一个精度很高的数时，double不够用        BigDecimal bigDecimal = new BigDecimal(&quot;0.3232545465665454325&quot;);        System.out.println(bigDecimal);        //再除以小数的时候，可能是一个无限循环的小数，会抛出异常        BigDecimal bigDecimal1 = new BigDecimal(&quot;3&quot;);        //在调用divide时，指定精度就可以        //如果有无限循环小数，就会保留分子的精度        bigDecimal = bigDecimal.divide(bigDecimal1, RoundingMode.CEILING);        System.out.println(bigDecimal);    &#125;&#125;</code></pre><h2 id="日期类"><a href="#日期类" class="headerlink" title="日期类"></a>日期类</h2><pre><code class="lang-java">package com.zzy.date_;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;/** * @autho: 周钟炎 * @version: 1.0 */public class Date01 &#123;    public static void main(String[] args) throws ParseException &#123;        //获取当前的系统时间        Date date = new Date();        System.out.println(&quot;当前日期 = &quot; + date);        //默认输出的日期格式是国外的        //用SimpleDateFormat改变的格式是规定好的        SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy年MM月dd日 hh:mm:ss E&quot;);        String format = simpleDateFormat.format(date);        System.out.println(format);        //也可以用构造器，输入毫秒数，但是时间是从1970年1月1号00:00开始的        Date date1 = new Date(321321);        System.out.println(date1);        //把字符串转成Date        String s = &quot;1996年01月01日 10:20:30 星期一&quot;;        Date parse = simpleDateFormat.parse(s);        System.out.println(simpleDateFormat.format(parse));    &#125;&#125;</code></pre><p>第二代时间</p><pre><code class="lang-java">package com.zzy.date_;import java.util.Calendar;/** * @autho: 周钟炎 * @version: 1.0 */public class Calender_ &#123;    public static void main(String[] args) &#123;        //Calender是一个抽象类,并且其构造器是受保护的        Calendar c = Calendar.getInstance();        //里面有很多字段，从中拿出相应的字段就好了        System.out.println(&quot;c = &quot; + c);        System.out.println(&quot;年:&quot; + c.get(Calendar.YEAR));        //返回月的时候是按照0开始编号的        System.out.println(&quot;月：&quot; + c.get(Calendar.MONTH) + 1);        System.out.println(&quot;日：&quot; + c.get(Calendar.DAY_OF_MONTH));        System.out.println(&quot;小时：&quot; + c.get(Calendar.HOUR));        System.out.println(&quot;24小时制：&quot; + c.get(Calendar.HOUR_OF_DAY));        System.out.println(&quot;分：&quot; + c.get(Calendar.MINUTE));        System.out.println(&quot;秒：&quot; + c.get(Calendar.SECOND));        //需要自己组合格式    &#125;&#125;</code></pre><p>第三代时间</p><pre><code class="lang-java">package com.zzy.date_;import java.time.LocalDate;import java.time.LocalDateTime;import java.time.LocalTime;import java.time.format.DateTimeFormatter;/** * @autho: 周钟炎 * @version: 1.0 */public class LocalTime_ &#123;    public static void main(String[] args) &#123;        LocalDateTime ldt = LocalDateTime.now();        System.out.println(ldt);        System.out.println(&quot;年:&quot; + ldt.getYear());        System.out.println(&quot;月：&quot; + ldt.getMonth());        System.out.println(&quot;月：&quot; + ldt.getMonthValue());        System.out.println(&quot;日：&quot; + ldt.getDayOfMonth());        System.out.println(&quot;时：&quot; + ldt.getHour());        System.out.println(&quot;分：&quot; + ldt.getMinute());        System.out.println(&quot;秒：&quot; + ldt.getSecond());        //获得年月日        LocalDate now = LocalDate.now();        //获取时分秒        LocalTime now2 = LocalTime.now();        //使用DateTimeFormatter对象进行格式化        DateTimeFormatter dtf = DateTimeFormatter.ofPattern(&quot;yyyy年MM月dd日 HH小时mm分钟ss秒 E&quot;);        String s = dtf.format(ldt);        System.out.println(s);        //加减时间        LocalDateTime ldt2 = ldt.plusDays(890);        System.out.println(dtf.format(ldt2));        LocalDateTime ldt3 = ldt.minusYears(2);        System.out.println(dtf.format(ldt3));    &#125;&#125;</code></pre><h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><p>保存多个数据时使用的是数组，而数组有不足的地方</p><p>数组</p><p>1.长度开始时必须指定，而且一旦指定，不能更改</p><p>2.保存的必须为同一类型的元素</p><p>3.增加或者删除元素比较麻烦</p><p>集合</p><p>1.可以动态保存任意多个对象，使用比较方便。</p><p>2.提供了一系列方便的操作对象的方法：add、remover、set、get</p><p>3.使用集合添加、删除新元素比较简单</p><p>集合主要分为2大类：</p><p>单列集合Collection</p><p>List: ArrayList、LinkedList、Vector</p><p>Set:HashSet、TreeSet</p><p>双列集合：</p><p>Map: HashMap、TreeMap、Hashtable、Properties</p><h2 id="List类的方法"><a href="#List类的方法" class="headerlink" title="List类的方法"></a>List类的方法</h2><pre><code class="lang-java">package com.zzy.collection_;import java.util.ArrayList;import java.util.Collection;import java.util.List;/** * @autho: 周钟炎 * @version: 1.0 */public class Collection01 &#123;    public static void main(String[] args) &#123;        List list = new ArrayList(); //动态绑定        //增加        list.add(&quot;jack&quot;);        list.add(10);        list.add(true);        System.out.println(list);        //删        list.remove(0);//删除第一个元素        list.remove(true);//删除某个元素        System.out.println(list);        //查找        System.out.println(list.contains(10));        //返回元素的个数        System.out.println(list.size());        //判断是否为空        System.out.println(list.isEmpty());        //清空//        list.clear();        //添加多个对象        ArrayList arrayList = new ArrayList();        arrayList.add(&quot;红楼梦&quot;);        arrayList.add(&quot;三国演义&quot;);        list.addAll(arrayList);        System.out.println(list);        //删除多个元素        list.removeAll(arrayList);        System.out.println(list);    &#125;&#125;</code></pre><p>实现了Iterable接口的可以采用迭代器的方式遍历</p><pre><code class="lang-java">package com.zzy.collection_;import java.util.ArrayList;import java.util.Iterator;/** * @autho: 周钟炎 * @version: 1.0 */public class CollectionIterator &#123;    public static void main(String[] args) &#123;        ArrayList arrayList = new ArrayList();        arrayList.add(new Book(&quot;三国演义&quot;, &quot;罗贯中&quot;, 19));        arrayList.add(new Book(&quot;红楼梦&quot;, &quot;曹雪芹&quot;, 20));        arrayList.add(new Book(&quot;西游记&quot;, &quot;吴世恩&quot;, 22));        System.out.println(arrayList);        //遍历        Iterator it = arrayList.iterator();        while (it.hasNext()) &#123;            //因为什么都能存，所以返回的是Object            Object obj = it.next();            System.out.println(obj); //动态绑定        &#125;        //如果想重新遍历，就要重置迭代器        it = arrayList.iterator();        while (it.hasNext()) &#123;            Object next =  it.next();            System.out.println(next);        &#125;    &#125;&#125;class Book &#123;    public String name;    public String author;    public double price;    public Book(String name, String author, double price) &#123;        this.name = name;        this.author = author;        this.price = price;    &#125;    @Override    public String toString() &#123;        return &quot;Book&#123;&quot; +                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +                &quot;, author=&#39;&quot; + author + &#39;\&#39;&#39; +                &quot;, price=&quot; + price +                &#39;&#125;&#39;;    &#125;&#125;</code></pre><p>==ctrl加J可以提示所有的快捷键==</p><p>List集合类中元素有序，且可重复。</p><p>List集合中的每个元素都有其对应的顺序索引</p><pre><code class="lang-java">package com.zzy.collection_;import java.util.ArrayList;import java.util.List;/** * @autho: 周钟炎 * @version: 1.0 */public class ListMethod &#123;    public static void main(String[] args) &#123;        List list = new ArrayList();        list.add(&quot;老黑&quot;);        list.add(&quot;大狗&quot;);        //在指定位置插入        list.add(1, &quot;大黄&quot;);        System.out.println(list);        //加入多个元素        List list1 = new ArrayList();        list1.add(&quot;lxc&quot;);        list1.add(&quot;zy&quot;);        list.addAll(1, list1);        System.out.println(list);        //替换        list.set(0, &quot;sy&quot;);        System.out.println(list);        //返回集合,返回的是一个前闭后开的范围        List returnlist = list.subList(0, 3);        System.out.println(returnlist);    &#125;&#125;</code></pre><p>ArrayList效率高,但是是线程不安全的</p><p>ArrayList源码</p><p>1.ArrayList中维护了一个Object类型的数组</p><p>2.当创建ArrayList对象时，如果使用的是无参构造器，则初始elementData容量为0，第一次添加，则扩容elementData为10，如需再次扩容，则扩容elmentData为1.5倍。</p><p>3.如果使用的是制定大小的构造器，则初始化elementData容量为指定大小，如果需要扩容，则直接扩容elementData为1.5倍。</p><p>transient //表示瞬间的、短暂的，表示该属性不会被序列号</p><p>Vector</p><p>1.Vector底层也是一个对象数组， protected Object[] elementData;</p><p>2.Vector是线程安全的</p><p>3.如果是无参，默认为10，满后，就按2倍扩容</p><p>LinkedList</p><p>1.LinkedList底层实现了双向链表和双端队列的特点</p><p>2.可以添加任意元素（元素可以重复），包括null</p><p>3.线程不安全，没有实现同步</p><p>LinkedList底层维护了一个双向链表，两个属性first和last分别指向首节点和尾结点</p><p>每个节点(Node对象)，里面又维护了prev、next、item三个属性，prev指向前一个，通过next指向后一个节点，最近实现双向链表。</p><p>比较方便添加和删除</p><pre><code class="lang-java">package com.zzy.collection_;/** * @autho: 周钟炎 * @version: 1.0 */public class LinkedList01 &#123;    public static void main(String[] args) &#123;        Node jack = new Node(&quot;jack&quot;);        Node tom = new Node(&quot;tom&quot;);        Node hsp = new Node(&quot;老韩&quot;);        //jack-&gt;tom-&gt;hsp        //连接三个结点        jack.next = tom;        tom.next = hsp;        //hsp-&gt;tom-&gt;jack        hsp.pre = tom;        tom.pre = jack;        Node first = jack;        Node last = hsp;        //从头到尾遍历        while (true) &#123;            if (first == null) &#123;//true                break;            &#125;            System.out.println(first);            first = first.next; //tom.next = null;        &#125;        //从尾到头遍历        while (true) &#123;            if (last == null) &#123;                break;            &#125;            System.out.println(last);            last = last.pre;        &#125;        //在tom和和老韩之间加入一个对象        Node zf = new Node(&quot;张飞&quot;);        tom.next = zf;        zf.next = hsp;        hsp.pre = zf;        zf.pre = tom;        first = jack;        while (true) &#123;            if (first == null) &#123;//true                break;            &#125;            System.out.println(first);            first = first.next; //tom.next = null;        &#125;    &#125;&#125;class Node &#123;    public Object item;    public Node next; //下一个节点    public Node pre; //前一个节点    public Node(Object item) &#123;        this.item = item;    &#125;    public String toString() &#123;        return &quot;Node name = &quot; + item;    &#125;&#125;</code></pre><pre><code class="lang-java">package com.zzy.collection_;import java.util.LinkedList;/** * @autho: 周钟炎 * @version: 1.0 */public class LinkedList02 &#123;    public static void main(String[] args) &#123;        LinkedList linkedList = new LinkedList();        linkedList.add(1);        linkedList.add(2);        linkedList.add(3);        System.out.println(linkedList);        linkedList.remove();        System.out.println(linkedList);        //修改某个节点对象        linkedList.set(1,999);        System.out.println(linkedList);        //得到某个节点对象        System.out.println(linkedList.get(0));    &#125;&#125;</code></pre><h2 id="Set类"><a href="#Set类" class="headerlink" title="Set类"></a>Set类</h2><p>1.无序（添加和取出的顺序不一致），没有索引</p><p>2.不允许重复的元素，所以最多包含一个null</p><p>HashSet:</p><p>1.HashSet底层是HashMap</p><p>2.添加一个元素时，先得到hash值，会转成-&gt;索引值</p><p>3.找到存储数据表table，看这个索引位置是否有已经存放的元素</p><p>4.如果没有，直接加入</p><p>5.如果有，调用equals比较，如果相同，就放弃添加，如果不相同，则添加到最后</p><p>6.在Java8中，如果一条链表的元素个数达到TREEIFT_THRESHOLD（默认为8），并且table的大小&gt;=MIN_TREEIFY_CAPACITY（默认64），就会进行树化（红黑树）</p><p>经典题：</p><pre><code class="lang-java">package com.zzy.set_;import java.util.HashSet;import java.util.Objects;/** * @autho: 周钟炎 * @version: 1.0 */public class HashSetExercise02 &#123;    public static void main(String[] args) &#123;        HashSet hashSet = new HashSet();        hashSet.add(new Employee_(&quot;zzy&quot;, 30000,                new Employee_().new MyDate(1998, 11, 24)));        hashSet.add(new Employee_(&quot;zzy&quot;, 30000,                new Employee_().new MyDate(1998, 11, 24)));        System.out.println(hashSet);    &#125;&#125;class Employee_ &#123;    private String name;    private double salary;    private MyDate birthday;    public Employee_(String name, double salary, MyDate birthday) &#123;        this.name = name;        this.salary = salary;        this.birthday = birthday;    &#125;    public Employee_()&#123;&#125;    class MyDate&#123;        private int year;        private int month;        private int day;        public MyDate(int year, int month, int day) &#123;            this.year = year;            this.month = month;            this.day = day;        &#125;        //通过内部类的hashCode和 equals的重写，套娃使其得到的hashCode依据birthday的内容决定        //而不是地址        @Override        public boolean equals(Object o) &#123;            if (this == o) return true;            if (o == null || getClass() != o.getClass()) return false;            MyDate myDate = (MyDate) o;            return year == myDate.year &amp;&amp; month == myDate.month &amp;&amp; day == myDate.day;        &#125;        @Override        public int hashCode() &#123;            return Objects.hash(year, month, day);        &#125;    &#125;    @Override    public boolean equals(Object o) &#123;        if (this == o) return true;        if (o == null || getClass() != o.getClass()) return false;        Employee_ employee_ = (Employee_) o;        return name.equals(employee_.name) &amp;&amp; birthday.equals(employee_.birthday);    &#125;    @Override    public int hashCode() &#123;        //这里的name是在常量池,但是要保证内部类的所影响的hashCode一致        return Objects.hash(name, birthday);    &#125;&#125;</code></pre><p>LinkedHashSet</p><p>1.在LinkedHashSet中维护了一个hash表和双向链表</p><p>2.在某个节点有before和after属性，这样可以形成双向链表</p><p>3.在添加一个元素时，先求hash值，再求索引，确定该元素在table的位置，然后将添加的元素加入到双向链接（如果已经存在，不添加【原则和hashset一样】</p><p>4.这样的话，我们遍历LinkedHashSet也能确保插入顺序和遍历顺序一致</p><p>里面HashMapNode里有内部类LinkedHashMapEntry</p><p>==其实set也是键值对的形式，但是其value是用一个常量填充的==</p><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><pre><code class="lang-java">package com.zzy.map_;import java.util.HashMap;import java.util.Map;/** * @autho: 周钟炎 * @version: 1.0 */@SuppressWarnings(&#123;&quot;all&quot;&#125;)public class Map_ &#123;    public static void main(String[] args) &#123;        //map接口实现类的特点        //1.保存具有映射关系的key-value        //无序的，因为底层还是hashMap        Map map = new HashMap();        map.put(&quot;No1&quot;, &quot;zzy&quot;);        map.put(&quot;No2&quot;, &quot;林动&quot;);        //当key相同的，会进行替换        map.put(&quot;No1&quot;, &quot;韩顺平&quot;);        //value值是可以重复的        map.put(&quot;No3&quot;, &quot;zzy&quot;);        System.out.println(&quot;map = &quot; + map);        //Map的key可以为null，value也可以为空，但是key的null只能有一个，value为null可以有多个        //key和value之间存在单向一对一关系，即通过指定的key总能找到对应的value        //通过get方法，传入key，得到相应的value        System.out.println(map.get(&quot;No1&quot;));    &#125;&#125;</code></pre><p>Map的源码解析</p><pre><code class="lang-java">package com.zzy.map_;import java.util.Collection;import java.util.HashMap;import java.util.Map;import java.util.Set;/** * @autho: 周钟炎 * @version: 1.0 */public class MapSource &#123;    public static void main(String[] args) &#123;        Map map = new HashMap();        map.put(&quot;no1&quot;, &quot;韩顺平&quot;);        map.put(&quot;no2&quot;, &quot;zzy&quot;);        //1.k-v是在HashMap$Node里面管理的        //2.k-v为了方便程序员的遍历，还会创建EntrySet集合，该集合存放的元素的类型是Entry        //3.entrySet中，定义的类型是Map.Entry, 但是实际上存放的还是HashMap$Node,这是因为Ha        //HashMap$Node implements Map.Entry        //4.当把HashMap$Node 对象放到entrySet 就方便我们遍历,因为Map.entry提供了重要方法        //getKey() 和 getValue()        Set set = map.entrySet();        for (Object obj : set) &#123;            Map.Entry entry = (Map.Entry) obj;            System.out.println(entry.getKey() + &quot;-&quot; + entry.getValue());        &#125;        //k值收集到了Set里  value收集到了 Collection        Set set1 = map.keySet();        //KeySet        System.out.println(set1.getClass());        Collection values = map.values();        //Values        System.out.println(values.getClass());    &#125;&#125;</code></pre><p>➢扩容机制[和HashSet相同]<br>1) HashMap底层维护了Node类型的数组table,默认为null<br>2)当创建对象时，将加载因子(loadfactor)初始化为0.75.<br>3) 当添加key-val时，通过key的哈希值得到在table的索引。然后判断该索引处是否有元素，<br>如果没有元素直接添加。如果该索引处有元素，继续判断该元素的key是否和准备加入的<br>key相等，如果相等，则直接替换val;如果不相等需要判断是树结构还是链表结构，做出<br>相应处理。如果添加时发现容量不够，则需要扩容。<br>4)第1次添加，则需要扩容table容量为16,临界值(threshold)为12.<br>5)以后再扩容，则需要扩容table容量为原来的2倍，临界值为原来的2倍,即24,依次类推.<br>6)在Java8中，如果一条链表的元素个数超过TREEIFY THRESHOLD(默认是8)，并且<br>table的大小&gt;= MIN TREEIFY CAPACITY(默认64),就会进行树化(红黑树)</p><hr><p>Map的接口和常用方法</p><pre><code class="lang-java">package com.zzy.map_;import java.util.HashMap;import java.util.Map;/** * @autho: 周钟炎 * @version: 1.0 */public class MapMethod &#123;    public static void main(String[] args) &#123;        Map map = new HashMap();        map.put(&quot;邓超&quot;, new Book(&quot;&quot;, 100));        map.put(&quot;王宝强&quot;, &quot;马蓉&quot;);        map.put(&quot;宋喆&quot;, &quot;马蓉&quot;);        map.put(&quot;邓超&quot;, &quot;孙俪&quot;);        map.put(null, &quot;刘亦菲&quot;);        System.out.println(&quot;map=&quot; +map );        //remove:根据键删除映射关系        map.remove(null);        System.out.println(&quot;map=&quot; +map );        //通过键获得值        Object val = map.get(&quot;王宝强&quot;);        System.out.println(&quot;value = &quot; + val);        //获取元素个数        System.out.println(&quot;size = &quot; + map.size());        //判断元素是否为空        System.out.println(map.isEmpty());        //清除l-v        map.clear();        //查找键是否存在        System.out.println(map.containsKey(&quot;邓超&quot;));    &#125;&#125;class Book &#123;    private String name;    private int num;    public Book(String name, int num) &#123;        this.name = name;        this.num = num;    &#125;&#125;</code></pre><p>Map的遍历</p><pre><code class="lang-java">package com.zzy.map_;import java.util.*;/** * @autho: 周钟炎 * @version: 1.0 */public class Mapfor &#123;    public static void main(String[] args) &#123;        Map map = new HashMap();        map.put(&quot;邓超&quot;, new Book(&quot;&quot;, 100));        map.put(&quot;王宝强&quot;, &quot;马蓉&quot;);        map.put(&quot;宋喆&quot;, &quot;马蓉&quot;);        map.put(&quot;邓超&quot;, &quot;孙俪&quot;);        map.put(null, &quot;刘亦菲&quot;);        Set keyset = map.keySet();        //第一组,通过key获取vales        for (Object o : keyset) &#123;            System.out.println(o + &quot;-&quot; + map.get(o));        &#125;        Iterator it = keyset.iterator();        while (it.hasNext()) &#123;            Object next =  it.next();            System.out.println(next + &quot;-&quot; + map.get(next));        &#125;        //第二组，取出所有的values        Collection values = map.values();        for (Object o : values) &#123;            System.out.println(o);        &#125;        Iterator it2= values.iterator();        while (it2.hasNext()) &#123;            Object next =  it2.next();            System.out.println(next);        &#125;        //通过EntrySet        Set set = map.entrySet();        for (Object o : set) &#123;            //向下转型            Map.Entry entry = (Map.Entry) o;            System.out.println(entry.getKey() + &quot;-&quot; + entry.getValue());        &#125;        Iterator it3 = set.iterator();        while (it3.hasNext()) &#123;            Object next =  it3.next();            Map.Entry entry = (Map.Entry) next;            System.out.println(entry.getKey() + &quot;-&quot; +entry.getValue());        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java面向对象&quot;&gt;&lt;a href=&quot;#Java面向对象&quot; class=&quot;headerlink&quot; title=&quot;Java面向对象&quot;&gt;&lt;/a&gt;Java面向对象&lt;/h1&gt;&lt;h2 id=&quot;接口&quot;&gt;&lt;a href=&quot;#接口&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="Java" scheme="https://zzygeo.cn/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="https://zzygeo.cn/2021/07/12/Java%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>https://zzygeo.cn/2021/07/12/Java%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-07-12T08:24:14.000Z</published>
    <updated>2021-07-13T08:32:50.595Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-单例模式"><a href="#1-单例模式" class="headerlink" title="1.单例模式"></a>1.单例模式</h1><p>饿汉式：</p><pre><code class="lang-java">package com.zzy.singel;public class Single01 &#123;    public static void main(String[] args) &#123;//        通过方法可以直接获取对象        GirlFriend instance01 = GirlFriend.getInstance();        System.out.println(instance01);    &#125;&#125;class GirlFriend &#123;    private String name;//为了能够在静态方法中，返回gf对象，需要将其设置为static    private  static GirlFriend gf = new GirlFriend(&quot;小红&quot;);//    设计模式--&gt;单例模式[饿汉式]//    如何只new一个girlfriend//    1.将构造器私有化//    2.在类的内部直接创建//    3.提供一个公共的static方法，返回gf对象//    这种对象一般都是重量级的对象，饿汉式可能造成资源浪费    private GirlFriend(String name) &#123;        this.name = name;    &#125;    public static GirlFriend getInstance() &#123;        return gf;    &#125;    @Override    public String toString() &#123;        return &quot;GirlFriend&#123;&quot; +                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +                &#39;&#125;&#39;;    &#125;&#125;</code></pre><p>饱汉式：</p><pre><code class="lang-java">package com.zzy.singel;public class single02 &#123;    public static void main(String[] args) &#123;        Cat cat = Cat.getInstance();        System.out.println(cat);    &#125;&#125;//希望在程序运行中，只能创建一个Cat对象//饱汉式的方法在调用类的属性的时候，不会创建对象，只有调用instance的时候才会创建对象class Cat &#123;    private String name;//  1.仍然将构造器私有化//  2.定义一个static静态属性对象//  3.提供一个public的static方法，可以返回一个Cat对象    private Cat(String name) &#123;        this.name = name;    &#125;    private static Cat cat;    public static Cat getInstance() &#123;        if (cat == null) &#123;            cat = new Cat(&quot;小白&quot;);        &#125;        return cat;    &#125;    @Override    public String toString() &#123;        return &quot;Cat&#123;&quot; +                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +                &#39;&#125;&#39;;    &#125;&#125;</code></pre><p>饿汉式VS饱汉式</p><p>1.二者最重要的区别在于创建对象的时机不同：饿汉式是在类加载的时候就创建了对象实例，而懒汉式是在使用时才创建。</p><p>2.饿汉式不存在线程安全问题，懒汉式存在线程安全问题。</p><p>3.饿汉式存在浪费资源的可能。如果程序员没有使用对象实例，那么饿汉式就会造成资源浪费，懒汉式是使用时才创建，不会存在这个问题。</p><p>4.在javaSE标准类中，java.lang.Runtime就是经典的单例模式。</p><h1 id="2-模板设计模式"><a href="#2-模板设计模式" class="headerlink" title="2.模板设计模式"></a>2.模板设计模式</h1><pre><code class="lang-java">package com.zzy.abstract_;public class TestTemplate &#123;    public static void main(String[] args) &#123;        AA aa = new AA();        aa.calculateTime();        BB bb = new BB();        bb.calculateTime();    &#125;&#125;</code></pre><p>父类</p><pre><code class="lang-java">package com.zzy.abstract_;abstract public class Template &#123;//抽象类-模板设计模式    public abstract void job();    public void calculateTime() &#123;        long start = System.currentTimeMillis();        job();//动态绑定机制        long end = System.currentTimeMillis();        System.out.println(&quot;执行时间 &quot; + (end - start));    &#125;&#125;</code></pre><p>子类AA</p><pre><code class="lang-java">package com.zzy.abstract_;public class AA extends Template &#123;    @Override    public void job() &#123;//实现了父类的抽象方法        int num = 0;        for (int i = 0; i &lt; 800000; i++) &#123;            num += i;        &#125;    &#125;&#125;</code></pre><p>子类BB</p><pre><code class="lang-java">package com.zzy.abstract_;public class BB extends Template &#123;    @Override    public void job() &#123;//这个类也重写了父类的方法        int num = 0;        for (int i = 1; i &lt; 80000 ; i++) &#123;            num *= i;        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-单例模式&quot;&gt;&lt;a href=&quot;#1-单例模式&quot; class=&quot;headerlink&quot; title=&quot;1.单例模式&quot;&gt;&lt;/a&gt;1.单例模式&lt;/h1&gt;&lt;p&gt;饿汉式：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-java&quot;&gt;package com.zzy.</summary>
      
    
    
    
    <category term="Java" scheme="https://zzygeo.cn/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>摄影测量</title>
    <link href="https://zzygeo.cn/2021/06/29/C++/%E6%91%84%E5%BD%B1%E6%B5%8B%E9%87%8F/"/>
    <id>https://zzygeo.cn/2021/06/29/C++/%E6%91%84%E5%BD%B1%E6%B5%8B%E9%87%8F/</id>
    <published>2021-06-29T04:23:30.000Z</published>
    <updated>2021-06-29T04:49:31.250Z</updated>
    
    <content type="html"><![CDATA[<h1 id="三方库"><a href="#三方库" class="headerlink" title="三方库"></a>三方库</h1><p>Eigen、Ceres Solver、opencv等</p><h1 id="main-cpp"><a href="#main-cpp" class="headerlink" title="main.cpp"></a>main.cpp</h1><pre><code class="lang-c++">#include &quot;image.h&quot;;#include &quot;file_io.h&quot;#include &quot;space_resection.h&quot;#include &quot;feature_matching.h&quot;#include &quot;image_orientation.h&quot;#include &quot;forward_intersection.h&quot;int main() &#123;    /*Image img;    vector&lt;Vector3d&gt; Pts;    vector&lt;Vector2d&gt; pts;    readImageInfoFromTxt(&quot;D:\\documents\\Photogrammetry\\task1\\Practice\\ImgInfo_example.txt&quot;, img, Pts, pts);    img.print();    SpaceResection resection;    //resection.EulerAngleMethod(img, Pts, pts);    resection.useCeres(img, Pts, pts);*/    Image imgL;    if (!imgL.readImgData(&quot;D:\\documents\\Photogrammetry\\task1\\images\\_MG_1813.JPG&quot;)) &#123;        return 0;    &#125;    FeatureDetection fdetection;    vector&lt;KeyPoint&gt; keypoints1;    Mat description1;    clock_t time0 = clock();    //fdetection.Harris(imgL.mat_, keypoints1, description1, 2, 3, 0.05, 0.85);    //fdetection.Sift(imgL.mat_, keypoints1, description1);    fdetection.Surf(imgL.mat_, keypoints1, description1, 400);    clock_t time1 = clock();    cout &lt;&lt; &quot;Totally &quot; &lt;&lt; keypoints1.size() &lt;&lt; &quot; key points detected.\n&quot;;    cout &lt;&lt; &quot;Feature detection takes time: &quot; &lt;&lt; (time1 - time0) / 1000.0 &lt;&lt; &quot; s.\n&quot;;    fdetection.showFeature(imgL.mat_, keypoints1);    cv::waitKey(0);    /*Image imgR;    if (!imgR.readImgData(&quot;D:\\documents\\Photogrammetry\\task1\\images\\_MG_1814.JPG&quot;)) &#123;        return 0;    &#125;    IO io;    io.focal_ = 51.6962;    io.cx_ = 4312.66;    io.cy_ = 2911.24;    io.k1_ = -0.168583;    io.k2_ = 0.316329;    io.k3_ = 0.434715;    io.p1_ = -0.00030953;    io.p2_ = 0.000414809;    imgL.io_ = imgR.io_ = io;    imgL.pixel_size_ = imgR.pixel_size_ = 0.00414;    FeatureDetection fdetection;    vector&lt;KeyPoint&gt; keypoints1, keypoints2;    Mat description1, description2;    clock_t time_start = clock();    fdetection.Surf(imgL.mat_, keypoints1, description1, 400);    fdetection.Surf(imgR.mat_, keypoints2, description2, 400);    FeatureMatching fmatching;    vector&lt;DMatch&gt; matches;    fmatching.FLANN_based(description1, description2, matches, 0.7);    vector&lt;Vector2d&gt; pixelPtsL(matches.size()), pixelPtsR(matches.size());    for (int i = 0; i &lt; matches.size(); i++) &#123;        pixelPtsL[i] = Vector2d(keypoints1[matches[i].queryIdx].pt.x, keypoints1[matches[i].queryIdx].pt.y);        pixelPtsR[i] = Vector2d(keypoints2[matches[i].trainIdx].pt.x, keypoints2[matches[i].trainIdx].pt.y);    &#125;    //相对定向    RelativeOrientation ro;    Mat rR;    Vector3d rT;    ro.cv(imgL, imgR, pixelPtsL, pixelPtsR, rR, rT);    //用相对定向结果计算三维点坐标    vector&lt;Point3d&gt; space_pts;    Mat mask;    Mat RcvL = (cv::Mat_&lt;double&gt;(3, 3) &lt;&lt; 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0);    Mat TcvL = Mat::zeros(3, 1, CV_64FC1);    Mat RcvR, TcvR;    rR.copyTo(RcvR);    TcvR = (cv::Mat_&lt;double&gt;(3, 1) &lt;&lt; rT.x(), rT.y(), rT.z());    ForwardIntersection forIntersection;    forIntersection.cv(imgL, imgR, RcvL, RcvR, TcvL, TcvR, pixelPtsL, pixelPtsR, space_pts, mask);    string path = &quot;D:\\documents\\libraries\\3dviewer\\structure.yml&quot;;    std::vector&lt;Mat&gt; Rs, Ts;    Rs.push_back(RcvL);    Rs.push_back(RcvR);    Ts.push_back(TcvL);    Ts.push_back(TcvR);    save_structure(path, Rs, Ts, space_pts, mask);*/&#125;</code></pre><h1 id="file-io-h"><a href="#file-io-h" class="headerlink" title="file_io.h"></a>file_io.h</h1><pre><code class="lang-c++">#pragma once#include &quot;image.h&quot;#include &lt;fstream&gt;int readImageInfoFromTxt(const string&amp; path, Image&amp; img, vector&lt;Vector3d&gt;&amp; Pts, vector&lt;Vector2d&gt;&amp; pts) &#123;    ifstream infile(path, ios::in);    if (!infile.is_open()) &#123;        cout &lt;&lt; &quot;Lol,failed to open Txt!&quot;;        return 0;    &#125;    while (!infile.eof()) &#123;        string str;        infile &gt;&gt; str;        if (str == &quot;ImagePath&quot;) &#123;            string img_path;            infile &gt;&gt; img_path;            img.path_ = img_path;        &#125;        else if (str == &quot;width&quot;)            infile &gt;&gt; img.width_;        else if (str == &quot;height&quot;)            infile &gt;&gt; img.height_;        else if (str == &quot;pixel_size&quot;)            infile &gt;&gt; img.pixel_size_;        else if (str == &quot;focal_length&quot;)            infile &gt;&gt; img.io_.focal_;        else if (str == &quot;principle_point&quot;)            infile &gt;&gt; img.io_.cx_ &gt;&gt; img.io_.cy_;        else if (str == &quot;distortions&quot;)            infile &gt;&gt; img.io_.k1_ &gt;&gt; img.io_.k2_ &gt;&gt; img.io_.k3_ &gt;&gt; img.io_.p1_ &gt;&gt; img.io_.p2_;        else if (str == &quot;Points&quot;) &#123;            int num;            infile &gt;&gt; num;            Pts.resize(num);            pts.resize(num);            for (int i = 0; i &lt; num; i++)                infile &gt;&gt; Pts[i].x() &gt;&gt; Pts[i].y() &gt;&gt; Pts[i].z() &gt;&gt; pts[i].x() &gt;&gt; pts[i].y();            break;        &#125;    &#125;    infile.close();    return 1;&#125;</code></pre><h1 id="image-h"><a href="#image-h" class="headerlink" title="image.h"></a>image.h</h1><pre><code class="lang-c++">#pragma once#include &lt;opencv2/core/core.hpp&gt;#include &lt;opencv2/imgcodecs.hpp&gt;#include &lt;opencv2/highgui.hpp&gt;#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;Eigen/Core&gt;#include &lt;vector&gt;using namespace Eigen;using namespace cv;using namespace std;struct IO &#123;    float focal_; //像主距    float cx_; //像主点x,单位为像素    float cy_; //像主点y，单位为像素    float k1_;    float k2_;    float k3_;    float p1_;    float p2_;&#125;;struct EO &#123;    MatrixXd R_;    MatrixXd T_;&#125;;class Image &#123;public:    //无参构造函数    Image() &#123;        width_ = 0;        height_ = 0;        pixel_size_ = 0;        io_.focal_ = 35;        io_.cx_ = 0;        io_.cy_ = 0;        io_.k1_ = io_.k2_ = io_.k3_ = io_.p1_ = io_.p2_ = 0.0;        eo_.R_ = MatrixXd::Ones(3, 3);        eo_.T_ = MatrixXd::Ones(3, 1);    &#125;    //有参构造函数    Image(const int&amp; width, const int&amp; height, const float&amp; pixel_size) &#123;        width_ = width;        height_ = height;        pixel_size_ = pixel_size;        io_.focal_ = 35;        io_.cx_ = (width - 1) / 2;        io_.cy_ = (height - 1) / 2;        io_.k1_ = io_.k2_ = io_.k3_ = io_.p1_ = io_.p2_ = 0.0;        eo_.R_ = MatrixXd::Ones(3, 3);        eo_.T_ = MatrixXd::Ones(3, 1);    &#125;    //属性值public:    //影像文件路径    string path_ = &quot;&quot;;    //影像基本参数    int width_;    int height_;    float pixel_size_; //单位为mm    //内参    IO io_;    //外参    EO eo_;    Mat mat_;public:    void print() &#123;        cout &lt;&lt; &quot;width: &quot; &lt;&lt; width_ &lt;&lt; endl            &lt;&lt; &quot;height: &quot; &lt;&lt; height_ &lt;&lt; endl            &lt;&lt; &quot;pixel size: &quot; &lt;&lt; pixel_size_ &lt;&lt; endl            &lt;&lt; &quot;focal length: &quot; &lt;&lt; io_.focal_ &lt;&lt; endl            &lt;&lt; &quot;principle point: &quot; &lt;&lt; io_.cx_ &lt;&lt; &quot;, &quot; &lt;&lt; io_.cy_ &lt;&lt; endl            &lt;&lt; &quot;distortion params: &quot; &lt;&lt; io_.k1_ &lt;&lt; &quot; &quot; &lt;&lt; io_.k2_ &lt;&lt; &quot; &quot; &lt;&lt; io_.k3_ &lt;&lt; &quot; &quot; &lt;&lt; io_.p1_ &lt;&lt; &quot; &quot; &lt;&lt; io_.p2_ &lt;&lt; endl            &lt;&lt; &quot;position: &quot; &lt;&lt; eo_.T_(0, 0) &lt;&lt; &quot; &quot; &lt;&lt; eo_.T_(1, 0) &lt;&lt; &quot; &quot; &lt;&lt; eo_.T_(2, 0) &lt;&lt; endl            &lt;&lt; &quot;rotation: &quot; &lt;&lt; endl            &lt;&lt; eo_.R_(0, 0) &lt;&lt; &quot; &quot; &lt;&lt; eo_.R_(0, 1) &lt;&lt; &quot; &quot; &lt;&lt; eo_.R_(0, 2) &lt;&lt; endl            &lt;&lt; eo_.R_(1, 0) &lt;&lt; &quot; &quot; &lt;&lt; eo_.R_(1, 1) &lt;&lt; &quot; &quot; &lt;&lt; eo_.R_(1, 2) &lt;&lt; endl            &lt;&lt; eo_.R_(2, 0) &lt;&lt; &quot; &quot; &lt;&lt; eo_.R_(2, 1) &lt;&lt; &quot; &quot; &lt;&lt; eo_.R_(2, 2) &lt;&lt; endl;    &#125;    //将像点由像素坐标转换为像平面坐标    void pixelpoints2imagepoints(const vector&lt;Vector2d&gt;&amp; pixelPts, vector&lt;Vector2d&gt;&amp; imgPts);    MatrixXd getRotationfromAngles(const double&amp; phi, const double&amp; omega, const double&amp; kappa);    int readImgData(const string&amp; filepath) &#123;        mat_ = imread(filepath); //读文件        if (mat_.data == NULL) &#123;//测试影像是否打开            cout &lt;&lt; &quot;Failed to read the image file.\n&quot;;            return 0;        &#125;        path_ = filepath;        width_ = mat_.cols;        height_ = mat_.rows;    &#125;    void showImg() &#123;        if (mat_.data == NULL) &#123;            cout &lt;&lt; &quot;No image data.\n&quot;;            return;        &#125;        Mat img_show;        mat_.copyTo(img_show);        namedWindow(path_, CV_WINDOW_NORMAL);        resizeWindow(path_, 960, int(height_ * 960.0 / width_));        moveWindow(path_, 100, 100);        imshow(path_, img_show);    &#125;&#125;;int save_structure(    const string&amp; savepath,    const std::vector&lt;Mat&gt;&amp; Rs,    const std::vector&lt;Mat&gt;&amp; Ts,    const std::vector&lt;Point3d&gt;&amp; points,    const Mat&amp; mask);</code></pre><h1 id="image-cpp"><a href="#image-cpp" class="headerlink" title="image.cpp"></a>image.cpp</h1><pre><code class="lang-c++">#include &quot;image.h&quot;#include &lt;vector&gt;void Image::pixelpoints2imagepoints(const vector&lt;Vector2d&gt;&amp; pixelPts, vector&lt;Vector2d&gt;&amp; imgPts) &#123;    double pix_size = pixel_size_ / 1000.0;    imgPts.resize(pixelPts.size());    for (int i = 0; i &lt; pixelPts.size(); i++) &#123;        double u = pixelPts[i].x();        double v = pixelPts[i].y();        double x = (u - io_.cx_) * pix_size;        double y = -(v - io_.cy_) * pix_size;        double r2 = x * x + y * y;        double r4 = r2 * r2;        double r6 = r2 * r4;        imgPts[i].x() = x + x * (io_.k1_ * r2 + io_.k2_ * r4 + io_.k3_ * r6) + io_.p1_ * (r2 + 2 * x * x) + 2 * io_.p2_ * x * y;        imgPts[i].y() = y + y * (io_.k1_ * r2 + io_.k2_ * r4 + io_.k3_ * r6) + io_.p1_ * (r2 + 2 * y * y) + 2 * io_.p2_ * x * y;    &#125;&#125;MatrixXd Image::getRotationfromAngles(const double&amp; phi, const double&amp; omega, const double&amp; kappa) &#123;    eo_.R_(0, 0) = cos(phi) * cos(kappa) - sin(phi) * sin(omega) * sin(kappa);    eo_.R_(0, 1) = -cos(phi) * sin(kappa) - sin(phi) * sin(omega) * cos(kappa);    eo_.R_(0, 2) = -sin(phi) * cos(omega);    eo_.R_(1, 0) = cos(omega) * sin(kappa);    eo_.R_(1, 1) = cos(omega) * cos(kappa);    eo_.R_(1, 2) = -sin(omega);    eo_.R_(2, 0) = sin(phi) * cos(kappa) + cos(phi) * sin(omega) * sin(kappa);    eo_.R_(2, 1) = -sin(phi) * sin(kappa) + cos(phi) * sin(omega) * cos(kappa);    eo_.R_(2, 2) = cos(phi) * cos(omega);    return eo_.R_;&#125;int save_structure(    const string&amp; savepath,    const std::vector&lt;Mat&gt;&amp; Rs,    const std::vector&lt;Mat&gt;&amp; Ts,    const std::vector&lt;Point3d&gt;&amp; points,    const Mat&amp; mask) &#123;    int n = (int)Rs.size();    FileStorage fs(savepath, FileStorage::WRITE);    if (!fs.isOpened())        return 0;    fs &lt;&lt; &quot;Camera Count&quot; &lt;&lt; n;    fs &lt;&lt; &quot;Point Count&quot; &lt;&lt; (int)points.size();    fs &lt;&lt; &quot;Rotations&quot; &lt;&lt; &quot;[&quot;;    for (size_t i = 0; i &lt; n; ++i) &#123;        if (Rs[i].empty())            fs &lt;&lt; cv::Mat::zeros(3, 3, CV_64FC1);        else            //fs &lt;&lt; Rs[i].inv();            fs &lt;&lt; Rs[i];    &#125;    fs &lt;&lt; &quot;]&quot;;    fs &lt;&lt; &quot;Motions&quot; &lt;&lt; &quot;[&quot;;    for (size_t i = 0; i &lt; n; ++i)    &#123;        if (Ts[i].empty() || Rs[i].empty())            fs &lt;&lt; cv::Mat::zeros(3, 1, CV_64FC1);        else            //fs &lt;&lt; -Rs[i].inv() * Ts[i];            fs &lt;&lt; Ts[i];    &#125;    fs &lt;&lt; &quot;]&quot;;    fs &lt;&lt; &quot;Points&quot; &lt;&lt; &quot;[&quot;;    for (size_t i = 0; i &lt; points.size(); ++i)    &#123;        fs &lt;&lt; points[i];    &#125;    fs &lt;&lt; &quot;]&quot;;    fs &lt;&lt; &quot;Colors&quot; &lt;&lt; &quot;[&quot;;    for (size_t i = 0; i &lt; points.size(); ++i)    &#123;        if (mask.at&lt;uchar&gt;(i) &gt; 0)            fs &lt;&lt; Vec3b(255, 255, 0);        else            fs &lt;&lt; Vec3b(0, 0, 255);    &#125;    fs &lt;&lt; &quot;]&quot;;    fs.release();    return 1;&#125;</code></pre><h1 id="space-resection-h"><a href="#space-resection-h" class="headerlink" title="space_resection.h"></a>space_resection.h</h1><pre><code class="lang-c++">#pragma once#include &quot;image.h&quot;class SpaceResection &#123;public:    int EulerAngleMethod(Image img, const vector&lt;Vector3d&gt;&amp; Pts, const vector&lt;Vector2d&gt;&amp; pts);    int useCeres(Image&amp; img, const vector&lt;Vector3d&gt;&amp; Pts, const vector&lt;Vector2d&gt;&amp; pts);&#125;;</code></pre><h1 id="space-resection-cpp"><a href="#space-resection-cpp" class="headerlink" title="space_resection.cpp"></a>space_resection.cpp</h1><pre><code class="lang-c++">#include &quot;space_Resection.h&quot;#include&lt;cmath&gt;#include&lt;Eigen/LU&gt;#include &lt;ceres/ceres.h&gt;#include &lt;glog/logging.h&gt;#ifdef max#undef max#endif //max#ifdef min#undef min#endif //minconstexpr auto G_ERROR = 1e-3;        //平移坐标改正值阈值constexpr auto A_ERROR = 1e-7;        //旋转角改正值阈值static double f_ = 50;struct EulerAngleBackCrossResidual&#123;    /*    X,Y,Z,x,y分别为观测值    */    EulerAngleBackCrossResidual(double X, double Y, double Z, double x, double y)        : X_(X), Y_(Y), Z_(Z), x_(x), y_(y) &#123;&#125;;    template &lt;class T&gt;    bool operator()(const T* const pBackCrossParameters, T* residual) const &#123;        T dXs = pBackCrossParameters[0];        T dYs = pBackCrossParameters[1];        T dZs = pBackCrossParameters[2];        T dPhi = pBackCrossParameters[3];        T dOmega = pBackCrossParameters[4];        T dKappa = pBackCrossParameters[5];        T a1 = ceres::cos(dPhi) * ceres::cos(dKappa) - ceres::sin(dPhi) * ceres::sin(dOmega) * ceres::sin(dKappa);        T a2 = -ceres::cos(dPhi) * ceres::sin(dKappa) - ceres::sin(dPhi) * ceres::sin(dOmega) * ceres::cos(dKappa);        T a3 = -ceres::sin(dPhi) * ceres::cos(dOmega);        T b1 = ceres::cos(dOmega) * ceres::sin(dKappa);        T b2 = ceres::cos(dOmega) * ceres::cos(dKappa);        T b3 = -ceres::sin(dOmega);        T c1 = ceres::sin(dPhi) * ceres::cos(dKappa) + ceres::cos(dPhi) * ceres::sin(dOmega) * ceres::sin(dKappa);        T c2 = -ceres::sin(dPhi) * ceres::sin(dKappa) + ceres::cos(dPhi) * ceres::sin(dOmega) * ceres::cos(dKappa);        T c3 = ceres::cos(dPhi) * ceres::cos(dOmega);        T XX = a1 * (X_ - dXs) + b1 * (Y_ - dYs) + c1 * (Z_ - dZs);        T YY = a2 * (X_ - dXs) + b2 * (Y_ - dYs) + c2 * (Z_ - dZs);        T ZZ = a3 * (X_ - dXs) + b3 * (Y_ - dYs) + c3 * (Z_ - dZs);        //有两个残差        residual[0] = T(x_) + T(f_) * XX / ZZ;        residual[1] = T(y_) + T(f_) * YY / ZZ;        return true;    &#125;private:    const double X_;    const double Y_;    const double Z_;    const double x_;    const double y_;&#125;;int SpaceResection::EulerAngleMethod(Image img, const vector&lt;Vector3d&gt;&amp; Pts, const vector&lt;Vector2d&gt;&amp; pts) &#123;    //计算外方位元素初始值    int Num = max(3.0, pts.size() / 2.0);//用一般的点进行空间后方交会计算，另一半进行精度验证    vector&lt;Vector2d&gt; imgPts;    img.pixelpoints2imagepoints(pts, imgPts);    double f = img.io_.focal_ / 1000.0;    //估算摄影比例尺    double GS = 0, SS = 0;    for (int i = 0; i &lt; Num - 1; i++) &#123;        GS += (Pts[i] - Pts[i + 1]).norm();        SS += (imgPts[i] - imgPts[i + 1]).norm();    &#125;    double lfScale = GS / SS;    //估算外方位元素初始值    double Xs = 0, Ys = 0, Zs = 0, phi = 0, omega = 0, kappa = 0;    for (int i = 0; i &lt; Num; i++) &#123;        Xs += Pts[i].x();        Ys += Pts[i].y();        Zs += Pts[i].z();    &#125;    Xs /= Num;    Ys /= Num;    Zs /= Num;    Zs += f * lfScale;    double fSANGLE = atan2((imgPts[1] - imgPts[0]).y(), (imgPts[1] - imgPts[0]).x());    double fGANGLE = atan2((Pts[1] - Pts[0]).y(), (Pts[1] - Pts[0]).x());    kappa = fSANGLE - fGANGLE;    MatrixXd B = MatrixXd(2 * Num, 6);    MatrixXd L = MatrixXd(2 * Num, 1);    MatrixXd Delta = MatrixXd::Ones(6, 1);    int iterationNum = 0;    do &#123;        //误差方程        MatrixXd R = img.getRotationfromAngles(phi, omega, kappa);        for (int i = 0; i &lt; Num; i++) &#123;            MatrixXd P = MatrixXd(3, 1);            P(0, 0) = Pts[i].x() - Xs;            P(1, 0) = Pts[i].y() - Ys;            P(2, 0) = Pts[i].z() - Zs;            MatrixXd PP = R.transpose() * P;            double x = imgPts[i].x();            double y = imgPts[i].y();            //double x = -f * PP(0,0) / PP(2, 0)            //double y = -f * PP(1, 0) / PP(2,0)            double b11 = (R(0, 0) * f + R(0, 2) * x) / PP(2, 0);            double b12 = (R(1, 0) * f + R(1, 2) * x) / PP(2, 0);            double b13 = (R(2, 0) * f + R(2, 2) * x) / PP(2, 0);            double b14 = y * sin(omega) - (x / f * (x * cos(kappa) - y * sin(kappa)) + f * cos(kappa)) * cos(omega);            double b15 = -f * sin(kappa) - x / f * (x * sin(kappa) + y * cos(kappa));            double b16 = y;            double b21 = (R(0, 1) * f + R(0, 2) * y) / PP(2, 0);            double b22 = (R(1, 1) * f + R(1, 2) * y) / PP(2, 0);            double b23 = (R(2, 1) * f + R(2, 2) * y) / PP(2, 0);            double b24 = -x * sin(omega) - (y / f * (x * cos(kappa) - y * sin(kappa)) - f * sin(kappa)) * cos(omega);            double b25 = -f * cos(kappa) - y / f * (x * sin(kappa) + y * cos(kappa));            double b26 = -x;            double xx = -f * PP(0, 0) / PP(2, 0);            double yy = -f * PP(1, 0) / PP(2, 0);            B(i * 2 + 0, 0) = b11; B(i * 2 + 0, 1) = b12; B(i * 2 + 0, 2) = b13;            B(i * 2 + 0, 3) = b14; B(i * 2 + 0, 4) = b15; B(i * 2 + 0, 5) = b16;            B(i * 2 + 1, 0) = b21; B(i * 2 + 1, 1) = b22; B(i * 2 + 1, 2) = b23;            B(i * 2 + 1, 3) = b24; B(i * 2 + 1, 4) = b25; B(i * 2 + 1, 5) = b26;            L(i * 2 + 0, 0) = imgPts[i].x() - xx;            L(i * 2 + 1, 0) = imgPts[i].y() - yy;        &#125;        cout &lt;&lt; &quot;********** iteration num:&quot; &lt;&lt; iterationNum &lt;&lt; &quot;*****************&quot; &lt;&lt; endl;        cout &lt;&lt; &quot;B: &quot; &lt;&lt; endl &lt;&lt; B &lt;&lt; endl &lt;&lt; &quot;-----------------&quot; &lt;&lt; endl;        cout &lt;&lt; &quot;L: &quot; &lt;&lt; endl &lt;&lt; L &lt;&lt; endl &lt;&lt; &quot;-----------------&quot; &lt;&lt; endl;        MatrixXd BT = B.transpose();        MatrixXd BTB = BT * B;        MatrixXd BTBinv = BTB.inverse();        Delta = BTBinv * (BT * L);        cout &lt;&lt; &quot;Delta: &quot; &lt;&lt; endl &lt;&lt; Delta &lt;&lt; endl &lt;&lt; endl;        //修正外方位元素        Xs += Delta(0, 0);        Ys += Delta(1, 0);        Zs += Delta(2, 0);        phi += Delta(3, 0);        omega += Delta(4, 0);        kappa += Delta(5, 0);        iterationNum++;    &#125; while ((fabs(Delta(0, 0)) &gt; G_ERROR || fabs(Delta(1, 0)) &gt; G_ERROR || fabs(Delta(2, 0)) &gt; G_ERROR ||        fabs(Delta(3, 0)) &gt; A_ERROR || fabs(Delta(4, 0)) &gt; A_ERROR || fabs(Delta(5, 0)) &gt; A_ERROR)        &amp;&amp; iterationNum &lt; 1000);    //计算单位权中误差    MatrixXd v = B * Delta - L;    cout &lt;&lt; &quot;v: &quot; &lt;&lt; endl &lt;&lt; v &lt;&lt; endl &lt;&lt; &quot;--------------&quot; &lt;&lt; endl;    MatrixXd s = v.transpose() * v;    double m0 = sqrtf(s(0, 0) / (2 * Num - 6));    cout &lt;&lt; &quot;--------------单位权中误差 m0= &quot; &lt;&lt; m0 &lt;&lt; &quot;--------------------&quot; &lt;&lt; endl;    img.eo_.T_(0, 0) = Xs;    img.eo_.T_(1, 0) = Ys;    img.eo_.T_(2, 0) = Zs;    //验证    MatrixXd R = img.getRotationfromAngles(phi, omega, kappa);    for (int i = 0; i &lt; Pts.size(); i++) &#123;        double x = imgPts[i].x();        double y = imgPts[i].y();        MatrixXd P = MatrixXd(3, 1);        P(0, 0) = Pts[i].x() - Xs;        P(1, 0) = Pts[i].y() - Ys;        P(2, 0) = Pts[i].z() - Zs;        MatrixXd PP = R.transpose() * P;        double xx = -f * PP(0, 0) / PP(2, 0);        double yy = -f * PP(1, 0) / PP(2, 0);        double du = (x - xx) / img.pixel_size_;        double dv = (y - yy) / img.pixel_size_;        if (i &gt;= Num)            cout &lt;&lt; &quot;check points: --------------&quot; &lt;&lt; endl;        cout &lt;&lt; &quot;point &quot; &lt;&lt; i &lt;&lt; &quot;: dx=&quot; &lt;&lt; du &lt;&lt; &quot;,  dy=&quot; &lt;&lt; dv &lt;&lt; &quot; error = &quot; &lt;&lt; sqrtf(du * du + dv * dv) &lt;&lt; &quot; pixels &quot;            &lt;&lt; endl &lt;&lt; &quot;----------------&quot; &lt;&lt; endl;    &#125;    cout &lt;&lt; &quot;Position: &quot;;    cout &lt;&lt; img.eo_.T_(0, 0) &lt;&lt; &quot;, &quot; &lt;&lt; img.eo_.T_(1, 0) &lt;&lt; &quot;, &quot; &lt;&lt; img.eo_.T_(2, 0) &lt;&lt; endl;    cout &lt;&lt; &quot;Rotation: &quot; &lt;&lt; endl &lt;&lt; img.eo_.R_;    return 1;&#125;int SpaceResection::useCeres(Image&amp; img, const vector&lt;Vector3d&gt;&amp; Pts, const vector&lt;Vector2d&gt;&amp; pts) &#123;    //计算外方位元素初始值    int Num = max(3.0, pts.size() / 2.0);//用一般的点进行空间后方交会计算，另一半进行精度验证    vector&lt;Vector2d&gt; imgPts;    img.pixelpoints2imagepoints(pts, imgPts);    double f = img.io_.focal_ / 1000.0;    //估算摄影比例尺     double GS = 0, SS = 0;    for (int i = 0; i &lt; Num - 1; i++) &#123;        GS += (Pts[i] - Pts[i + 1]).norm();        SS += (imgPts[i] - imgPts[i + 1]).norm();    &#125;    double lfScale = GS / SS;    //估算外方位元素初始值    double Xs = 0, Ys = 0, Zs = 0, phi = 0, omega = 0, kappa = 0;    for (int i = 0; i &lt; Num; i++) &#123;        Xs += Pts[i].x();        Ys += Pts[i].y();        Zs += Pts[i].z();    &#125;    Xs /= Num;    Ys /= Num;    Zs /= Num;    Zs += f * lfScale;    double fSANGLE = atan2((imgPts[1] - imgPts[0]).y(), (imgPts[1] - imgPts[0]).x());    double fGANGLE = atan2((Pts[1] - Pts[0]).y(), (Pts[1] - Pts[0]).x());    kappa = fSANGLE - fGANGLE;    MatrixXd B = MatrixXd(2 * Num, 6);    MatrixXd L = MatrixXd(2 * Num, 1);    MatrixXd Delta = MatrixXd::Ones(6, 1);    //利用Ceres Solver计算外方位元素    f_ = f;    double dBackCrossParameters[6] = &#123; Xs, Ys, Zs, phi, omega, kappa &#125;;    ceres::Problem problem;    for (int i = 0; i &lt; Num; i++) &#123;        EulerAngleBackCrossResidual* pResidual =            new EulerAngleBackCrossResidual(Pts[i].x(), Pts[i].y(), Pts[i].z(), imgPts[i].x(), imgPts[i].y());        problem.AddResidualBlock(            new ceres::AutoDiffCostFunction&lt;EulerAngleBackCrossResidual, 2, 6&gt;(pResidual),            NULL, dBackCrossParameters);    &#125;    ceres::Solver::Options m_options;    ceres::Solver::Summary m_summary;    m_options.max_num_iterations = 1000;    m_options.linear_solver_type = ceres::DENSE_QR;    m_options.minimizer_progress_to_stdout = true;    ceres::Solve(m_options, &amp;problem, &amp;m_summary);    cout &lt;&lt; &quot;-------------------------------&quot; &lt;&lt; endl;    cout.precision(10);    cout &lt;&lt; m_summary.BriefReport() &lt;&lt; &quot;\n&quot;;    img.eo_.T_(0, 0) = dBackCrossParameters[0];    img.eo_.T_(1, 0) = dBackCrossParameters[1];    img.eo_.T_(2, 0) = dBackCrossParameters[2];    //验证    MatrixXd R = img.getRotationfromAngles(dBackCrossParameters[3], dBackCrossParameters[4], dBackCrossParameters[5]);    for (int i = Num; i &lt; Pts.size(); i++) &#123;        double x = imgPts[i].x();        double y = imgPts[i].y();        MatrixXd P = MatrixXd(3, 1);        P(0, 0) = Pts[i].x() - Xs;        P(1, 0) = Pts[i].y() - Ys;        P(2, 0) = Pts[i].z() - Zs;        MatrixXd PP = R.transpose() * P;        double xx = -f * PP(0, 0) / PP(2, 0);        double yy = -f * PP(1, 0) / PP(2, 0);        double du = (x - xx) / img.pixel_size_;        double dv = (y - yy) / img.pixel_size_;        cout &lt;&lt; &quot;point &quot; &lt;&lt; i &lt;&lt; &quot;: dx=&quot; &lt;&lt; du &lt;&lt; &quot;,  dy=&quot; &lt;&lt; dv &lt;&lt; &quot; error = &quot; &lt;&lt; sqrtf(du * du + dv * dv) &lt;&lt; &quot; pixels &quot;            &lt;&lt; endl &lt;&lt; &quot;----------------&quot; &lt;&lt; endl;    &#125;    cout &lt;&lt; &quot;Position: &quot;;    cout &lt;&lt; img.eo_.T_(0, 0) &lt;&lt; &quot;, &quot; &lt;&lt; img.eo_.T_(1, 0) &lt;&lt; &quot;, &quot; &lt;&lt; img.eo_.T_(2, 0) &lt;&lt; endl;    cout &lt;&lt; &quot;Rotation: &quot; &lt;&lt; endl &lt;&lt; img.eo_.R_;    return 1;&#125;</code></pre><h1 id="feature-matching-h"><a href="#feature-matching-h" class="headerlink" title="feature_matching.h"></a>feature_matching.h</h1><pre><code class="lang-c++">#pragma once#include &lt;opencv2/core.hpp&gt;using namespace std;using namespace cv;class FeatureDetection &#123;public:    int Harris(        const Mat&amp; img,                    //影像        vector&lt;KeyPoint&gt;&amp; keypoints,    //影像上的特征点        Mat&amp; description,                //特征点描述        int blockSize = 2,                //Neighborhood size        int apertureSize = 3,            //Aperture parameter for the Sobel operator        double k = 0.04,                //Harris detector free parameter        float thresh = 0.75                //threshold(0 ~ 1.0)    );    void showFeature(const Mat&amp; img, const vector&lt;KeyPoint&gt;&amp; keypoints);    int Sift(        const Mat&amp; img,                    //影像        vector&lt;KeyPoint&gt;&amp; keypoints,    //影像上的特征点        Mat&amp; description,                //特征点描述        const int&amp; nfeatrues = 0,        //The number of best features to ratain        const int&amp; nOctaveLayers = 3,    //The number of layers in each octave        const double&amp; contrastThreshold = 0.04,    //The contrast threshold will be divided by        const double&amp; edgeThreshold = 20,        //The threshold used to filter out edge-like features.        const double&amp; sigma = 1.6                //The sigma if the Gaussian applied to the input image at the octave.    );    int Surf(        const Mat&amp; img,                    //影像        vector&lt;KeyPoint&gt;&amp; keypoints,    //影像上的特征点        Mat&amp; description,                //特征点描述        const double&amp; hessianThreshold = 100,    //Threshold for hessian keypoint detector used in Surf.        const int&amp; nOctaves = 4,                //Number of pyramid octaves the keypoint detector will use.            const int&amp; nOctaveLayers = 3            //Number of octave layers within each octave.    );&#125;;class FeatureMatching &#123;public:    int Brute_force(        const Mat&amp; description1,        //特征点描述        const Mat&amp; description2,        //特征点描述        vector&lt;DMatch&gt;&amp; matched,        //匹配结果        const float&amp; ratio_thresh = 0.7    );    void showMatches(        const Mat&amp; img1,        const vector&lt;KeyPoint&gt;&amp; keypoints1,        const Mat&amp; img2,        const vector&lt;KeyPoint&gt;&amp; keypoints2,        const vector&lt;DMatch&gt;&amp; matches    );    int FLANN_based(        const Mat&amp; description1,        const Mat&amp; description2,        vector&lt;DMatch&gt;&amp; matches,        const float&amp; ratio_thresh = 0.7    );&#125;;</code></pre><h1 id="feature-matching-cpp"><a href="#feature-matching-cpp" class="headerlink" title="feature_matching.cpp"></a>feature_matching.cpp</h1><pre><code class="lang-c++">#include &quot;feature_matching.h&quot;#include &lt;opencv2/highgui.hpp&gt;#include &lt;opencv2/imgproc.hpp&gt;#include &lt;opencv2/features2d.hpp&gt;#include &lt;opencv2/xfeatures2d.hpp&gt;using namespace cv::xfeatures2d;int FeatureDetection::Harris(    const Mat&amp; img,    vector&lt;KeyPoint&gt;&amp; keypoints,    Mat&amp; description,    int blockSize,    int apertureSize,    double k,    float thresh) &#123;    Mat img_gray;    cvtColor(img, img_gray, COLOR_RGB2GRAY);    //Corners 角点特征提取    Mat dst, dst_norm;    dst = Mat::zeros(img_gray.size(), CV_32FC1);    cornerHarris(img_gray, dst, blockSize, apertureSize, k, BORDER_DEFAULT);    //特征影像归一化处理    normalize(dst, dst_norm, 0, 1.0, NORM_MINMAX, CV_32FC1, Mat());    //提取特征点    keypoints.resize(0);    for (int j = 1; j &lt; dst_norm.rows - 1; j++) &#123;        for (int i = 1; i &lt; dst_norm.cols - 1; i++) &#123;            if (dst_norm.at&lt;float&gt;(j, i) &gt; thresh)                keypoints.push_back(KeyPoint(i, j, 20.0));        &#125;    &#125;    //将角点转换为特征描述    //特征描述description为一个矩阵，其中矩阵的每一行对应一个Keypoints    //每一行为一个9维的向量，向量1个值为当前特征点的灰度值，剩余8个值分别为向量像素点与当前特征点的灰度差    description = Mat::zeros(keypoints.size(), 9, CV_32F);    for (int i = 0; i &lt; keypoints.size(); i++) &#123;        float v = img_gray.at&lt;uchar&gt;(keypoints[i].pt);        description.at&lt;float&gt;(i, 0) = v;        description.at&lt;float&gt;(i, 1) = img_gray.at&lt;uchar&gt;(keypoints[i].pt - Point2f(-1, -1)) - v;        description.at&lt;float&gt;(i, 2) = img_gray.at&lt;uchar&gt;(keypoints[i].pt - Point2f(-1, 0)) - v;        description.at&lt;float&gt;(i, 3) = img_gray.at&lt;uchar&gt;(keypoints[i].pt - Point2f(-1, 1)) - v;        description.at&lt;float&gt;(i, 4) = img_gray.at&lt;uchar&gt;(keypoints[i].pt - Point2f(0, -1)) - v;        description.at&lt;float&gt;(i, 5) = img_gray.at&lt;uchar&gt;(keypoints[i].pt - Point2f(0, 1)) - v;        description.at&lt;float&gt;(i, 6) = img_gray.at&lt;uchar&gt;(keypoints[i].pt - Point2f(0, -1)) - v;        description.at&lt;float&gt;(i, 7) = img_gray.at&lt;uchar&gt;(keypoints[i].pt - Point2f(0, 0)) - v;        description.at&lt;float&gt;(i, 8) = img_gray.at&lt;uchar&gt;(keypoints[i].pt - Point2f(0, 1)) - v;    &#125;    return 1;&#125;void FeatureDetection::showFeature(const Mat&amp; img, const vector&lt;KeyPoint&gt;&amp; keypoints) &#123;    Mat img_show;    img.copyTo(img_show);    if (img_show.channels() == 1) &#123;        cvtColor(img_show, img_show, COLOR_GRAY2BGR);    &#125;    for (int i = 0; i &lt; keypoints.size(); i++) &#123;        Point p = keypoints[i].pt;        circle(img_show, p, keypoints[i].size, Scalar(0, 255, 0), 10, 8, 0);    &#125;    string win_str = &quot;Featured image&quot;;    namedWindow(win_str, WINDOW_NORMAL);    resizeWindow(win_str, 960, int(img_show.rows * 960.0 / img_show.cols));    moveWindow(win_str, 100, 100);    imshow(win_str, img_show);&#125;int FeatureDetection::Sift(    const Mat&amp; img,    vector&lt;KeyPoint&gt;&amp; keypoints,    Mat&amp; description,    const int&amp; nfeatrues, /* = 0, 保留的最佳特性的数量*/    const int&amp; nOctaveLayers, /* = 3，高斯金字塔最小层级数，由图像自动计算出 */    const double&amp; contrastThreshold, /* = 0.04， 对比阈值用于过滤区域中的弱特征。阈值越大，检测器产生的特征越少*/    const double&amp; edgeThreshold, /* = 10, 用于过滤掉类似边缘特征的阈值，与对比阈值不同，即边缘阈值越大，滤出的特征越少*/    const double&amp; sigma /* = 1.6， 高斯输入层级， 如果图像分辨率较低，则可能需要减少数值*/) &#123;    Mat img_gray;    cvtColor(img, img_gray, COLOR_RGB2GRAY);    Ptr&lt;SIFT&gt; detector = SIFT::create(nfeatrues, nOctaveLayers, contrastThreshold, edgeThreshold, sigma, CV_32F);    detector-&gt;detectAndCompute(img_gray, Mat(), keypoints, description, false);    return 1;&#125;int FeatureDetection::Surf(    const Mat&amp; img,    vector&lt;KeyPoint&gt;&amp; keypoints,    Mat&amp; description,    const double&amp; hessianThreshold,    const int&amp; nOctaves,    const int&amp; nOctaveLayers) &#123;    Mat img_gray;    cvtColor(img, img_gray, COLOR_RGB2GRAY);    Ptr&lt;SURF&gt; detector = SURF::create(hessianThreshold, nOctaves, nOctaveLayers);    detector-&gt;detectAndCompute(img_gray, noArray(), keypoints, description);    return 1;&#125;int FeatureMatching::Brute_force(    const Mat&amp; description1,    const Mat&amp; description2,    vector&lt;DMatch&gt;&amp; matches,    const float&amp; ratio_thresh) &#123;    vector&lt;vector&lt;DMatch&gt;&gt; all_matches;    BFMatcher BF_matcher(NORM_L2);    BF_matcher.knnMatch(description1, description2, all_matches, 2);    float mindistance = FLT_MAX;    for (int i = 0; i &lt; all_matches.size(); i++) &#123;        if (all_matches[i][0].distance &gt; ratio_thresh * all_matches[i][1].distance) &#123;            continue;        &#125;        float distance = all_matches[i][0].distance;        if (distance &lt; mindistance) &#123;            mindistance = distance;        &#125;    &#125;    vector&lt;DMatch&gt; good_matches;    for (int j = 0; j &lt; all_matches.size(); j++) &#123;        if (all_matches[j][0].distance &gt; ratio_thresh * all_matches[j][1].distance ||            all_matches[j][0].distance &gt; 5 * mindistance) &#123;            continue;        &#125;        good_matches.push_back(all_matches[j][0]);    &#125;    matches = good_matches;    return 1;&#125;void FeatureMatching::showMatches(    const Mat&amp; img1,    const vector&lt;KeyPoint&gt;&amp; keypoints1,    const Mat&amp; img2,    const vector&lt;KeyPoint&gt;&amp; keypoints2,    const vector&lt;DMatch&gt;&amp; matches) &#123;    // Draw matches    Mat img_matches;    //原始图像尺寸太大，需要适当缩放    Mat mat1, mat2;    resize(img1, mat1, Size(), 0.15, 0.15);    resize(img2, mat2, Size(), 0.15, 0.15);    vector&lt;KeyPoint&gt; kpts1 = keypoints1;    vector&lt;KeyPoint&gt; kpts2 = keypoints2;    for (int i = 0; i &lt; kpts1.size(); i++) &#123;        kpts1[i].pt *= 0.15;    &#125;    for (int i = 0; i &lt; kpts2.size(); i++) &#123;        kpts2[i].pt *= 0.15;    &#125;    //生成绘制匹配结果的图像    drawMatches(mat1, kpts1, mat2, kpts2, matches, img_matches, Scalar::all(-1),        Scalar::all(-1), vector&lt;char&gt;(), DrawMatchesFlags::NOT_DRAW_SINGLE_POINTS);    //Show detected matches    string win_str = &quot;Matches&quot;;    namedWindow(win_str, WINDOW_NORMAL);    resizeWindow(win_str, img_matches.cols, img_matches.rows);    imshow(&quot;Matches&quot;, img_matches);&#125;int FeatureMatching::FLANN_based(    const Mat&amp; description1,    const Mat&amp; description2,    vector&lt;DMatch&gt;&amp; matches,    const float&amp; ratio_thresh) &#123;    vector &lt;vector&lt;DMatch&gt;&gt; all_matches;    Ptr&lt;DescriptorMatcher&gt; FB_matcher = DescriptorMatcher::create(DescriptorMatcher::FLANNBASED);    FB_matcher-&gt;knnMatch(description1, description2, all_matches, 2);    float mindistance = FLT_MAX;    for (int i = 0; i &lt; all_matches.size(); i++) &#123;        if (all_matches[i][0].distance &gt; ratio_thresh * all_matches[i][1].distance) &#123;            continue;        &#125;        float distance = all_matches[i][0].distance;        if (distance &lt; mindistance) &#123;            mindistance = distance;        &#125;    &#125;    vector&lt;DMatch&gt; good_matches;    for (int j = 0; j &lt; all_matches.size(); j++) &#123;        if (all_matches[j][0].distance &gt; ratio_thresh * all_matches[j][1].distance ||            all_matches[j][0].distance &gt; 5 * mindistance) &#123;            continue;        &#125;        good_matches.push_back(all_matches[j][0]);    &#125;    matches = good_matches;    return 1;&#125;</code></pre><h1 id="image-orientation-h"><a href="#image-orientation-h" class="headerlink" title="image_orientation.h"></a>image_orientation.h</h1><pre><code class="lang-c++">#pragma once#include &quot;image.h&quot;class RelativeOrientation &#123;public:    int ContinuousMethod(        const Image&amp; imgL,                    //左像        const Image&amp; imgR,                    //右像        const vector&lt;Vector2d&gt;&amp; pixelPtsL,    //左像上的特征点        const vector&lt;Vector2d&gt;&amp; pixelPtsR,    //右像上的特征点        Mat&amp; rR,                            //右像相对于左像的旋转矩阵        Vector3d&amp; rT                        //右像相对于左像的平移参数    );    int IndependentMethod(        const Image&amp; imgL,                    //左像        const Image&amp; imgR,                    //右像        const vector&lt;Vector2d&gt;&amp; pixelPtsL,    //左像上的特征点        const vector&lt;Vector2d&gt;&amp; pixelPtsR,    //右像上的特征点        Mat&amp; rR,                            //右像相对于左像的旋转矩阵        Vector3d&amp; rT                        //右像相对于左像的平移参数    );    int cv(        const Image&amp; imgL,        const Image&amp; imgR,        const vector&lt;Vector2d&gt;&amp; pixelPtsL,        const vector&lt;Vector2d&gt;&amp; pixelPtsR,        Mat&amp; rR,        Vector3d&amp; rT    );&#125;;</code></pre><h1 id="image-orientation-cpp"><a href="#image-orientation-cpp" class="headerlink" title="image_orientation.cpp"></a>image_orientation.cpp</h1><pre><code class="lang-c++">#include &quot;image_orientation.h&quot;#include &lt;opencv2/calib3d.hpp&gt;int RelativeOrientation::cv(    const Image&amp; imgL,    const Image&amp; imgR,    const vector&lt;Vector2d&gt;&amp; pixelPtsL,    const vector&lt;Vector2d&gt;&amp; pixelPtsR,    Mat&amp; rR,    Vector3d&amp; rT) &#123;    if (pixelPtsL.size() != pixelPtsR.size()) &#123;        return 0;    &#125;    //假设左右影像为同一传感器拍摄的影像，即具有相同的内参    double focal_length = imgL.io_.focal_ / imgL.pixel_size_;    Point2d principle_point = Point2d(imgL.io_.cx_, imgL.io_.cy_);    vector&lt;Point2d&gt; pts1(pixelPtsL.size()), pts2(pixelPtsR.size());    for (int i = 0; i &lt; pixelPtsL.size(); i++) &#123;        pts1[i] = Point2d(pixelPtsL[i].x(), pixelPtsL[i].y());        pts2[i] = Point2d(pixelPtsR[i].x(), pixelPtsR[i].y());    &#125;    //计算本征矩阵    Mat mask;    Mat E = cv::findEssentialMat(pts1, pts2, focal_length, principle_point,        RANSAC, 0.9999, 1.0, mask);    if (E.empty()) &#123;        return 0;    &#125;    double feasible_count = cv::countNonZero(mask);    //对于RANSAC来说，outlier的数量大于50%时，结果是不可靠的    if (feasible_count / pixelPtsL.size() &lt; 0.5) &#123;        return 0;    &#125;    //分解本征矩阵，获取相对变换    Mat R, t;    int pass_count = cv::recoverPose(E, pts1, pts2, R, t, focal_length, principle_point, mask);    //同时，位于两个相机前方的点数量要足够大    if (((double)pass_count) / feasible_count &lt; 0.7) &#123;        return 0;    &#125;    R.copyTo(rR);    rT = Vector3d(t.at&lt;double&gt;(0, 0), t.at&lt;double&gt;(1, 0), t.at&lt;double&gt;(2, 0));    //这里的rR和rT满足CV里的坐标转换关系，即    //            | x2 |            | x1 |    //            | y2 |    = R *    | y1 | + t    //            | z2 |            | z1 |         return 1;&#125;</code></pre><h1 id="forword-intersection-h"><a href="#forword-intersection-h" class="headerlink" title="forword_intersection.h"></a>forword_intersection.h</h1><pre><code class="lang-c++">#pragma once#include &quot;image.h&quot;class ForwardIntersection&#123;public:    ForwardIntersection() &#123;&#125;;    ~ForwardIntersection() &#123;&#125;;private:    Mat_&lt;double&gt; LinearLSTriangulation(        Point3d u,        Matx34d P,        Point3d u1,        Matx34d P1)    &#123;        //build matrix A for homogenous equation system Ax = 0        //assume X = (x,y,z,1), for Linear-LS method        //which turns it into a AX = B system, where A is 4x3, X is 3x1 and B is 4x1        Matx43d A(u.x * P(2, 0) - P(0, 0), u.x * P(2, 1) - P(0, 1), u.x * P(2, 2) - P(0, 2),            u.y * P(2, 0) - P(1, 0), u.y * P(2, 1) - P(1, 1), u.y * P(2, 2) - P(1, 2),            u1.x * P1(2, 0) - P1(0, 0), u1.x * P1(2, 1) - P1(0, 1), u1.x * P1(2, 2) - P1(0, 2),            u1.y * P1(2, 0) - P1(1, 0), u1.y * P1(2, 1) - P1(1, 1), u1.y * P1(2, 2) - P1(1, 2)        );        Mat_&lt;double&gt; B = (Mat_&lt;double&gt;(4, 1) &lt;&lt; -(u.x * P(2, 3) - P(0, 3)),            -(u.y * P(2, 3) - P(1, 3)),            -(u1.x * P1(2, 3) - P1(0, 3)),            -(u1.y * P1(2, 3) - P1(1, 3)));        Mat_&lt;double&gt; X;        solve(A, B, X, DECOMP_SVD);        return X;    &#125;    Mat_&lt;double&gt; IterativeLinearLSTriangulation(        Point3d u,        Matx34d P,        Point3d u1,        Matx34d P1)    &#123;        double wi = 1, wi1 = 1;        Mat_&lt;double&gt; X(4, 1);        for (int i = 0; i &lt; 10; i++)        &#123;            //Hartley suggests 10 iterations at most            Mat_&lt;double&gt; X_ = LinearLSTriangulation(u, P, u1, P1);            X(0) = X_(0); X(1) = X_(1); X(2) = X_(2); X(3) = 1.0;            //recalculate weights            double p2x = Mat_&lt;double&gt;(Mat_&lt;double&gt;(P).row(2) * X)(0);            double p2x1 = Mat_&lt;double&gt;(Mat_&lt;double&gt;(P1).row(2) * X)(0);            //breaking point            if (fabsf(wi - p2x) &lt;= 0.000001 &amp;&amp; fabsf(wi1 - p2x1) &lt;= 0.000001) break;            wi = p2x;            wi1 = p2x1;            //reweight equations and solve            Matx43d A((u.x * P(2, 0) - P(0, 0)) / wi, (u.x * P(2, 1) - P(0, 1)) / wi, (u.x * P(2, 2) - P(0, 2)) / wi,                (u.y * P(2, 0) - P(1, 0)) / wi, (u.y * P(2, 1) - P(1, 1)) / wi, (u.y * P(2, 2) - P(1, 2)) / wi,                (u1.x * P1(2, 0) - P1(0, 0)) / wi1, (u1.x * P1(2, 1) - P1(0, 1)) / wi1, (u1.x * P1(2, 2) - P1(0, 2)) / wi1,                (u1.y * P1(2, 0) - P1(1, 0)) / wi1, (u1.y * P1(2, 1) - P1(1, 1)) / wi1, (u1.y * P1(2, 2) - P1(1, 2)) / wi1            );            Mat_&lt;double&gt; B = (Mat_&lt;double&gt;(4, 1) &lt;&lt; -(u.x * P(2, 3) - P(0, 3)) / wi,                -(u.y * P(2, 3) - P(1, 3)) / wi,                -(u1.x * P1(2, 3) - P1(0, 3)) / wi1,                -(u1.y * P1(2, 3) - P1(1, 3)) / wi1                );            solve(A, B, X_, DECOMP_SVD);            X(0) = X_(0); X(1) = X_(1); X(2) = X_(2); X(3) = 1.0;        &#125;        return X;    &#125;public:    int cv(        const Image&amp; imgL,        const Image&amp; imgR,        const Mat&amp; RcvL,        const Mat&amp; RcvR,        const Mat&amp; TcvL,        const Mat&amp; TcvR,        const vector&lt;Vector2d&gt;&amp; pixelPtsL,        const vector&lt;Vector2d&gt;&amp; pixelPtsR,        vector&lt;Point3d&gt;&amp; space_pts,        Mat&amp; mask    )    &#123;        Mat proj1(3, 4, CV_64FC1);        Mat proj2(3, 4, CV_64FC1);        double fx = imgL.io_.focal_ / imgL.pixel_size_;        double fy = fx;        double cx = imgL.io_.cx_;        double cy = imgL.io_.cy_;        Mat K = (cv::Mat_&lt;double&gt;(3, 3) &lt;&lt; fx, 0, cx, 0, fy, cy, 0, 0, 1);        RcvL.convertTo(proj1(Range(0, 3), Range(0, 3)), CV_64FC1);        proj1.at&lt;double&gt;(0, 3) = TcvL.at&lt;double&gt;(0);        proj1.at&lt;double&gt;(1, 3) = TcvL.at&lt;double&gt;(1);        proj1.at&lt;double&gt;(2, 3) = TcvL.at&lt;double&gt;(2);        RcvR.convertTo(proj2(Range(0, 3), Range(0, 3)), CV_64FC1);        proj2.at&lt;double&gt;(0, 3) = TcvR.at&lt;double&gt;(0);        proj2.at&lt;double&gt;(1, 3) = TcvR.at&lt;double&gt;(1);        proj2.at&lt;double&gt;(2, 3) = TcvR.at&lt;double&gt;(2);        // triangulate points        int pts_size = pixelPtsL.size();        space_pts.resize(pixelPtsL.size());        for (int i = 0; i &lt; pts_size; i++)        &#123;            Point2f kp = Point2f(pixelPtsL[i].x(), pixelPtsL[i].y());            Point3d u1(kp.x, kp.y, 1.0);            Mat_&lt;double&gt; um1 = K.inv() * Mat_&lt;double&gt;(u1);            u1 = Point3d(um1.at&lt;double&gt;(0), um1.at&lt;double&gt;(1), um1.at&lt;double&gt;(2));            Point2f kp1 = Point2f(pixelPtsR[i].x(), pixelPtsR[i].y());            Point3d u2(kp1.x, kp1.y, 1.0);            Mat_&lt;double&gt; um2 = K.inv() * Mat_&lt;double&gt;(u2);            u2 = Point3d(um2.at&lt;double&gt;(0), um2.at&lt;double&gt;(1), um2.at&lt;double&gt;(2));            Mat_&lt;double&gt; X = IterativeLinearLSTriangulation(u1, proj1, u2, proj2);            space_pts[i] = Point3d(X(0), X(1), X(2));        &#125;        int fail_count = 0;        mask = cv::Mat::ones(1, space_pts.size(), CV_8UC1);        for (int i = 0; i &lt; space_pts.size(); i++)        &#123;            Mat P = (Mat_&lt;double&gt;(4, 1) &lt;&lt; space_pts[i].x, space_pts[i].y, space_pts[i].z, 1);            Mat pix1 = K * proj1 * P;            pix1 /= pix1.at&lt;double&gt;(2);            Mat pix2 = K * proj2 * P;            pix2 /= pix2.at&lt;double&gt;(2);            double d1 = (pix1.at&lt;double&gt;(0) - pixelPtsL[i].x()) * (pix1.at&lt;double&gt;(0) - pixelPtsL[i].x()) + (pix1.at&lt;double&gt;(1) - pixelPtsL[i].y()) * (pix1.at&lt;double&gt;(1) - pixelPtsL[i].y());            double d2 = (pix2.at&lt;double&gt;(0) - pixelPtsR[i].x()) * (pix2.at&lt;double&gt;(0) - pixelPtsR[i].x()) + (pix2.at&lt;double&gt;(1) - pixelPtsR[i].y()) * (pix2.at&lt;double&gt;(1) - pixelPtsR[i].y());            if (d1 &gt; 2 || d2 &gt; 2) //若反投影到影像上与像点的距离大于2个像素，则判断为失配点            &#123;                mask.at&lt;uchar&gt;(i) = 0;                fail_count++;            &#125;        &#125;        if (fail_count &gt; space_pts.size() * 0.8) //80%以上都失败 返回0            return 0;        return 1;    &#125;&#125;;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;三方库&quot;&gt;&lt;a href=&quot;#三方库&quot; class=&quot;headerlink&quot; title=&quot;三方库&quot;&gt;&lt;/a&gt;三方库&lt;/h1&gt;&lt;p&gt;Eigen、Ceres Solver、opencv等&lt;/p&gt;
&lt;h1 id=&quot;main-cpp&quot;&gt;&lt;a href=&quot;#main-cp</summary>
      
    
    
    
    <category term="摄影测量" scheme="https://zzygeo.cn/categories/%E6%91%84%E5%BD%B1%E6%B5%8B%E9%87%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>C++知识点</title>
    <link href="https://zzygeo.cn/2021/06/21/C++/Visual%20Studio%E6%B7%BB%E5%8A%A0%E5%BA%93/"/>
    <id>https://zzygeo.cn/2021/06/21/C++/Visual%20Studio%E6%B7%BB%E5%8A%A0%E5%BA%93/</id>
    <published>2021-06-21T10:56:30.000Z</published>
    <updated>2021-06-29T04:27:15.321Z</updated>
    
    <content type="html"><![CDATA[<p>为了==识别dll文件==，需要将其文件目录位置放入系统变量里</p><p>项目属性-》VC++Directions里Include Directions里加入==库所在文件夹==以及==头文件所在文件夹== </p><p>项目属性-》VC++Directions里Library Directions里加入存放==lib文件夹目录==：</p><p>项目属性-》Linker-》Input里加入==lib文件的名称==：</p><p>lib和dll简介:</p><p>(1)lib是编译时需要的，dll是运行时需要的。<br>如果要完成源代码的编译，有lib就够了。<br>如果也使动态连接的程序运行起来，有dll就够了。<br>在开发和调试阶段，当然最好都有。<br>(2)一般的动态库程序有lib文件和dll文件。lib文件是必须在编译期就连接到应用程序中的，而dll文件是运行期才会被调用的。如果有dll文件，那么对应的lib文件一般是一些索引信息，具体的实现在dll文件中。如果只有lib文件，那么这个lib文件是静态编译出来的，索引和实现都在其中。静态编译的lib文件有好处：给用户安装时就不需要再挂动态库了。但也有缺点，就是导致应用程序比较大，而且失去了动态库的灵活性，在版本升级时，同时要发布新的应用程序才行。<br>(3)在动态库的情况下，有两个文件，一个是引入库（.LIB）文件，一个是dll文件，引入库文件包含被DLL导出的函数的名称和位置，DLL包含实际的函数和数据，应用程序使用LIB文件链接到所需要使用的DLL文件，库中的函数和数据并不复制到可执行文件中，因此在应用程序的可执行文件中，存放的不是被调用的函数代码，而是DLL中所要调用的函数的内存地址，这样当一个或多个应用程序运行是再把程序代码和被调用的函数代码链接起来，从而节省了内存资源。从上面的说明可以看出，DLL和.LIB文件必须随应用程序一起发行，否则应用程序将会产生错误。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;为了==识别dll文件==，需要将其文件目录位置放入系统变量里&lt;/p&gt;
&lt;p&gt;项目属性-》VC++Directions里Include Directions里加入==库所在文件夹==以及==头文件所在文件夹== &lt;/p&gt;
&lt;p&gt;项目属性-》VC++Directions里Li</summary>
      
    
    
    
    <category term="C++" scheme="https://zzygeo.cn/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaScript基础</title>
    <link href="https://zzygeo.cn/2021/06/10/Cesium/Cesiun%E5%AD%A6%E4%B9%A0/"/>
    <id>https://zzygeo.cn/2021/06/10/Cesium/Cesiun%E5%AD%A6%E4%B9%A0/</id>
    <published>2021-06-09T17:02:30.000Z</published>
    <updated>2021-06-10T14:41:41.657Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Cesium下载及安装"><a href="#1-Cesium下载及安装" class="headerlink" title="1. Cesium下载及安装"></a>1. Cesium下载及安装</h1><p>先会用到node和git两个软件.</p><p>在运行以下代码之前，先安装gulp.</p><p><a href="https://www.gulpjs.com.cn/">gulp</a></p><pre><code class="lang-bash">git clone https://github.com/CesiumGS/cesium.git    //源码下载npm install    //安装cesium所需的一些依赖npm run release    //会把所有的东西封装成一个文件</code></pre><h1 id="2-cesiumWidget"><a href="#2-cesiumWidget" class="headerlink" title="2. cesiumWidget"></a>2. cesiumWidget</h1><p>CesiumWidget内部创建的对象主要有以下几个部分：</p><pre><code class="lang-mermaid">graph LRA[Cesium]--&gt;B[cesiumWidget]B--&gt;C[clock]B--&gt;D[container]B--&gt;E[canvas]B--&gt;F[screenSpaceEvenHandler]B--&gt;G[scene]G--&gt;H[global]--&gt;I[_surface]G--&gt;J[primitives]G--&gt;K[groundPrimitives]G--&gt;Y[环境对象]Y--&gt;a[skyBox]Y--&gt;b[skyAtmosphere]Y--&gt;c[sun]Y--&gt;d[sunBloom]Y--&gt;e[moon]Y--&gt;f[background]</code></pre><p>clock用来记录时间，毕竟三维场景需要进行动态展示，需要通过时间来确定某一帧的绘制内容。container则是构造函数的参数，也就是传入的div。canvas则是在container上构建的Canvas的对象，可以据此获取WebGL绘制的比划。screenSpaceEventHandler则是对Canvas对象上各种鼠标的交互时间的封装，方便传递给三维场景。三维场景干之后可以据此改变相机姿态等。scene最重要，它承载着整个三维场景中的对象。</p><p>Scene中装载了所有的三维对象</p><p>Scene中有一些==内置==的图元对象：地球（Global）、skyBox（天空盒）、sun、moon等，另外还有两个用来由用户自行控制存放对象的数组：primitives和groundPrimitives, ==scene里本身是没有时间的概念的==</p><h1 id="3-cesium搭建发布环境"><a href="#3-cesium搭建发布环境" class="headerlink" title="3. cesium搭建发布环境"></a>3. cesium搭建发布环境</h1><p>先安装express</p><pre><code class="lang-bash">npm install express</code></pre><p>创建server.js文件</p><pre><code class="lang-javascript">var http = require(&quot;http&quot;);var express = require(&quot;express&quot;);const path = require(&#39;path&#39;);var app = express();app.use(express.static(path.join(__dirname, &#39;&#39;)));app.listen(4111, () =&gt; &#123;  console.log(`http://localhost:4111`)&#125;)</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-Cesium下载及安装&quot;&gt;&lt;a href=&quot;#1-Cesium下载及安装&quot; class=&quot;headerlink&quot; title=&quot;1. Cesium下载及安装&quot;&gt;&lt;/a&gt;1. Cesium下载及安装&lt;/h1&gt;&lt;p&gt;先会用到node和git两个软件.&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    <category term="Cesiun" scheme="https://zzygeo.cn/categories/Cesiun/"/>
    
    
  </entry>
  
  <entry>
    <title>C++知识点</title>
    <link href="https://zzygeo.cn/2021/05/31/C++/C++%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>https://zzygeo.cn/2021/05/31/C++/C++%E7%9F%A5%E8%AF%86%E7%82%B9/</id>
    <published>2021-05-31T03:22:15.000Z</published>
    <updated>2021-05-31T04:03:10.856Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-cin-clear"><a href="#1-cin-clear" class="headerlink" title="1. cin.clear()"></a>1. cin.clear()</h1><p>是用来更改cin的状态标示符的。</p><p>cin.sync（）是用来清除缓存区的数据流的。<br>如果标示符没有改变那么即使清除了数据流也无法输入。所以两个要联合起来使用。</p><p>我们定义要输入到的变量是整型,但如果我们输入了英文字母或者汉字,那就会发生错误,cin里有个方法能检测这个错误,就是cin.rdstate(); 当cin.rdstate()返回0(即ios::goodbit)时表示无错误,可以继续输入或者操作,若返回4则发生非致命错误即ios::failbit,则不能继续输入或操作.而cin.clear则可以控制我们此时cin里对这个问题的一个标识.语发如下: cin.clear(标识符); 标识符号为:</p><p>goodbit 无错误<br>Eofbit 已到达文件尾<br>failbit 非致命的输入/输出错误，可挽回<br>badbit　致命的输入/输出错误,无法挽回 若在输入输出类里.需要加ios::标识符号<br>通过cin.clear,我们能确认它的内部标识符,如果输入错误则能重新输入.结合真正的清空数据流方法cin.sync(),请看下例:</p><pre><code class="lang-c++">include &lt;iostream&gt;using namespace std; int main()  &#123;             int a;             while(1)             &#123;                         cin&gt;&gt;a;                         if(!cin)            //条件可改写为cin.fail()                         &#123;                                     cout&lt;&lt;&quot;输入有错!请重新输入&quot;&lt;&lt;endl;                                     cin.clear();                                      cin.sync();   //清空流                         &#125;                         else                         &#123;                                     cout&lt;&lt;a;                                     break;                         &#125;             &#125;             system(&quot;pause&quot;); &#125;</code></pre><p>上面的cin.clear()默认参数为0,即无错误,正常操作.当我们输入英文字母’k’时,它的状态标识改为fail,即错误,用cout对用户输出信息,再用cin.clear让错误标识改回为0,让我们可以继续输入,再清空流数据继续输入.如果我们没有了cin.clear,则会进入死循环,其过程为我们输入了英文字母,它的状态标识便为fail,当运行到条件判断时,便总是回到错误的条件表示里,并且我们再也没办法输入,因为错误的表示关闭了cin,所以会进入死循环.</p><h1 id="2-常量指针和指针常量"><a href="#2-常量指针和指针常量" class="headerlink" title="2. 常量指针和指针常量"></a>2. 常量指针和指针常量</h1><p>在第一次听黑马C++的时候，是按老师的说法自己记忆的，而在回顾C++ primer plus时，对这个的理解才更加深刻，先看两者的声明。</p><pre><code class="lang-c++">int sloth =3;const int* ps = &amp;sloth;        // a pointer to const intint* const finger = &amp;sloth;    // a const pointer to int</code></pre><p>根据英文的理解比中文好的多， a pointer to const int 代表这个指针指向的常量是不可以改变的，但是这个指针是指向却是可以改变的。</p><p>第二个表明这个指针它是一个常量，它是没法改变的，但是他指向的值却是可以改变的，记住这个英文的注解就可以了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-cin-clear&quot;&gt;&lt;a href=&quot;#1-cin-clear&quot; class=&quot;headerlink&quot; title=&quot;1. cin.clear()&quot;&gt;&lt;/a&gt;1. cin.clear()&lt;/h1&gt;&lt;p&gt;是用来更改cin的状态标示符的。&lt;/p&gt;
&lt;p&gt;cin.</summary>
      
    
    
    
    <category term="C++" scheme="https://zzygeo.cn/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>IDEA快捷键</title>
    <link href="https://zzygeo.cn/2021/05/24/Java%E5%9F%BA%E7%A1%80/IDEA%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>https://zzygeo.cn/2021/05/24/Java%E5%9F%BA%E7%A1%80/IDEA%E5%BF%AB%E6%8D%B7%E9%94%AE/</id>
    <published>2021-05-24T02:48:12.000Z</published>
    <updated>2021-06-07T14:07:58.361Z</updated>
    
    <content type="html"><![CDATA[<p>查看类的结构：ctrl+f12</p><p>查看类的继承图：ctrl+alt+shift+u</p><p>查看函数参数：ctrl+p</p><p>查看函数介绍：ctrl+q</p><p>格式化代码：ctrl+shift+l</p><p>代码补全：alt+/</p><p>提示关键字：alt+shift+/</p><p>万能结错/生成返回值变量：alt+enter</p><p>查看继承结构：ctrl+h</p><p>反撤销：ctrl+shift+z</p><p>大小写转换：ctrl+shift+u</p><p>收起所有的方法：ctrl+shift+-</p><p>打开所有的方法：ctrl+shfit++</p><p>重命名：shift+f6</p><p>打开文件所在位置：ctrl+shift+x</p><p>生成try-catch等：ctrl+alt+t</p><p>局部变量抽取为成员变量：ctrl+alt+f</p><p>添加到收藏夹：alt+shift+f</p><p>搜索类中的错误：f2</p><p>复制选取：ctrl+shift+v</p><p>显示方法在哪调用过：ctrl+shift+h</p><p>快写构造函数：alt+insert</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;查看类的结构：ctrl+f12&lt;/p&gt;
&lt;p&gt;查看类的继承图：ctrl+alt+shift+u&lt;/p&gt;
&lt;p&gt;查看函数参数：ctrl+p&lt;/p&gt;
&lt;p&gt;查看函数介绍：ctrl+q&lt;/p&gt;
&lt;p&gt;格式化代码：ctrl+shift+l&lt;/p&gt;
&lt;p&gt;代码补全：alt+/&lt;/p&gt;</summary>
      
    
    
    
    <category term="Java基础" scheme="https://zzygeo.cn/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>dpkg被中断的解决办法</title>
    <link href="https://zzygeo.cn/2021/03/14/Ubuntu/dpkg%E8%A2%AB%E4%B8%AD%E6%96%AD%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <id>https://zzygeo.cn/2021/03/14/Ubuntu/dpkg%E8%A2%AB%E4%B8%AD%E6%96%AD%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</id>
    <published>2021-03-13T17:40:02.000Z</published>
    <updated>2021-05-24T00:57:48.469Z</updated>
    
    <content type="html"><![CDATA[<p>linux系统安装软件是有时会碰到“dpkg 被中断,您必须手工运行 sudo dpkg –configure -a解决此问题”，然而按照提示运行却并没能很好的解决问题。其实导致这个问题的主要原因是因为/var/lib/dpkg/updates文件下的文件有问题，可能是其他软件安装过程或是其他原因导致的，这里删除掉然后重建即可。<br><a id="more"></a></p><pre><code>sudo rm /var/lib/dpkg/updates/*sudo apt-get updatesudo apt-get upgrade</code></pre><p>解释：[<em>]sudo apt-get update指令会重新建立这些资料，所以不必担心删除后会出问题；<br>[</em>]sudo apt-get upgrade会更新你的电脑里面已安装的软件的明细，根据软件的明细更新软件到最新版。<br>PS：“dpkg ”是“Debian Packager ”的简写。为 “Debian” 专门开发的套件管理系统，方便软件的安装、更新及移除。所有源自“Debian”的“Linux ”发行版都使用 “dpkg”</p><p>参考<a href="https://blog.csdn.net/coolcooljob/article/details/79964812">博客</a></p><hr>]]></content>
    
    
    <summary type="html">&lt;p&gt;linux系统安装软件是有时会碰到“dpkg 被中断,您必须手工运行 sudo dpkg –configure -a解决此问题”，然而按照提示运行却并没能很好的解决问题。其实导致这个问题的主要原因是因为/var/lib/dpkg/updates文件下的文件有问题，可能是其他软件安装过程或是其他原因导致的，这里删除掉然后重建即可。&lt;br&gt;</summary>
    
    
    
    <category term="Ubuntu" scheme="https://zzygeo.cn/categories/Ubuntu/"/>
    
    
  </entry>
  
  <entry>
    <title>安装snap以及常用命令</title>
    <link href="https://zzygeo.cn/2021/03/14/Ubuntu/%E5%AE%89%E8%A3%85snap/"/>
    <id>https://zzygeo.cn/2021/03/14/Ubuntu/%E5%AE%89%E8%A3%85snap/</id>
    <published>2021-03-13T17:35:25.000Z</published>
    <updated>2021-05-24T00:58:39.914Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-安装snap"><a href="#1-安装snap" class="headerlink" title="1.安装snap"></a>1.安装snap</h1><a id="more"></a><pre><code>sudo apt-get install snapdsudo apt-get install snapcraft</code></pre><h1 id="2-常用命令"><a href="#2-常用命令" class="headerlink" title="2.常用命令"></a>2.常用命令</h1><pre><code>//列出已经安装的snap包sudo snap list//搜索要安装的snap包sudo snap find &lt;text to search&gt;//安装一个snap包sudo snap install &lt;snap name&gt;//更新一个snap包，如果你后面不加包的名字的话那就是更新所有的snap包sudo snap refresh &lt;snap name&gt;//把一个包还原到以前安装的版本sudo snap revert &lt;snap name&gt;//删除一个snap包sudo snap remove &lt;snap name&gt;</code></pre><hr>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;1-安装snap&quot;&gt;&lt;a href=&quot;#1-安装snap&quot; class=&quot;headerlink&quot; title=&quot;1.安装snap&quot;&gt;&lt;/a&gt;1.安装snap&lt;/h1&gt;</summary>
    
    
    
    <category term="Ubuntu" scheme="https://zzygeo.cn/categories/Ubuntu/"/>
    
    
  </entry>
  
  <entry>
    <title>ubuntu配置C/C++开发环境</title>
    <link href="https://zzygeo.cn/2021/03/14/Ubuntu/ubuntu%E9%85%8D%E7%BD%AEC-C-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
    <id>https://zzygeo.cn/2021/03/14/Ubuntu/ubuntu%E9%85%8D%E7%BD%AEC-C-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</id>
    <published>2021-03-13T17:31:07.000Z</published>
    <updated>2021-05-24T00:58:14.532Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-在代码文件夹下建立两个文件"><a href="#1-在代码文件夹下建立两个文件" class="headerlink" title="1.在代码文件夹下建立两个文件"></a>1.在代码文件夹下建立两个文件</h1><p>launch.json 以及 tasks.json<br><a id="more"></a></p><h1 id="2-给这个两个文件配置文件"><a href="#2-给这个两个文件配置文件" class="headerlink" title="2.给这个两个文件配置文件"></a>2.给这个两个文件配置文件</h1><p>launch.json:</p><pre><code>&#123;    // Use IntelliSense to learn about possible attributes.    // Hover to view descriptions of existing attributes.    // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387    &quot;version&quot;: &quot;0.2.0&quot;,    &quot;configurations&quot;: [        &#123;            &quot;name&quot;: &quot;(gdb) Launch&quot;,            &quot;type&quot;: &quot;cppdbg&quot;,            &quot;request&quot;: &quot;launch&quot;,            &quot;program&quot;: &quot;$&#123;workspaceFolder&#125;/$&#123;fileBasenameNoExtension&#125;.out&quot;,            &quot;args&quot;: [],            &quot;stopAtEntry&quot;: false,            &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;&quot;,            &quot;environment&quot;: [],            &quot;externalConsole&quot;: true,    //如果不要窗口弹出，在ide中显示，就设置成 false            &quot;MIMode&quot;: &quot;gdb&quot;,            &quot;preLaunchTask&quot;: &quot;build&quot;,   //表示预先生成一个中间文件，用于g++运行            &quot;setupCommands&quot;: [                &#123;                    &quot;description&quot;: &quot;Enable pretty-printing for gdb&quot;,                    &quot;text&quot;: &quot;-enable-pretty-printing&quot;,                    &quot;ignoreFailures&quot;: true                &#125;            ]        &#125;    ]&#125;</code></pre><p>tasks.json:</p><pre><code>&#123;    // See https://go.microsoft.com/fwlink/?LinkId=733558    // for the documentation about the tasks.json format    &quot;version&quot;: &quot;2.0.0&quot;,    &quot;tasks&quot;: [        &#123;            &quot;label&quot;: &quot;build&quot;,            &quot;type&quot;: &quot;shell&quot;,            &quot;command&quot;: &quot;g++&quot;,            &quot;args&quot;: [&quot;-g&quot;, &quot;$&#123;file&#125;&quot;, &quot;-std=c++11&quot;, &quot;-o&quot;, &quot;$&#123;fileBasenameNoExtension&#125;.out&quot;]    //相当于 g++ -g main.cpp -std=c++11 -o main.out        &#125;    ]&#125;</code></pre><p>参考<a href="https://blog.csdn.net/suiyueruge1314/article/details/106125949">博客</a></p><hr>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;1-在代码文件夹下建立两个文件&quot;&gt;&lt;a href=&quot;#1-在代码文件夹下建立两个文件&quot; class=&quot;headerlink&quot; title=&quot;1.在代码文件夹下建立两个文件&quot;&gt;&lt;/a&gt;1.在代码文件夹下建立两个文件&lt;/h1&gt;&lt;p&gt;launch.json 以及 tasks.json&lt;br&gt;</summary>
    
    
    
    <category term="Ubuntu" scheme="https://zzygeo.cn/categories/Ubuntu/"/>
    
    
  </entry>
  
  <entry>
    <title>ubuntu安装gcc依赖关系报错</title>
    <link href="https://zzygeo.cn/2021/03/14/Ubuntu/ubuntu%E5%AE%89%E8%A3%85gcc%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB%E6%8A%A5%E9%94%99/"/>
    <id>https://zzygeo.cn/2021/03/14/Ubuntu/ubuntu%E5%AE%89%E8%A3%85gcc%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB%E6%8A%A5%E9%94%99/</id>
    <published>2021-03-13T17:26:01.000Z</published>
    <updated>2021-05-24T00:57:56.428Z</updated>
    
    <content type="html"><![CDATA[<p>使用aptitude包依赖管理工具替代apt处理，看其他的博客说这个得慎用，不过用来安装gcc倒是没啥问题。<br><a id="more"></a></p><pre><code>sudo apt-get install aptitudesudo aptitude install gcc g++</code></pre><p>解决方案里选择no,yes,yes.<br>参考<a href="https://blog.csdn.net/CLZHIT/article/details/104508894">博客</a></p><hr>]]></content>
    
    
    <summary type="html">&lt;p&gt;使用aptitude包依赖管理工具替代apt处理，看其他的博客说这个得慎用，不过用来安装gcc倒是没啥问题。&lt;br&gt;</summary>
    
    
    
    <category term="Ubuntu" scheme="https://zzygeo.cn/categories/Ubuntu/"/>
    
    
  </entry>
  
  <entry>
    <title>ubuntu安装vim依赖关系报错</title>
    <link href="https://zzygeo.cn/2021/03/14/Ubuntu/ubuntu%E5%AE%89%E8%A3%85vim%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB%E6%8A%A5%E9%94%99/"/>
    <id>https://zzygeo.cn/2021/03/14/Ubuntu/ubuntu%E5%AE%89%E8%A3%85vim%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB%E6%8A%A5%E9%94%99/</id>
    <published>2021-03-13T17:22:16.000Z</published>
    <updated>2021-05-24T00:58:01.518Z</updated>
    
    <content type="html"><![CDATA[<p>按如下步骤进行就可：<br><a id="more"></a></p><pre><code>sudo apt-get purge vim-commonsudo apt-get updatesudo apt-get upgradesudo apt-get install vim</code></pre><hr>]]></content>
    
    
    <summary type="html">&lt;p&gt;按如下步骤进行就可：&lt;br&gt;</summary>
    
    
    
    <category term="Ubuntu" scheme="https://zzygeo.cn/categories/Ubuntu/"/>
    
    
  </entry>
  
  <entry>
    <title>ubuntu下的firefox无法播放视频解决方案</title>
    <link href="https://zzygeo.cn/2021/03/14/Ubuntu/ubuntu%E4%B8%8B%E7%9A%84firefox%E6%97%A0%E6%B3%95%E6%92%AD%E6%94%BE%E8%A7%86%E9%A2%91%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>https://zzygeo.cn/2021/03/14/Ubuntu/ubuntu%E4%B8%8B%E7%9A%84firefox%E6%97%A0%E6%B3%95%E6%92%AD%E6%94%BE%E8%A7%86%E9%A2%91%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</id>
    <published>2021-03-13T17:09:31.000Z</published>
    <updated>2021-05-24T00:58:20.789Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-下载flash的tar-gz文件"><a href="#1-下载flash的tar-gz文件" class="headerlink" title="1.下载flash的tar.gz文件"></a>1.下载flash的tar.gz文件</h1><p>直接去<a href="https://www.flash.cn/">官网链接</a>下载<br><a id="more"></a></p><h1 id="2-解压tar-gz文件"><a href="#2-解压tar-gz文件" class="headerlink" title="2.解压tar.gz文件"></a>2.解压tar.gz文件</h1><pre><code>tar -zxvf filename.tar.gz</code></pre><p>注意filename.tar.gz就是你下载的文件的名字，可以直接复制下载包名字。</p><h1 id="3-移动解压文件夹"><a href="#3-移动解压文件夹" class="headerlink" title="3.移动解压文件夹"></a>3.移动解压文件夹</h1><p>先进入安装包目录下,然后</p><pre><code>sudo cp libflashplayer.so /usr/lib/firefox/browser/pluginssudo cp -r usr/* /usr</code></pre><h1 id="4-缺少依赖报错解决"><a href="#4-缺少依赖报错解决" class="headerlink" title="4.缺少依赖报错解决"></a>4.缺少依赖报错解决</h1><pre><code>sudo apt-get install ffmpeg  //ffmpeg支持H.264解码</code></pre><hr>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;1-下载flash的tar-gz文件&quot;&gt;&lt;a href=&quot;#1-下载flash的tar-gz文件&quot; class=&quot;headerlink&quot; title=&quot;1.下载flash的tar.gz文件&quot;&gt;&lt;/a&gt;1.下载flash的tar.gz文件&lt;/h1&gt;&lt;p&gt;直接去&lt;a href=&quot;https://www.flash.cn/&quot;&gt;官网链接&lt;/a&gt;下载&lt;br&gt;</summary>
    
    
    
    <category term="Ubuntu" scheme="https://zzygeo.cn/categories/Ubuntu/"/>
    
    
  </entry>
  
  <entry>
    <title>ubuntu下解决wps2019缺少字体问题</title>
    <link href="https://zzygeo.cn/2021/03/14/Ubuntu/ubuntu%E4%B8%8B%E8%A7%A3%E5%86%B3wps2019%E7%BC%BA%E5%B0%91%E5%AD%97%E4%BD%93%E9%97%AE%E9%A2%98/"/>
    <id>https://zzygeo.cn/2021/03/14/Ubuntu/ubuntu%E4%B8%8B%E8%A7%A3%E5%86%B3wps2019%E7%BC%BA%E5%B0%91%E5%AD%97%E4%BD%93%E9%97%AE%E9%A2%98/</id>
    <published>2021-03-13T16:56:33.000Z</published>
    <updated>2021-05-24T00:58:26.096Z</updated>
    
    <content type="html"><![CDATA[<p>主要参考<a href="https://blog.csdn.net/sunmengke1101/article/details/103436997">博客</a><br><a id="more"></a></p><h1 id="1-准备字体包"><a href="#1-准备字体包" class="headerlink" title="1.准备字体包"></a>1.准备字体包</h1><p><a href="https://wws.lanzous.com/iBIiqmwnvve">下载链接</a></p><h1 id="2-解压到指定目录下"><a href="#2-解压到指定目录下" class="headerlink" title="2.解压到指定目录下"></a>2.解压到指定目录下</h1><pre><code>sudo unzip wps_symbol_fonts.zip -d /home/&lt;user&gt;/usr/share/fonts</code></pre><h1 id="3-到解压的根目录下安装"><a href="#3-到解压的根目录下安装" class="headerlink" title="3.到解压的根目录下安装"></a>3.到解压的根目录下安装</h1><p>依次打开每个文件并点击安装即可</p><hr>]]></content>
    
    
    <summary type="html">&lt;p&gt;主要参考&lt;a href=&quot;https://blog.csdn.net/sunmengke1101/article/details/103436997&quot;&gt;博客&lt;/a&gt;&lt;br&gt;</summary>
    
    
    
    <category term="Ubuntu" scheme="https://zzygeo.cn/categories/Ubuntu/"/>
    
    
  </entry>
  
  <entry>
    <title>Ubuntu更换源教程</title>
    <link href="https://zzygeo.cn/2021/03/14/Ubuntu/Ubuntu%E6%9B%B4%E6%8D%A2%E6%BA%90%E6%95%99%E7%A8%8B/"/>
    <id>https://zzygeo.cn/2021/03/14/Ubuntu/Ubuntu%E6%9B%B4%E6%8D%A2%E6%BA%90%E6%95%99%E7%A8%8B/</id>
    <published>2021-03-13T16:34:31.000Z</published>
    <updated>2021-05-24T00:58:08.039Z</updated>
    
    <content type="html"><![CDATA[<p>参考<a href="https://blog.csdn.net/weixin_43876206/article/details/100924378">博客</a><br><a id="more"></a></p><h1 id="1-备份源列表"><a href="#1-备份源列表" class="headerlink" title="1.备份源列表"></a>1.备份源列表</h1><pre><code>sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak</code></pre><h1 id="2-打开sources-list文件"><a href="#2-打开sources-list文件" class="headerlink" title="2.打开sources.list文件"></a>2.打开sources.list文件</h1><pre><code>sudo gedit /etc/apt/sources.list</code></pre><h1 id="3-修改sources-list文件"><a href="#3-修改sources-list文件" class="headerlink" title="3.修改sources.list文件"></a>3.修改sources.list文件</h1><pre><code>#  阿里镜像源deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</code></pre><h1 id="4-更新并升级"><a href="#4-更新并升级" class="headerlink" title="4.更新并升级"></a>4.更新并升级</h1><pre><code>sudo apt-get update &amp;&amp; sudo apt-get upgrade</code></pre><h1 id="5-恢复源列表"><a href="#5-恢复源列表" class="headerlink" title="5.恢复源列表"></a>5.恢复源列表</h1><pre><code>sudo cp /etc/apt/sources.list.bak /etc/apt/sources.list</code></pre><hr><p>其他的源请自己搜索，这里只放了阿里云的。</p><hr>]]></content>
    
    
    <summary type="html">&lt;p&gt;参考&lt;a href=&quot;https://blog.csdn.net/weixin_43876206/article/details/100924378&quot;&gt;博客&lt;/a&gt;&lt;br&gt;</summary>
    
    
    
    <category term="Ubuntu" scheme="https://zzygeo.cn/categories/Ubuntu/"/>
    
    
  </entry>
  
  <entry>
    <title>github设置自己的域名</title>
    <link href="https://zzygeo.cn/2021/01/20/Hexo/github%E8%AE%BE%E7%BD%AE%E8%87%AA%E5%B7%B1%E7%9A%84%E5%9F%9F%E5%90%8D/"/>
    <id>https://zzygeo.cn/2021/01/20/Hexo/github%E8%AE%BE%E7%BD%AE%E8%87%AA%E5%B7%B1%E7%9A%84%E5%9F%9F%E5%90%8D/</id>
    <published>2021-01-20T08:30:55.000Z</published>
    <updated>2021-06-08T01:57:15.207Z</updated>
    
    <content type="html"><![CDATA[<p>哈哈，上次整了一晚上的没整明白，今天两下就整好了，看来真的进步不错哈哈，至少看东西，解决问题更有耐心也更能看懂了。<br><a id="more"></a></p><h1 id="1-购买域名"><a href="#1-购买域名" class="headerlink" title="1.购买域名"></a>1.购买域名</h1><p>我是买的阿里云的域名，如下图：<br><img src="/blog_img/github设置自己的域名/1.jpg" alt="域名"><br>域名解析如下：<br><img src="/blog_img/github设置自己的域名/2.jpg" alt="域名解析"></p><h1 id="2-github仓库设置域名地址"><a href="#2-github仓库设置域名地址" class="headerlink" title="2.github仓库设置域名地址"></a>2.github仓库设置域名地址</h1><p>在blog目录下的source文件下，创一个叫CNAME的无后缀文件，里面填入你的域名，比如我的   zzygeo.cn    如下图：<br><img src="/blog_img/github设置自己的域名/4.jpg" alt=""><br>如下图，主要是要设置博客上传分支的目录，以及更改你自己的域名（创建CNAME后自动生成），采用https加密。<br><img src="/blog_img/github设置自己的域名/3.jpg" alt=""></p><p>到此就设置完成了！</p><hr>]]></content>
    
    
    <summary type="html">&lt;p&gt;哈哈，上次整了一晚上的没整明白，今天两下就整好了，看来真的进步不错哈哈，至少看东西，解决问题更有耐心也更能看懂了。&lt;br&gt;</summary>
    
    
    
    <category term="Hexo" scheme="https://zzygeo.cn/categories/Hexo/"/>
    
    
  </entry>
  
  <entry>
    <title>pcl+vs+cmake编译</title>
    <link href="https://zzygeo.cn/2020/12/27/PCL/pcl-vs-cmake%E7%BC%96%E8%AF%91/"/>
    <id>https://zzygeo.cn/2020/12/27/PCL/pcl-vs-cmake%E7%BC%96%E8%AF%91/</id>
    <published>2020-12-27T14:50:27.000Z</published>
    <updated>2021-05-24T00:59:31.373Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇写的配置可能是最基础的，也是很麻烦，其实可以用cmake来偷个懒，这样就不用附加依赖性已经加入库目录和包含目录了。<br><a id="more"></a></p><h1 id="1-软件准备"><a href="#1-软件准备" class="headerlink" title="1.软件准备"></a>1.软件准备</h1><p>1.All in one 安装包。</p><p>2.获取All in one 包对应得PDB文件包，用于后期单步调试。</p><p>3.安装Visual studio 2019编译器</p><p>4.cmake<br><img src="/blog_img/PCL配置/17.png" alt="示意图"><br><img src="/blog_img/PCL配置/1.jpg" alt="示意图"></p><p>其实源码包用不上，懒得改了，最复杂的方式就是源代码加第三方库进行配置，等我配置好了也会再一篇关于源码方式的配置。</p><hr><h1 id="2-链接"><a href="#2-链接" class="headerlink" title="2.链接"></a>2.链接</h1><p><a href="https://github.com/PointCloudLibrary/pcl/releases">pcl下载地址</a><br><a href="https://visualstudio.microsoft.com/zh-hans/downloads/">visual studio下载地址</a><br><a href="https://cmake.org/download/">cmake下载地址</a></p><hr><h1 id="3-安装事项"><a href="#3-安装事项" class="headerlink" title="3.安装事项"></a>3.安装事项</h1><p>为了方便配置，pcl安装目录尽量默认，不默认后续添加目录需要选择对应的位置。</p><p>pcl安装请一定选择创建系统路径，visual studio和cmake安装位置随意，其他选项默认即可。</p><p>pcl安装完成后，请把下载的pcd文件解压，如下图：<br><img src="/blog_img/PCL配置/2.jpg" alt=""></p><p>将所有文件复制，安装到pcl下的BIN文件下<br><img src="/blog_img/PCL配置/3.jpg" alt=""></p><p>检查pcl安装目录下的 3rdParty-OpenNI2是否只有一个安装包（我的是这样），这可能是事先安装过SDK的原因，请卸载了重新安装在OpenNI2下，安装完成如下图：<br><img src="/blog_img/PCL配置/4.jpg" alt=""></p><p>cmake 安装请选择添加到系统路径，没选的话也可以自己手动添加，添加的方式为cmake目录下bin文件  比如C:\APP\Cmake\bin这样的形式。</p><hr><h1 id="4-关于Visual-studio安装项目"><a href="#4-关于Visual-studio安装项目" class="headerlink" title="4.关于Visual studio安装项目"></a>4.关于Visual studio安装项目</h1><p>我安装了这些负载</p><p><img src="/blog_img/PCL配置/5.png" alt=""></p><hr><h1 id="5-环境配置"><a href="#5-环境配置" class="headerlink" title="5.环境配置"></a>5.环境配置</h1><p>右键我的电脑——高级系统设置-环境变量，在path选项下新建如下几项，根据你pcl安装的位置来：<br><img src="/blog_img/PCL配置/6.jpg" alt=""></p><p>比如我的：<br>C:\Program Files\PCL 1.11.0\bin<br>C:\Program Files\PCL 1.11.0\3rdParty\FLANN\bin<br>C:\Program Files\PCL 1.11.0\3rdParty\Qhull\bin<br>C:\Program Files\PCL 1.11.0\3rdParty\VTK\bin<br>C:\Program Files\PCL 1.11.0\3rdParty\OpenNI2\Tools<br>C:\Program Files\PCL 1.11.0\3rdParty\OpenNI2\Redist</p><p>在系统变量下，配置如下图：<br><img src="/blog_img/PCL配置/6.png" alt=""><br>比如我的：<br>C:\Program Files\PCL 1.11.0\3rdParty\FLANN\bin<br>C:\Program Files\PCL 1.11.0\3rdParty\OpenNI2\Tools<br>C:\Program Files\PCL 1.11.0\3rdParty\Qhull\bin<br>C:\Program Files\PCL 1.11.0\3rdParty\VTK\bin<br>C:\Program Files\PCL 1.11.0\bin</p><hr><h1 id="6-cmake编译"><a href="#6-cmake编译" class="headerlink" title="6.cmake编译"></a>6.cmake编译</h1><p>以管理员身份运行cmake-gui<br>在你想要的文件下创建一个名为example的文件夹，然后在此目录下创建一个source和cmake_bin文件，比如我的：</p><p><img src="/blog_img/PCL配置/18.png" alt=""></p><p>在source里面创建一个cpp文件和CMakeLists.txt文件。<br>CmakeLists.txt里写入以下内容：</p><pre><code>cmake_minimum_required(VERSION 2.6 FATAL_ERROR)project(test)find_package(PCL 1.4 REQUIRED)include_directories($&#123;PCL_INCLUDE_DIRS&#125;)link_directories($&#123;PCL_LIBRARY_DIRS&#125;)  add_definitions($&#123;PCL_DEFINITIONS&#125;)add_executable (test test.cpp)target_link_libraries (test $&#123;PCL_LIBRARIES&#125;)</code></pre><p>其中这个test就是你创建的测试代码的名字，请保持一致，如果你换别的名字，请把txt文件的名字也一起改了。我的如下：<br><img src="/blog_img/PCL配置/19.png" alt=""></p><p>测试代码请网上去找，我用的是上一篇文件里的（里面有个D盘文件的读取可能会报错，但只要能出彩色的那个图就算配置成功了）。</p><p>跟着步骤添加<br><img src="/blog_img/PCL配置/20.png" alt=""></p><p>点击Configure，选x64<br><img src="/blog_img/PCL配置/21.jpg" alt=""></p><p>再点击一次configure<br><img src="/blog_img/PCL配置/22.jpg" alt=""></p><p>点击Generate,出现Generating done.<br><img src="/blog_img/PCL配置/23.png" alt=""></p><p>找到cmake_bin底下的test_sln 打开。<br><img src="/blog_img/PCL配置/24.jpg" alt=""></p><p>将test设置为启动项，并调试。<br><img src="/blog_img/PCL配置/25.png" alt=""></p><p><img src="/blog_img/PCL配置/26.jpg" alt=""></p><hr>]]></content>
    
    
    <summary type="html">&lt;p&gt;上一篇写的配置可能是最基础的，也是很麻烦，其实可以用cmake来偷个懒，这样就不用附加依赖性已经加入库目录和包含目录了。&lt;br&gt;</summary>
    
    
    
    <category term="Ubuntu" scheme="https://zzygeo.cn/categories/Ubuntu/"/>
    
    
  </entry>
  
</feed>
