<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>我说个数，1500W</title>
  
  
  <link href="https://zzygeo.cn/atom.xml" rel="self"/>
  
  <link href="https://zzygeo.cn/"/>
  <updated>2021-05-24T04:58:03.663Z</updated>
  <id>https://zzygeo.cn/</id>
  
  <author>
    <name>Regular</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>面向对象高级部分</title>
    <link href="https://zzygeo.cn/2021/05/24/Java%E5%9F%BA%E7%A1%80/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/"/>
    <id>https://zzygeo.cn/2021/05/24/Java%E5%9F%BA%E7%A1%80/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/</id>
    <published>2021-05-24T02:49:32.000Z</published>
    <updated>2021-05-24T04:58:03.663Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-类变量和类方法"><a href="#1-类变量和类方法" class="headerlink" title="1.类变量和类方法"></a>1.类变量和类方法</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><img src="https://raw.githubusercontent.com/zzygeo/images/master/image-20210512202025523.5b1j2jak19s0.png" alt="image-20210512202025523"></p><p>==类变量可以通过类名直接来访问==</p><p>==堆区 or 静态域==，需要看jdk的版本</p><p><img src="https://raw.githubusercontent.com/zzygeo/images/master/image-20210512203343915.2grguwvuy960.png" alt="image-20210512203343915"></p><p>==不管static变量在哪里，共识（1）static变量是同一个类所有对象共享 （2）static类变量，在类加载的时候就生成了==</p><pre><code class="lang-java">package com.zzy.static_;public class VisitStatic &#123;    public static void main(String[] args) &#123;        //类变量是随着类的加载创建的,不创建对象实例也可以访问        System.out.println(A.name);    &#125;&#125;class A&#123;    public static String name = &quot;韩顺平教育&quot;;&#125;</code></pre><p>==加上static称为类变量或静态变量，否则称为实例变量/普通变量/非静态变量==</p><p>==类方法也可以通过类名进行访问==</p><h2 id="类方法的使用场景"><a href="#类方法的使用场景" class="headerlink" title="类方法的使用场景"></a>类方法的使用场景</h2><p><img src="https://raw.githubusercontent.com/zzygeo/images/master/image-20210512210404632.1v296c255aw0.png" alt="image-20210512210404632"></p><h2 id="类方法的细节"><a href="#类方法的细节" class="headerlink" title="类方法的细节"></a>类方法的细节</h2><p><img src="https://raw.githubusercontent.com/zzygeo/images/master/image-20210512210636540.46e97zs0p440.png" alt="image-20210512210636540"></p><p><img src="https://raw.githubusercontent.com/zzygeo/images/master/image-20210512210908683.46g10ymx9a00.png" alt="image-20210512210908683"></p><p>==根据加载的时间来的，类在创建的时候，类变量和类方法就已经有了==，而普通变量和普通方法是在类实例的时候才出现</p><h1 id="2-理解main方法语法"><a href="#2-理解main方法语法" class="headerlink" title="2.理解main方法语法"></a>2.理解main方法语法</h1><p><img src="https://raw.githubusercontent.com/zzygeo/images/master/image-20210512213729148.5ze5kknxs200.png" alt="image-20210512213729148"></p><p><img src="https://raw.githubusercontent.com/zzygeo/images/master/image-20210512213846089.6jjxl371zzw0.png" alt="image-20210512213846089"></p><p>如果想在idea中也给args字符串数组传入字符串，需要在以下的窗口去传入</p><p><img src="https://raw.githubusercontent.com/zzygeo/images/master/image-20210512214659162.478kzo8tjtw0.png" alt="image-20210512214659162"></p><h1 id="3-代码块"><a href="#3-代码块" class="headerlink" title="3.代码块"></a>3.代码块</h1><h2 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h2><p><img src="https://raw.githubusercontent.com/zzygeo/images/master/image-20210512215021484.7ems24jyeeo0.png" alt="image-20210512215021484"></p><p><img src="https://raw.githubusercontent.com/zzygeo/images/master/image-20210512215117763.74f7ofaugik0.png" alt="image-20210512215117763"></p><pre><code class="lang-java">package com.zzy.codeblock_;public class CodeBlock01 &#123;    public static void main(String[] args) &#123;        Movie movie1 = new Movie(&quot;你好，李焕英&quot;);    &#125;&#125;class Movie&#123;    private String name;    private double price;    private String director;    //3个构造器，函数重载    //3个构造器都有相同的语句，代码看起来比较冗余    //可以将相同的语句放入代码块中,不管调用哪个构造器创建对象，都会先调用代码块的内容    //代码块调用的顺序优先于构造器    &#123;        System.out.println(&quot;电影屏幕打开...&quot;);        System.out.println(&quot;广告开始...&quot;);        System.out.println(&quot;电影正式开始...&quot;);    &#125;    public Movie(String name) &#123;        System.out.println(&quot;Movie(String name)构造器被调用&quot;);        this.name = name;    &#125;    public Movie(double price, String director) &#123;        this.price = price;        this.director = director;    &#125;    public Movie(String name, double price, String director) &#123;        this.name = name;        this.price = price;        this.director = director;    &#125;&#125;</code></pre><p>输出结果</p><p><img src="https://raw.githubusercontent.com/zzygeo/images/master/image-20210512220748122.4iqixdml1fu0.png" alt="image-20210512220748122"></p><h2 id="代码块使用注意事项"><a href="#代码块使用注意事项" class="headerlink" title="代码块使用注意事项"></a>代码块使用注意事项</h2><p>（1）static代码块也叫静态代码块，作用就是对类进行初始化，==而且它随着类的加载而执行，并且只会执行一次。如果是普通代码块，每创建一个对象，就执行。==</p><p>（2）类什么时候被加载（重要）</p><ol><li>==创建对象实例时（new）==</li><li>==创建子类对象实例，父类也被会加载,父类先被加载，子类后被加载==</li><li>==使用类的静态成员时（静态属性，静态方法）==</li></ol><p>创建一个对象时，在一个类调用的顺序是：</p><ol><li>==调用静态代码块和静态属性初始化（静态代码块和静态属性初始化调用的优先级一样，如果有多个静态代码块和多个静态变量初始化，则按他们定义的顺序调用）==</li><li>==调用普通代码块和普通属性的初始化（普通代码块和普通属性初始化调用的优先级一样，如果有多个普通代码块和多个普通属性初始化，则按定义顺序调用）==</li><li>==调用构造方法==</li><li>==构造器的最前面其实隐含了super()和调用普通代码块==</li><li>当创建一个子类对象时（继承关系），他们的静态代码块，静态属性初始化，普通代码块，普通属性初始化，构造方法的调用顺序如下：</li></ol><ul><li>==父类的静态代码块和静态属性（优先级一样，按定义顺序执行）==</li><li>==子类的静态代码块和静态属性（优先级一样，按定义顺序执行）==</li><li>==父类的普通代码块和普通属性初始化（优先级一样，按定义顺序执行）==</li><li>==父类的构造方法==</li><li>==子类的普通代码块和普通属性初始化（优先级一样，按定义顺序执行）==</li><li>==子类的构造方法==</li></ul><pre><code class="lang-java">package com.zzy.codeblock_;public class CodeBlockDetail03 &#123;    public static void main(String[] args) &#123;        B b = new B();    &#125;&#125;class A&#123;    public A()&#123;        System.out.println(&quot;A的无参构造器调用&quot;); //6    &#125;    public static int n1 = getN1();    public static int getN1()&#123;        System.out.println(&quot;A的静态属性的调用&quot;); //1        return 100;    &#125;    static &#123;        System.out.println(&quot;A类的静态代码块的调用&quot;); //2    &#125;    &#123;        System.out.println(&quot;A类的普通代码块调用&quot;); //5    &#125;&#125;class B extends A&#123;    public B()&#123;        System.out.println(&quot;B类的无参构造器&quot;); //8    &#125;    public static int N2 = getN2();    public static int getN2()&#123;        System.out.println(&quot;B类的静态属性调用&quot;); //3        return 200;    &#125;    static &#123;        System.out.println(&quot;B类的静态代码块调用&quot;); //4    &#125;    &#123;        System.out.println(&quot;B类的普通代码块调用&quot;); //7    &#125;&#125;</code></pre><h1 id="4-设计模式"><a href="#4-设计模式" class="headerlink" title="4.设计模式"></a>4.设计模式</h1><h2 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h2><p>静态方法和属性的经典使用</p><p>设计模式是在大量的实践中总结和理论化之后优选的代码结构、编程风格、以及解决问题的思考方式。设计模式就像是经典的棋谱，不同的棋局，我们用不同的棋谱，免去我们自己再思考和摸索。</p><p>单例模式</p><p>1.所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能==存在一个对象实例==，并且该类==只提供一个取得其对象实例==的方法</p><p>2.单例模式有两种 1）饿汉式 2）懒汉式</p><h2 id="饿汉式的单例模式"><a href="#饿汉式的单例模式" class="headerlink" title="饿汉式的单例模式"></a>饿汉式的单例模式</h2><p>步骤如下:</p><p>1)构造器私有化 =》防止直接new</p><p>2)类的内部创建对象</p><p>3)向外暴露一个静态的公共方法</p><p>4)代码实现</p><pre><code class="lang-java">package com.zzy.Single_;public class SingleTon01 &#123;    public static void main(String[] args) &#123;        GirlFriend instance1 = GirlFriend.getInstance();        System.out.println(instance1);        GirlFriend instance2 = GirlFriend.getInstance();        System.out.println(instance2);    &#125;&#125;//只能有一个女朋友class GirlFriend&#123;    private String name;    //内部创建一个私有的    private static GirlFriend girl = new GirlFriend(&quot;小红&quot;);    //如何防止只能创建一个女朋友    private GirlFriend(String name)&#123;        this.name = name;    &#125;    public static GirlFriend getInstance()&#123;        return girl;    &#125;    @Override    public String toString() &#123;        return &quot;GirlFriend&#123;&quot; +                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +                &#39;&#125;&#39;;    &#125;&#125;</code></pre><h2 id="懒汉式的单例模式"><a href="#懒汉式的单例模式" class="headerlink" title="懒汉式的单例模式"></a>懒汉式的单例模式</h2><p>1)仍然构造器私有化</p><p>2)定义一个静态属性对象</p><p>3)提供一个public的static方法，可以返回一个Cat对象</p><p>4)只有当用户使用getInstance时，才返回cat对象，后面再次调用时，会返回上次创建的cat对象</p><p>饿汉式VS懒汉式</p><ol><li>二者最主要的区别在于创建对象的时机不同：饿汉式是在类加载就创建了对象实例，而懒汉式是在使用时（调用instance）才创建。</li><li>饿汉式不存在线程安全的问题，懒汉式存在线程安全的问题（后面学习线程后，在进行完善）</li><li>饿汉式存在浪费资源的可能。因为如果一个程序员一个对象实例都没有使用，那么饿汉式创建的对象就浪费了，懒汉式是使用时才创建，不存在这个问题。</li><li>在javaSE标准中, java.lang.Runtime就是经典的单例模式</li></ol><h1 id="5-final关键字"><a href="#5-final关键字" class="headerlink" title="5.final关键字"></a>5.final关键字</h1><h2 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h2><p>final可以修饰类、属性、方法和局部变量</p><p>在某些情况下，程序员可能有以下需求，就会使用到final：</p><p>1)当==不希望类被继承==时，可以用final修饰</p><p>2)当==不希望父类的某个方法被子类覆盖/重写==时，可以使用final关键字修饰。</p><p>3)当==不希望类的某个属性的值被修改==，可以用final修饰</p><p>4)当==不希望某个局部变量被修改==（比如函数里），可以使用final修饰</p><h2 id="final的使用细节"><a href="#final的使用细节" class="headerlink" title="final的使用细节"></a>final的使用细节</h2><p>1）final修饰的属性又叫常量，一般用XX_XX_XX来命名</p><p>2）final修饰的属性==在定义时，必须赋初值==，并且==以后不能再修改==，赋值可以加在如下位置之一【选择一个位置赋初值即可】</p><ul><li>==定义时==，如 public final double TAX_RATE = 0.08;</li><li>==在构造器中==</li><li>==在代码块中==</li></ul><p>3）如果==final修饰的属性是静态的==，则初始化的位置只能是 ==1. 定义时 2. 在静态代码块== 而不能在构造器中赋值(==参考类加载的先后顺序==)。</p><p>4）==final类不能继承，但是可以实例化对象==</p><p>5）如果类不是final类，但是含有final方法，则该方法虽然不可以重写，但是可以被继承。</p><pre><code class="lang-java">package com.zzy.final_;public class Final01 &#123;    public static void main(String[] args) &#123;        //final不可以继承，但是可以实例化对象        System.out.println(Test02.num);        //final方法虽然不能被重写，但是可以被继承        Test04 test04 = new Test04();        test04.say();    &#125;&#125;class Test01&#123;    public final double TAX_RATE = 0.08; //1.在定义时赋值    public final double TAX_RATE1;    public final double TAX_RATE2;    public static final double TAX_RATE3 = 0.01; //修饰静态属性，可以在定义时赋值    public static final double TAX_RATE4; //修饰静态属性，可以在定义时赋值    public Test01()&#123;//2.在构造器中赋值        TAX_RATE1 = 0.8;    &#125;    static&#123;        TAX_RATE4 = 0.04; //在静态代码块中可行    &#125;    &#123;        //3.在代码块中赋值        TAX_RATE2 = 0.1;    &#125;&#125;final class Test02&#123;    public static int num = 5;&#125;class Test03&#123;    public final void say()&#123;        System.out.println(&quot;Test03类的say方法&quot;);    &#125;&#125;class Test04 extends Test03&#123;    public double val = 5.0;&#125;</code></pre><p>5）一般来说，如果==一个类已经是final类了，就没有必要再将方法修饰成final==方法。</p><p>6）==final不能修饰构造器==</p><p>7）==final和static往往搭配使用==，效率更高，不会导致类加载，底层编译器做了优化处理</p><p>8）包装类（Integer,Double，Float, Boolean等都是final），String也是final方法</p><pre><code class="lang-java">package com.zzy.final_;public class Final &#123;    public static void main(String[] args) &#123;        //不会导致类加载        System.out.println(Test05.num);    &#125;&#125;class Test05&#123;    public final static int num = 5;    static&#123;        System.out.println(&quot;Test05的静态代码块&quot;);    &#125;&#125;</code></pre><h1 id="6-抽象类"><a href="#6-抽象类" class="headerlink" title="6.抽象类"></a>6.抽象类</h1><h2 id="介绍-4"><a href="#介绍-4" class="headerlink" title="介绍"></a>介绍</h2><p>当父类的一些方法不能确定时，可以用abstract关键字来修饰该方法，这个方法就是抽象方法，用abstract来修饰该类就是抽象类</p><p>1）用abstract关键字来修饰一个类时，这个类就叫抽象类</p><p>2）用abstract关键字来修饰一个方法时，这个方法就是抽象方法</p><p>访问修饰符 abstract 返回类型 方法名(参数列表)； //没有方法体</p><p>3）==抽象类的价值更多作用是在于设计，是设计者设计好后，让子类继承并实现抽象类==</p><p>4）抽象类，是面试比较爱问的知识点，在框架和设计模式使用较多</p><h2 id="抽象类的细节"><a href="#抽象类的细节" class="headerlink" title="抽象类的细节"></a>抽象类的细节</h2><p>1）抽象类==不能被实例化==</p><p>2）抽象类不一定要包含abstract方法。也就是说，抽象类可以没有abstract方法</p><p>3）一旦类==包含了abstract方法，则这个类必须声明为abstract==</p><p>4）abstract==只能修饰类和方法，不能修饰属性和其他的==</p><p>5）抽象类可以由任意成员【因为抽象类还是类】，比如：非抽象方法，构造器，静态属性等</p><p>6）==抽象方法不能有主体==，即不能实现</p><p>7）如果==一个类继承了抽象类，则它必须实现抽象类的所有抽象方法==，==除非它自己也声明为abstract类==。</p><p>8）抽象方法不能使用private、final、static来修饰，因为这些关键字都是和重写违背的</p><pre><code class="lang-java">package com.zzy.Animal;public class AbstractDetails &#123;    public static void main(String[] args) &#123;        //抽象类，不能被初始化        //new A();    &#125;&#125;abstract class A&#123;//抽象类的方法可以不抽象化    public void hi()&#123;        System.out.println(&quot;hi&quot;);    &#125;&#125;//一旦类包含了abstract方法，则这个类必须声明为abstractabstract class B&#123;    public abstract void hi();&#125;class C&#123;    //abstract只能修饰类和方法，不能修饰其他的    //public abstract int n1 = 5;&#125;</code></pre><pre><code class="lang-java">package com.zzy.Animal;public class AbstractDetails01 &#123;    public static void main(String[] args) &#123;    &#125;&#125;abstract class E&#123;    public abstract void hi();&#125;abstract class F extends E&#123;    //除非自己也声明为abstract类&#125;class G extends E&#123;    @Override    public void hi() &#123;//这里相当于重写父类E的抽象方法        System.out.println(&quot;话不投机，说你妈逼&quot;);    &#125;&#125;</code></pre><h2 id="抽象类最佳实践-模板设计模式"><a href="#抽象类最佳实践-模板设计模式" class="headerlink" title="抽象类最佳实践-模板设计模式"></a>抽象类最佳实践-模板设计模式</h2><p>需求</p><p>1）有多个类，完成不同的任务job</p><p>2）要求能够得到各自完成任务的时间</p><p>感情的自然流露</p><ol><li>先用最容易想到的方法</li><li>分析问题，提出使用模板设计模式</li></ol><p>父类</p><pre><code class="lang-java">package com.zzy.Animal;abstract public class Template &#123;    public abstract void job();    public void calculateTime()&#123;        long start = System.currentTimeMillis();        job(); //这里涉及到动态绑定机制        long end = System.currentTimeMillis();        System.out.println(&quot;任务运行时间为：&quot; + (end - start));    &#125;&#125;</code></pre><p>父类AA</p><pre><code class="lang-java">package com.zzy.Animal;public class AA extends Template&#123;    //计算任务    //从1加到10000    public void job()&#123;        long num = 0;        for (long i = 1; i &lt;= 800000; i++) &#123;            num += i;        &#125;    &#125;&#125;</code></pre><p>子类BB</p><pre><code class="lang-java">package com.zzy.Animal;public class BB extends Template&#123;    public void job()&#123;        long num = 0;        for (long i = 1; i &lt;= 80000; i++) &#123;            num *= i;        &#125;    &#125;&#125;</code></pre><p>测试类</p><pre><code class="lang-java">package com.zzy.Animal;public class TestTemplate &#123;    public static void main(String[] args) &#123;        AA aa = new AA();        aa.calculateTime();        BB bb = new BB();        bb.calculateTime();    &#125;&#125;</code></pre><h1 id="7-接口"><a href="#7-接口" class="headerlink" title="7.接口"></a>7.接口</h1><h2 id="介绍-5"><a href="#介绍-5" class="headerlink" title="介绍"></a>介绍</h2><p><img src="https://raw.githubusercontent.com/zzygeo/images/master/1621823722.5mjdgmqmdco0.jpg" alt="1621823722"></p><h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><p>1）接口不能被实例化</p><p>2）接口中的所有方法是public方法，接口中抽象方法，可以不用abstract修饰</p><p>3）一个普通类实现接口，就必须将该接口的所有方法都实现</p><p>4）抽象了实现接口，可以不用实现接口的方法</p><p>5）一个类同时可以实现多个接口</p><p>6）接口中的属性，只能是final的，而且是public static final 修饰符，因此必须初始化</p><p>7）接口中属性的访问形式：接口名.属性名</p><p>8）接口不能继承其他的类，但是可以继承多个别的接口</p><p>9）接口的修饰符只能是public和默认，这一点和类的修饰符是一样的</p><p>接口和继承解决的问题不同</p><p>继承的价值主要在于：解决代码的复用性和可维护性</p><p>接口的价值主要在于：设计，设计好各种规范，让其他类去实现这些方法。即更加的灵活</p><p>接口比继承更加灵活</p><p>接口比继承更加灵活，继承是满足is -a的关系, 而接口只 需满足 like -a的关系</p><p>接口在一定程度上实现代码解耦（即：接口规范性+动态绑定机制）</p><h2 id="接口的多态特性"><a href="#接口的多态特性" class="headerlink" title="接口的多态特性"></a>接口的多态特性</h2><p>接口既可以接受A对象，又可以接受相机对象，就体现了接口，多态</p><p>一个接口的数组里，既可以存放A对象，也可以存放B对象，也体现了多态特性，这里还设计到向上转型和向下转型</p><p>接口存在多态传递现象</p><h1 id="8-内部类"><a href="#8-内部类" class="headerlink" title="8.内部类"></a>8.内部类</h1><h2 id="介绍-6"><a href="#介绍-6" class="headerlink" title="介绍"></a>介绍</h2><p>如果定义类在局部位置（方法/代码块）：（1）局部内部类 （2）匿名内部类</p><p>定义在成员位置：（1）成员内部类 （2）静态内部类</p><p>一个类的内部类又完整的嵌套了另一个类结构 。被嵌套的类称为内部类（inner class），嵌套其他类的类称为外部类（outer class）。是我们类的第五大成员，内部类的最大特点就是可以直接访问私有属性，并且可以体现类和类之间的包含关系，是学习的难点。</p><p>入门代码：</p><pre><code class="lang-java">package com.zzy.innerclass;public class InnerClass01 &#123;//外部其他类    public static void main(String[] args) &#123;    &#125;&#125;class Outer&#123;//外部类    private int n1 = 100;    public void m1()&#123;        System.out.println(&quot;m1()&quot;);    &#125;    public Outer(int n1) &#123;        this.n1 = n1;    &#125;    &#123;        System.out.println(&quot;Outer的代码块哦&quot;);    &#125;    class Inner&#123;        //内部类    &#125;&#125;</code></pre><h2 id="局部内部类的使用"><a href="#局部内部类的使用" class="headerlink" title="局部内部类的使用"></a>局部内部类的使用</h2><p>局部内部类是定义在外部类的局部位置，比如方法中，并且有类名</p><ol><li>可以直接访问外部类的所有成员，包含私有的</li><li>不能添加访问修饰符，因为它的地位就是一个局部变量。局部变量是不能使用修饰符的。但是可以使用final修饰，因为局部变量也可以使用final</li><li>作用域：仅仅在定义它的方法或者代码块中</li><li>局部访问类—访问外部类的成员—可以==直接访问==</li><li>外部类—访问—局部内部类成员   访问方式：创建对象，再访问</li><li>外部其他类—不能访问—局部内部类（因为局部内部类也是一个局部变量）</li><li>如果外部类和局部内部类的成员重名，默认遵守就近原则，如果想访问外部类的成员，可以使用（外部类名.this.成员）去访问</li></ol><p>记住：</p><ul><li>局部内部类定义在方法中/代码块</li><li>作用域在方法体或者代码块中</li><li>本质仍然是一个类</li></ul><pre><code class="lang-java">package com.zzy.innerclass;/*演示局部内部类 */public class LocalInnerClass &#123;    public static void main(String[] args) &#123;        Outer02 outer02 = new Outer02();        outer02.m1();        System.out.println(&quot;outer02 hashcode = &quot; + outer02);    &#125;&#125;class Outer02&#123;    private int n1 = 100;    private void m2()&#123;        System.out.println(&quot;m2()&quot;);    &#125;    public void m1()&#123;//方法        //局部内部类是定义在外部类的局部位置，通常在方法        class Inner02&#123;            //局部内部类            //可以直接访问外部内的所有成员，包含私有的            //局部内部类的作用域在定义的方法或者代码块里面            private int n1 = 800;            public void f1()&#123;                System.out.println(&quot;n1 = &quot; + n1 + &quot; n1 = &quot; + Outer02.this.n1);                System.out.println(&quot;Outer02.this hashcode = &quot; + Outer02.this);                m2();            &#125;        &#125;        //外部类在方法中，可以创建Inner02对象的实例，然后调用方法        Inner02 inner02 = new Inner02();        inner02.f1();    &#125;&#125;</code></pre><h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><p>（1）本质是类 （2）内部类 （3）该类没有名字（其实是类名加$） (4)同时还是一个对象</p><p>匿名内部类是定义在外部类的局部位置，比如方法中，并且没有类名</p><pre><code class="lang-java">package com.zzy.innerclass;/** * 演示匿名内部类的使用 */public class AnonymousInnerClass &#123;    public static void main(String[] args) &#123;        Outer04 outer04 = new Outer04();        outer04.method();    &#125;&#125;class Outer04&#123;//外部类    private int n1 = 10;    public void method()&#123;        //基于接口的匿名内部类        //这个基于接口的类我只使用一次就不用了,则在其他外部类去写这个类有点浪费        //可以使用匿名内部类来简化开发        //编译类型？ IA        //运行类型：是系统自动分配的，但是可以用类.getclass()进行查看        //jdk底层在创建匿名内部类的时候，立马就创建了Outer$1的实例，并且把地址返回给接收new对象的对象        //匿名内部类只能使用一次，注意区别实例和匿明内部类的区别        IA tiger = new  IA()&#123;            @Override            public void cry()&#123;                System.out.println(&quot;老虎叫唤...&quot;);            &#125;        &#125;;        System.out.println(&quot;tiger的运行类型：&quot; + tiger.getClass());        tiger.cry();        //基于类的匿名内部类        Father baba = new Father(&quot;baba&quot;)&#123;            @Override            public void test() &#123;                System.out.println(&quot;匿名内部类重写了test方法&quot;);            &#125;        &#125;;        System.out.println(&quot;baba的运行类型&quot; + baba.getClass());        baba.test();    &#125;&#125;interface IA&#123;//接口    public abstract void cry();&#125;class Father&#123;    public Father(String name)&#123;//构造器    &#125;    public void test()&#123;//方法        System.out.println(&quot;父类的test方法&quot;);    &#125;&#125;</code></pre><h2 id="匿名内部类的使用细节"><a href="#匿名内部类的使用细节" class="headerlink" title="匿名内部类的使用细节"></a>匿名内部类的使用细节</h2><ol><li>匿名内部类的语法比较奇特，它既是一个类的定义，同时本身也是一个对象，从语法上，它既有定义类的特征，也有创建对象的特征</li><li>可以直接访问外部类的所有成员，包含私有的</li><li>不能添加访问修饰符，因为它的地位就是一个局部变量</li><li>作用域：仅仅定义在它的方法或者代码块中</li><li>匿名内部类—访问—&gt;外部类成员【直接访问】</li><li>外部其他类—不能访问—&gt;匿名内部类【因为匿名内部类地位是一个局部变量】</li><li>如果外部类和匿名内部类的成员重名时，匿名内部类访问的话，遵循就近一致原则，如果想访问外部类的成员，可以使用（外部类名.this.成员）去访问</li></ol><pre><code class="lang-java">package com.zzy.innerclass;public class AnonymousInnerClassDetails &#123;    public static void main(String[] args) &#123;        Outer05 outer05 = new Outer05();        outer05.f1();    &#125;&#125;class Outer05&#123;    private int n1 = 99;    public void f1()&#123;        //创建一个基于类的匿名内部类        Person person = new Person()&#123;//编译类型Person,运行类型是匿名对象            @Override            public void hi()&#123;                System.out.println(&quot;匿名内部类重写了 hi方法&quot;);            &#125;        &#125;;        person.hi();        new Person()&#123;//编译类型Person,运行类型是匿名对象            @Override            public void hi()&#123;                System.out.println(&quot;匿名内部类重写了 hi方法&quot;);            &#125;            @Override            public void ok(String name) &#123;                super.ok(name);            &#125;        &#125;.ok(&quot;小周&quot;);    &#125;&#125;class Person&#123;    public void hi()&#123;        System.out.println(&quot;Person hi()&quot;);    &#125;    public void ok(String name)&#123;        System.out.println(&quot;name = &quot; + name);    &#125;&#125;</code></pre><h2 id="匿名内部类的最佳实践"><a href="#匿名内部类的最佳实践" class="headerlink" title="匿名内部类的最佳实践"></a>匿名内部类的最佳实践</h2><p>当做实参直接传递，简洁高效</p><pre><code class="lang-java">package com.zzy.innerclass;public class InnerClassExercise01 &#123;    public static void main(String[] args) &#123;        f1(new AA() &#123;//当做实参直接传递，简洁高效            @Override            public void show() &#123;                System.out.println(&quot;匿名内部类&quot;);            &#125;        &#125;);    &#125;    //静态方法,形参是接口类型    public static void f1(AA aa)&#123;        aa.show();    &#125;&#125;interface AA&#123;    public abstract void show();&#125;</code></pre><pre><code class="lang-java">package com.zzy.innerclass;public class InnerClassExercise02 &#123;    public static void main(String[] args) &#123;        alarmclock(new Bell() &#123;//匿名内部类作为实参            @Override            public void ring() &#123;                System.out.println(&quot;懒猪起床了&quot;);            &#125;        &#125;);        alarmclock(new Bell() &#123;            @Override            public void ring() &#123;                System.out.println(&quot;小伙伴上课了&quot;);            &#125;        &#125;);    &#125;    public static void alarmclock(Bell bell)&#123;        bell.ring();    &#125;&#125;interface Bell&#123;    public abstract void ring();&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-类变量和类方法&quot;&gt;&lt;a href=&quot;#1-类变量和类方法&quot; class=&quot;headerlink&quot; title=&quot;1.类变量和类方法&quot;&gt;&lt;/a&gt;1.类变量和类方法&lt;/h1&gt;&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="Java基础" scheme="https://zzygeo.cn/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>IDEA快捷键</title>
    <link href="https://zzygeo.cn/2021/05/24/Java%E5%9F%BA%E7%A1%80/IDEA%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>https://zzygeo.cn/2021/05/24/Java%E5%9F%BA%E7%A1%80/IDEA%E5%BF%AB%E6%8D%B7%E9%94%AE/</id>
    <published>2021-05-24T02:48:12.000Z</published>
    <updated>2021-05-24T02:49:01.649Z</updated>
    
    <content type="html"><![CDATA[<p>查看类的结构：ctrl+f12</p><p>查看类的继承图：ctrl+alt+shift+u</p><p>查看函数参数：ctrl+p</p><p>格式化代码：ctrl+shift+l</p><p>代码补全：alt+/</p><p>提示关键字：alt+shift+/</p><p>万能结错/生成返回值变量：alt+enter</p><p>查看继承结构：ctrl+h</p><p>反撤销：ctrl+shift+z</p><p>大小写转换：ctrl+shift+u</p><p>收起所有的方法：ctrl+shift+-</p><p>打开所有的方法：ctrl+shfit++</p><p>重命名：shift+f6</p><p>打开文件所在位置：ctrl+shift+x</p><p>生成try-catch等：ctrl+alt+t</p><p>局部变量抽取为成员变量：ctrl+alt+f</p><p>添加到收藏夹：alt+shift+f</p><p>搜索类中的错误：f2</p><p>复制选取：ctrl+shift+v</p><p>显示方法在哪调用过：ctrl+shift+h</p><p>快写构造函数：alt+insert</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;查看类的结构：ctrl+f12&lt;/p&gt;
&lt;p&gt;查看类的继承图：ctrl+alt+shift+u&lt;/p&gt;
&lt;p&gt;查看函数参数：ctrl+p&lt;/p&gt;
&lt;p&gt;格式化代码：ctrl+shift+l&lt;/p&gt;
&lt;p&gt;代码补全：alt+/&lt;/p&gt;
&lt;p&gt;提示关键字：alt+shift+/</summary>
      
    
    
    
    <category term="Java基础" scheme="https://zzygeo.cn/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>dpkg被中断的解决办法</title>
    <link href="https://zzygeo.cn/2021/03/14/Ubuntu/dpkg%E8%A2%AB%E4%B8%AD%E6%96%AD%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <id>https://zzygeo.cn/2021/03/14/Ubuntu/dpkg%E8%A2%AB%E4%B8%AD%E6%96%AD%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</id>
    <published>2021-03-13T17:40:02.000Z</published>
    <updated>2021-05-24T00:57:48.469Z</updated>
    
    <content type="html"><![CDATA[<p>linux系统安装软件是有时会碰到“dpkg 被中断,您必须手工运行 sudo dpkg –configure -a解决此问题”，然而按照提示运行却并没能很好的解决问题。其实导致这个问题的主要原因是因为/var/lib/dpkg/updates文件下的文件有问题，可能是其他软件安装过程或是其他原因导致的，这里删除掉然后重建即可。<br><a id="more"></a></p><pre><code>sudo rm /var/lib/dpkg/updates/*sudo apt-get updatesudo apt-get upgrade</code></pre><p>解释：[<em>]sudo apt-get update指令会重新建立这些资料，所以不必担心删除后会出问题；<br>[</em>]sudo apt-get upgrade会更新你的电脑里面已安装的软件的明细，根据软件的明细更新软件到最新版。<br>PS：“dpkg ”是“Debian Packager ”的简写。为 “Debian” 专门开发的套件管理系统，方便软件的安装、更新及移除。所有源自“Debian”的“Linux ”发行版都使用 “dpkg”</p><p>参考<a href="https://blog.csdn.net/coolcooljob/article/details/79964812">博客</a></p><hr>]]></content>
    
    
    <summary type="html">&lt;p&gt;linux系统安装软件是有时会碰到“dpkg 被中断,您必须手工运行 sudo dpkg –configure -a解决此问题”，然而按照提示运行却并没能很好的解决问题。其实导致这个问题的主要原因是因为/var/lib/dpkg/updates文件下的文件有问题，可能是其他软件安装过程或是其他原因导致的，这里删除掉然后重建即可。&lt;br&gt;</summary>
    
    
    
    <category term="Ubuntu" scheme="https://zzygeo.cn/categories/Ubuntu/"/>
    
    
  </entry>
  
  <entry>
    <title>安装snap以及常用命令</title>
    <link href="https://zzygeo.cn/2021/03/14/Ubuntu/%E5%AE%89%E8%A3%85snap/"/>
    <id>https://zzygeo.cn/2021/03/14/Ubuntu/%E5%AE%89%E8%A3%85snap/</id>
    <published>2021-03-13T17:35:25.000Z</published>
    <updated>2021-05-24T00:58:39.914Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-安装snap"><a href="#1-安装snap" class="headerlink" title="1.安装snap"></a>1.安装snap</h1><a id="more"></a><pre><code>sudo apt-get install snapdsudo apt-get install snapcraft</code></pre><h1 id="2-常用命令"><a href="#2-常用命令" class="headerlink" title="2.常用命令"></a>2.常用命令</h1><pre><code>//列出已经安装的snap包sudo snap list//搜索要安装的snap包sudo snap find &lt;text to search&gt;//安装一个snap包sudo snap install &lt;snap name&gt;//更新一个snap包，如果你后面不加包的名字的话那就是更新所有的snap包sudo snap refresh &lt;snap name&gt;//把一个包还原到以前安装的版本sudo snap revert &lt;snap name&gt;//删除一个snap包sudo snap remove &lt;snap name&gt;</code></pre><hr>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;1-安装snap&quot;&gt;&lt;a href=&quot;#1-安装snap&quot; class=&quot;headerlink&quot; title=&quot;1.安装snap&quot;&gt;&lt;/a&gt;1.安装snap&lt;/h1&gt;</summary>
    
    
    
    <category term="Ubuntu" scheme="https://zzygeo.cn/categories/Ubuntu/"/>
    
    
  </entry>
  
  <entry>
    <title>ubuntu配置C/C++开发环境</title>
    <link href="https://zzygeo.cn/2021/03/14/Ubuntu/ubuntu%E9%85%8D%E7%BD%AEC-C-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
    <id>https://zzygeo.cn/2021/03/14/Ubuntu/ubuntu%E9%85%8D%E7%BD%AEC-C-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</id>
    <published>2021-03-13T17:31:07.000Z</published>
    <updated>2021-05-24T00:58:14.532Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-在代码文件夹下建立两个文件"><a href="#1-在代码文件夹下建立两个文件" class="headerlink" title="1.在代码文件夹下建立两个文件"></a>1.在代码文件夹下建立两个文件</h1><p>launch.json 以及 tasks.json<br><a id="more"></a></p><h1 id="2-给这个两个文件配置文件"><a href="#2-给这个两个文件配置文件" class="headerlink" title="2.给这个两个文件配置文件"></a>2.给这个两个文件配置文件</h1><p>launch.json:</p><pre><code>&#123;    // Use IntelliSense to learn about possible attributes.    // Hover to view descriptions of existing attributes.    // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387    &quot;version&quot;: &quot;0.2.0&quot;,    &quot;configurations&quot;: [        &#123;            &quot;name&quot;: &quot;(gdb) Launch&quot;,            &quot;type&quot;: &quot;cppdbg&quot;,            &quot;request&quot;: &quot;launch&quot;,            &quot;program&quot;: &quot;$&#123;workspaceFolder&#125;/$&#123;fileBasenameNoExtension&#125;.out&quot;,            &quot;args&quot;: [],            &quot;stopAtEntry&quot;: false,            &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;&quot;,            &quot;environment&quot;: [],            &quot;externalConsole&quot;: true,    //如果不要窗口弹出，在ide中显示，就设置成 false            &quot;MIMode&quot;: &quot;gdb&quot;,            &quot;preLaunchTask&quot;: &quot;build&quot;,   //表示预先生成一个中间文件，用于g++运行            &quot;setupCommands&quot;: [                &#123;                    &quot;description&quot;: &quot;Enable pretty-printing for gdb&quot;,                    &quot;text&quot;: &quot;-enable-pretty-printing&quot;,                    &quot;ignoreFailures&quot;: true                &#125;            ]        &#125;    ]&#125;</code></pre><p>tasks.json:</p><pre><code>&#123;    // See https://go.microsoft.com/fwlink/?LinkId=733558    // for the documentation about the tasks.json format    &quot;version&quot;: &quot;2.0.0&quot;,    &quot;tasks&quot;: [        &#123;            &quot;label&quot;: &quot;build&quot;,            &quot;type&quot;: &quot;shell&quot;,            &quot;command&quot;: &quot;g++&quot;,            &quot;args&quot;: [&quot;-g&quot;, &quot;$&#123;file&#125;&quot;, &quot;-std=c++11&quot;, &quot;-o&quot;, &quot;$&#123;fileBasenameNoExtension&#125;.out&quot;]    //相当于 g++ -g main.cpp -std=c++11 -o main.out        &#125;    ]&#125;</code></pre><p>参考<a href="https://blog.csdn.net/suiyueruge1314/article/details/106125949">博客</a></p><hr>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;1-在代码文件夹下建立两个文件&quot;&gt;&lt;a href=&quot;#1-在代码文件夹下建立两个文件&quot; class=&quot;headerlink&quot; title=&quot;1.在代码文件夹下建立两个文件&quot;&gt;&lt;/a&gt;1.在代码文件夹下建立两个文件&lt;/h1&gt;&lt;p&gt;launch.json 以及 tasks.json&lt;br&gt;</summary>
    
    
    
    <category term="Ubuntu" scheme="https://zzygeo.cn/categories/Ubuntu/"/>
    
    
  </entry>
  
  <entry>
    <title>ubuntu安装gcc依赖关系报错</title>
    <link href="https://zzygeo.cn/2021/03/14/Ubuntu/ubuntu%E5%AE%89%E8%A3%85gcc%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB%E6%8A%A5%E9%94%99/"/>
    <id>https://zzygeo.cn/2021/03/14/Ubuntu/ubuntu%E5%AE%89%E8%A3%85gcc%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB%E6%8A%A5%E9%94%99/</id>
    <published>2021-03-13T17:26:01.000Z</published>
    <updated>2021-05-24T00:57:56.428Z</updated>
    
    <content type="html"><![CDATA[<p>使用aptitude包依赖管理工具替代apt处理，看其他的博客说这个得慎用，不过用来安装gcc倒是没啥问题。<br><a id="more"></a></p><pre><code>sudo apt-get install aptitudesudo aptitude install gcc g++</code></pre><p>解决方案里选择no,yes,yes.<br>参考<a href="https://blog.csdn.net/CLZHIT/article/details/104508894">博客</a></p><hr>]]></content>
    
    
    <summary type="html">&lt;p&gt;使用aptitude包依赖管理工具替代apt处理，看其他的博客说这个得慎用，不过用来安装gcc倒是没啥问题。&lt;br&gt;</summary>
    
    
    
    <category term="Ubuntu" scheme="https://zzygeo.cn/categories/Ubuntu/"/>
    
    
  </entry>
  
  <entry>
    <title>ubuntu安装vim依赖关系报错</title>
    <link href="https://zzygeo.cn/2021/03/14/Ubuntu/ubuntu%E5%AE%89%E8%A3%85vim%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB%E6%8A%A5%E9%94%99/"/>
    <id>https://zzygeo.cn/2021/03/14/Ubuntu/ubuntu%E5%AE%89%E8%A3%85vim%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB%E6%8A%A5%E9%94%99/</id>
    <published>2021-03-13T17:22:16.000Z</published>
    <updated>2021-05-24T00:58:01.518Z</updated>
    
    <content type="html"><![CDATA[<p>按如下步骤进行就可：<br><a id="more"></a></p><pre><code>sudo apt-get purge vim-commonsudo apt-get updatesudo apt-get upgradesudo apt-get install vim</code></pre><hr>]]></content>
    
    
    <summary type="html">&lt;p&gt;按如下步骤进行就可：&lt;br&gt;</summary>
    
    
    
    <category term="Ubuntu" scheme="https://zzygeo.cn/categories/Ubuntu/"/>
    
    
  </entry>
  
  <entry>
    <title>ubuntu下的firefox无法播放视频解决方案</title>
    <link href="https://zzygeo.cn/2021/03/14/Ubuntu/ubuntu%E4%B8%8B%E7%9A%84firefox%E6%97%A0%E6%B3%95%E6%92%AD%E6%94%BE%E8%A7%86%E9%A2%91%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>https://zzygeo.cn/2021/03/14/Ubuntu/ubuntu%E4%B8%8B%E7%9A%84firefox%E6%97%A0%E6%B3%95%E6%92%AD%E6%94%BE%E8%A7%86%E9%A2%91%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</id>
    <published>2021-03-13T17:09:31.000Z</published>
    <updated>2021-05-24T00:58:20.789Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-下载flash的tar-gz文件"><a href="#1-下载flash的tar-gz文件" class="headerlink" title="1.下载flash的tar.gz文件"></a>1.下载flash的tar.gz文件</h1><p>直接去<a href="https://www.flash.cn/">官网链接</a>下载<br><a id="more"></a></p><h1 id="2-解压tar-gz文件"><a href="#2-解压tar-gz文件" class="headerlink" title="2.解压tar.gz文件"></a>2.解压tar.gz文件</h1><pre><code>tar -zxvf filename.tar.gz</code></pre><p>注意filename.tar.gz就是你下载的文件的名字，可以直接复制下载包名字。</p><h1 id="3-移动解压文件夹"><a href="#3-移动解压文件夹" class="headerlink" title="3.移动解压文件夹"></a>3.移动解压文件夹</h1><p>先进入安装包目录下,然后</p><pre><code>sudo cp libflashplayer.so /usr/lib/firefox/browser/pluginssudo cp -r usr/* /usr</code></pre><h1 id="4-缺少依赖报错解决"><a href="#4-缺少依赖报错解决" class="headerlink" title="4.缺少依赖报错解决"></a>4.缺少依赖报错解决</h1><pre><code>sudo apt-get install ffmpeg  //ffmpeg支持H.264解码</code></pre><hr>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;1-下载flash的tar-gz文件&quot;&gt;&lt;a href=&quot;#1-下载flash的tar-gz文件&quot; class=&quot;headerlink&quot; title=&quot;1.下载flash的tar.gz文件&quot;&gt;&lt;/a&gt;1.下载flash的tar.gz文件&lt;/h1&gt;&lt;p&gt;直接去&lt;a href=&quot;https://www.flash.cn/&quot;&gt;官网链接&lt;/a&gt;下载&lt;br&gt;</summary>
    
    
    
    <category term="Ubuntu" scheme="https://zzygeo.cn/categories/Ubuntu/"/>
    
    
  </entry>
  
  <entry>
    <title>ubuntu下解决wps2019缺少字体问题</title>
    <link href="https://zzygeo.cn/2021/03/14/Ubuntu/ubuntu%E4%B8%8B%E8%A7%A3%E5%86%B3wps2019%E7%BC%BA%E5%B0%91%E5%AD%97%E4%BD%93%E9%97%AE%E9%A2%98/"/>
    <id>https://zzygeo.cn/2021/03/14/Ubuntu/ubuntu%E4%B8%8B%E8%A7%A3%E5%86%B3wps2019%E7%BC%BA%E5%B0%91%E5%AD%97%E4%BD%93%E9%97%AE%E9%A2%98/</id>
    <published>2021-03-13T16:56:33.000Z</published>
    <updated>2021-05-24T00:58:26.096Z</updated>
    
    <content type="html"><![CDATA[<p>主要参考<a href="https://blog.csdn.net/sunmengke1101/article/details/103436997">博客</a><br><a id="more"></a></p><h1 id="1-准备字体包"><a href="#1-准备字体包" class="headerlink" title="1.准备字体包"></a>1.准备字体包</h1><p><a href="https://wws.lanzous.com/iBIiqmwnvve">下载链接</a></p><h1 id="2-解压到指定目录下"><a href="#2-解压到指定目录下" class="headerlink" title="2.解压到指定目录下"></a>2.解压到指定目录下</h1><pre><code>sudo unzip wps_symbol_fonts.zip -d /home/&lt;user&gt;/usr/share/fonts</code></pre><h1 id="3-到解压的根目录下安装"><a href="#3-到解压的根目录下安装" class="headerlink" title="3.到解压的根目录下安装"></a>3.到解压的根目录下安装</h1><p>依次打开每个文件并点击安装即可</p><hr>]]></content>
    
    
    <summary type="html">&lt;p&gt;主要参考&lt;a href=&quot;https://blog.csdn.net/sunmengke1101/article/details/103436997&quot;&gt;博客&lt;/a&gt;&lt;br&gt;</summary>
    
    
    
    <category term="Ubuntu" scheme="https://zzygeo.cn/categories/Ubuntu/"/>
    
    
  </entry>
  
  <entry>
    <title>Ubuntu更换源教程</title>
    <link href="https://zzygeo.cn/2021/03/14/Ubuntu/Ubuntu%E6%9B%B4%E6%8D%A2%E6%BA%90%E6%95%99%E7%A8%8B/"/>
    <id>https://zzygeo.cn/2021/03/14/Ubuntu/Ubuntu%E6%9B%B4%E6%8D%A2%E6%BA%90%E6%95%99%E7%A8%8B/</id>
    <published>2021-03-13T16:34:31.000Z</published>
    <updated>2021-05-24T00:58:08.039Z</updated>
    
    <content type="html"><![CDATA[<p>参考<a href="https://blog.csdn.net/weixin_43876206/article/details/100924378">博客</a><br><a id="more"></a></p><h1 id="1-备份源列表"><a href="#1-备份源列表" class="headerlink" title="1.备份源列表"></a>1.备份源列表</h1><pre><code>sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak</code></pre><h1 id="2-打开sources-list文件"><a href="#2-打开sources-list文件" class="headerlink" title="2.打开sources.list文件"></a>2.打开sources.list文件</h1><pre><code>sudo gedit /etc/apt/sources.list</code></pre><h1 id="3-修改sources-list文件"><a href="#3-修改sources-list文件" class="headerlink" title="3.修改sources.list文件"></a>3.修改sources.list文件</h1><pre><code>#  阿里镜像源deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</code></pre><h1 id="4-更新并升级"><a href="#4-更新并升级" class="headerlink" title="4.更新并升级"></a>4.更新并升级</h1><pre><code>sudo apt-get update &amp;&amp; sudo apt-get upgrade</code></pre><h1 id="5-恢复源列表"><a href="#5-恢复源列表" class="headerlink" title="5.恢复源列表"></a>5.恢复源列表</h1><pre><code>sudo cp /etc/apt/sources.list.bak /etc/apt/sources.list</code></pre><hr><p>其他的源请自己搜索，这里只放了阿里云的。</p><hr>]]></content>
    
    
    <summary type="html">&lt;p&gt;参考&lt;a href=&quot;https://blog.csdn.net/weixin_43876206/article/details/100924378&quot;&gt;博客&lt;/a&gt;&lt;br&gt;</summary>
    
    
    
    <category term="Ubuntu" scheme="https://zzygeo.cn/categories/Ubuntu/"/>
    
    
  </entry>
  
  <entry>
    <title>github设置自己的域名</title>
    <link href="https://zzygeo.cn/2021/01/20/Hexo/github%E8%AE%BE%E7%BD%AE%E8%87%AA%E5%B7%B1%E7%9A%84%E5%9F%9F%E5%90%8D/"/>
    <id>https://zzygeo.cn/2021/01/20/Hexo/github%E8%AE%BE%E7%BD%AE%E8%87%AA%E5%B7%B1%E7%9A%84%E5%9F%9F%E5%90%8D/</id>
    <published>2021-01-20T08:30:55.000Z</published>
    <updated>2021-05-24T00:59:47.893Z</updated>
    
    <content type="html"><![CDATA[<p>哈哈，上次整了一晚上的没整明白，今天两下就整好了，看来真的进步不错哈哈，至少看东西，解决问题更有耐心也更能看懂了。<br><a id="more"></a></p><h1 id="1-购买域名"><a href="#1-购买域名" class="headerlink" title="1.购买域名"></a>1.购买域名</h1><p>我是买的阿里云的域名，如下图：<br><img src="/blog_img/github设置自己的域名/1.jpg" alt="域名"><br>域名解析如下：<br><img src="/blog_img/github设置自己的域名/2.jpg" alt="域名解析"></p><h1 id="2-github仓库设置域名地址"><a href="#2-github仓库设置域名地址" class="headerlink" title="2.github仓库设置域名地址"></a>2.github仓库设置域名地址</h1><p>在blog目录下的source文件下，创一个叫CNAME的无后缀文件，里面填入你的域名，比如我的   zzygeo.cn    如下图：<br><img src="/blog_img/github设置自己的域名/4.jpg" alt=""><br>如下图，主要是要设置博客上传分支的目录，以及更改你自己的域名（创建CNAME后自动生成），采用https加密。<br><img src="/blog_img/github设置自己的域名/3.jpg" alt=""></p><p>到此就设置完成了！</p><hr>]]></content>
    
    
    <summary type="html">&lt;p&gt;哈哈，上次整了一晚上的没整明白，今天两下就整好了，看来真的进步不错哈哈，至少看东西，解决问题更有耐心也更能看懂了。&lt;br&gt;</summary>
    
    
    
    <category term="Hexo" scheme="https://zzygeo.cn/categories/Hexo/"/>
    
    
  </entry>
  
  <entry>
    <title>pcl+vs+cmake编译</title>
    <link href="https://zzygeo.cn/2020/12/27/PCL/pcl-vs-cmake%E7%BC%96%E8%AF%91/"/>
    <id>https://zzygeo.cn/2020/12/27/PCL/pcl-vs-cmake%E7%BC%96%E8%AF%91/</id>
    <published>2020-12-27T14:50:27.000Z</published>
    <updated>2021-05-24T00:59:31.373Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇写的配置可能是最基础的，也是很麻烦，其实可以用cmake来偷个懒，这样就不用附加依赖性已经加入库目录和包含目录了。<br><a id="more"></a></p><h1 id="1-软件准备"><a href="#1-软件准备" class="headerlink" title="1.软件准备"></a>1.软件准备</h1><p>1.All in one 安装包。</p><p>2.获取All in one 包对应得PDB文件包，用于后期单步调试。</p><p>3.安装Visual studio 2019编译器</p><p>4.cmake<br><img src="/blog_img/PCL配置/17.png" alt="示意图"><br><img src="/blog_img/PCL配置/1.jpg" alt="示意图"></p><p>其实源码包用不上，懒得改了，最复杂的方式就是源代码加第三方库进行配置，等我配置好了也会再一篇关于源码方式的配置。</p><hr><h1 id="2-链接"><a href="#2-链接" class="headerlink" title="2.链接"></a>2.链接</h1><p><a href="https://github.com/PointCloudLibrary/pcl/releases">pcl下载地址</a><br><a href="https://visualstudio.microsoft.com/zh-hans/downloads/">visual studio下载地址</a><br><a href="https://cmake.org/download/">cmake下载地址</a></p><hr><h1 id="3-安装事项"><a href="#3-安装事项" class="headerlink" title="3.安装事项"></a>3.安装事项</h1><p>为了方便配置，pcl安装目录尽量默认，不默认后续添加目录需要选择对应的位置。</p><p>pcl安装请一定选择创建系统路径，visual studio和cmake安装位置随意，其他选项默认即可。</p><p>pcl安装完成后，请把下载的pcd文件解压，如下图：<br><img src="/blog_img/PCL配置/2.jpg" alt=""></p><p>将所有文件复制，安装到pcl下的BIN文件下<br><img src="/blog_img/PCL配置/3.jpg" alt=""></p><p>检查pcl安装目录下的 3rdParty-OpenNI2是否只有一个安装包（我的是这样），这可能是事先安装过SDK的原因，请卸载了重新安装在OpenNI2下，安装完成如下图：<br><img src="/blog_img/PCL配置/4.jpg" alt=""></p><p>cmake 安装请选择添加到系统路径，没选的话也可以自己手动添加，添加的方式为cmake目录下bin文件  比如C:\APP\Cmake\bin这样的形式。</p><hr><h1 id="4-关于Visual-studio安装项目"><a href="#4-关于Visual-studio安装项目" class="headerlink" title="4.关于Visual studio安装项目"></a>4.关于Visual studio安装项目</h1><p>我安装了这些负载</p><p><img src="/blog_img/PCL配置/5.png" alt=""></p><hr><h1 id="5-环境配置"><a href="#5-环境配置" class="headerlink" title="5.环境配置"></a>5.环境配置</h1><p>右键我的电脑——高级系统设置-环境变量，在path选项下新建如下几项，根据你pcl安装的位置来：<br><img src="/blog_img/PCL配置/6.jpg" alt=""></p><p>比如我的：<br>C:\Program Files\PCL 1.11.0\bin<br>C:\Program Files\PCL 1.11.0\3rdParty\FLANN\bin<br>C:\Program Files\PCL 1.11.0\3rdParty\Qhull\bin<br>C:\Program Files\PCL 1.11.0\3rdParty\VTK\bin<br>C:\Program Files\PCL 1.11.0\3rdParty\OpenNI2\Tools<br>C:\Program Files\PCL 1.11.0\3rdParty\OpenNI2\Redist</p><p>在系统变量下，配置如下图：<br><img src="/blog_img/PCL配置/6.png" alt=""><br>比如我的：<br>C:\Program Files\PCL 1.11.0\3rdParty\FLANN\bin<br>C:\Program Files\PCL 1.11.0\3rdParty\OpenNI2\Tools<br>C:\Program Files\PCL 1.11.0\3rdParty\Qhull\bin<br>C:\Program Files\PCL 1.11.0\3rdParty\VTK\bin<br>C:\Program Files\PCL 1.11.0\bin</p><hr><h1 id="6-cmake编译"><a href="#6-cmake编译" class="headerlink" title="6.cmake编译"></a>6.cmake编译</h1><p>以管理员身份运行cmake-gui<br>在你想要的文件下创建一个名为example的文件夹，然后在此目录下创建一个source和cmake_bin文件，比如我的：</p><p><img src="/blog_img/PCL配置/18.png" alt=""></p><p>在source里面创建一个cpp文件和CMakeLists.txt文件。<br>CmakeLists.txt里写入以下内容：</p><pre><code>cmake_minimum_required(VERSION 2.6 FATAL_ERROR)project(test)find_package(PCL 1.4 REQUIRED)include_directories($&#123;PCL_INCLUDE_DIRS&#125;)link_directories($&#123;PCL_LIBRARY_DIRS&#125;)  add_definitions($&#123;PCL_DEFINITIONS&#125;)add_executable (test test.cpp)target_link_libraries (test $&#123;PCL_LIBRARIES&#125;)</code></pre><p>其中这个test就是你创建的测试代码的名字，请保持一致，如果你换别的名字，请把txt文件的名字也一起改了。我的如下：<br><img src="/blog_img/PCL配置/19.png" alt=""></p><p>测试代码请网上去找，我用的是上一篇文件里的（里面有个D盘文件的读取可能会报错，但只要能出彩色的那个图就算配置成功了）。</p><p>跟着步骤添加<br><img src="/blog_img/PCL配置/20.png" alt=""></p><p>点击Configure，选x64<br><img src="/blog_img/PCL配置/21.jpg" alt=""></p><p>再点击一次configure<br><img src="/blog_img/PCL配置/22.jpg" alt=""></p><p>点击Generate,出现Generating done.<br><img src="/blog_img/PCL配置/23.png" alt=""></p><p>找到cmake_bin底下的test_sln 打开。<br><img src="/blog_img/PCL配置/24.jpg" alt=""></p><p>将test设置为启动项，并调试。<br><img src="/blog_img/PCL配置/25.png" alt=""></p><p><img src="/blog_img/PCL配置/26.jpg" alt=""></p><hr>]]></content>
    
    
    <summary type="html">&lt;p&gt;上一篇写的配置可能是最基础的，也是很麻烦，其实可以用cmake来偷个懒，这样就不用附加依赖性已经加入库目录和包含目录了。&lt;br&gt;</summary>
    
    
    
    <category term="Ubuntu" scheme="https://zzygeo.cn/categories/Ubuntu/"/>
    
    
  </entry>
  
  <entry>
    <title>Unable to access &#39;https://gitee.com/自己的项目/&#39;: Could not resolve host: gitee.com问题的解决</title>
    <link href="https://zzygeo.cn/2020/10/23/Ubuntu/Unable-to-access-https-gitee-com-%E8%87%AA%E5%B7%B1%E7%9A%84%E9%A1%B9%E7%9B%AE-Could-not-resolve-host-gitee-com%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3/"/>
    <id>https://zzygeo.cn/2020/10/23/Ubuntu/Unable-to-access-https-gitee-com-%E8%87%AA%E5%B7%B1%E7%9A%84%E9%A1%B9%E7%9B%AE-Could-not-resolve-host-gitee-com%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3/</id>
    <published>2020-10-22T17:28:36.000Z</published>
    <updated>2021-05-24T00:58:33.166Z</updated>
    
    <content type="html"><![CDATA[<p>果然玩hexo报错是在所难免，就好像我已经长大，读研以后乃至以后得日子，可能总是繁琐常伴。今天在hexo d推到GITEE上时，报了错。<br><a id="more"></a><br>原因是由于爬梯子代理网络的问题，其实折腾了下。具体哪个步骤解决了这个问题，我也不是很清楚，这次做好记录方便以后继续更新把。</p><p>首先我是从这篇<a href="https://blog.csdn.net/weixin_37166398/article/details/101422239?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param">博客</a>里查到了我的ip，然后ping了查到的ip，然后在system32\drives\etc\hosts里添加了   </p><pre><code>IP gitee.com</code></pre><p>然而这并没有继续运行成功。<br>然后我有尝试<br>1.管理员身份运行cmd<br>2.输入 </p><pre><code>netsh winsock reset</code></pre><p>3.重启</p><p>还有尝试命令行输入  </p><pre><code>git config --global --unset http.proxy git config --global --unset https.proxy</code></pre><p>最后发现还是不行，结果我把第一步添加的IP gitee.com删了居然好了。</p><p>所以我觉得问题在以下原因，第一个是我没有在打开代理下hexo d,平时确实是没有注意这个问题，但关闭代理下好像有时候也成功过，但这个问题确实出在了代理的问题上。<br>另外就是我的代理导致了无法上传上去，上述的两个操作我也不知道哪个解决了这个问题，毕竟我先添加了IP，然后再试了这两种清楚的。如果下次再出现这个问题，有了结果再继续补充。</p><p>2020/11/17<br>他妈个头的，翻墙今天又部署不上去了，前面的用了也不好使，又试了一下这个更改DNS的方法成功了，<a href="https://blog.csdn.net/weixin_42476786/article/details/82691934?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.add_param_isCf&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.add_param_isCf">链接</a>在这</p><hr>]]></content>
    
    
    <summary type="html">&lt;p&gt;果然玩hexo报错是在所难免，就好像我已经长大，读研以后乃至以后得日子，可能总是繁琐常伴。今天在hexo d推到GITEE上时，报了错。&lt;br&gt;</summary>
    
    
    
    <category term="Ubuntu" scheme="https://zzygeo.cn/categories/Ubuntu/"/>
    
    
  </entry>
  
  <entry>
    <title>资源</title>
    <link href="https://zzygeo.cn/2020/10/04/%E5%85%B6%E4%BB%96/%E8%B5%84%E6%BA%90/"/>
    <id>https://zzygeo.cn/2020/10/04/%E5%85%B6%E4%BB%96/%E8%B5%84%E6%BA%90/</id>
    <published>2020-10-04T06:53:31.000Z</published>
    <updated>2021-05-24T01:35:25.910Z</updated>
    
    <content type="html"><![CDATA[<p>准备把一些资源都放在这个博客下，持续更新，有需要得自取。</p><h1 id="1-Linux学习笔记"><a href="#1-Linux学习笔记" class="headerlink" title="1.Linux学习笔记"></a>1.Linux学习笔记</h1><p><a href="https://wws.lanzous.com/iKIZfh7eeuh">链接</a></p><a id="more"></a><h1 id="2-cloud-compare中文版使用手册"><a href="#2-cloud-compare中文版使用手册" class="headerlink" title="2.cloud compare中文版使用手册"></a>2.cloud compare中文版使用手册</h1><p><a href="https://wws.lanzous.com/imyXlh3nide">链接</a></p><hr><h1 id="3-深度学习"><a href="#3-深度学习" class="headerlink" title="3.深度学习"></a>3.深度学习</h1><p><a href="https://www.bilibili.com/video/BV164411m79z?from=search&amp;seid=8194466955642792600">吴恩达深度学习课程</a></p><p><a href="https://www.kesci.com/home/project/5e20243e2823a10036b542da">吴恩达课程配套科目</a></p><p><a href="http://www.ai-start.com/dl2017/">吴恩达深度学习笔记</a></p><hr><h1 id="4-壁纸"><a href="#4-壁纸" class="headerlink" title="4.壁纸"></a>4.壁纸</h1><p><a href="https://wallhaven.cc/">地址</a></p><h1 id="5-1080p下载"><a href="#5-1080p下载" class="headerlink" title="5.1080p下载"></a>5.1080p下载</h1><p><a href="https://www.y2mate.com/en60/">下载地址</a></p><hr><h1 id="6-视频字幕下载"><a href="#6-视频字幕下载" class="headerlink" title="6.视频字幕下载"></a>6.视频字幕下载</h1><p><a href="https://www.findyoutube.net/">下载地址</a><br>版权限制，目前下载为VTT格式，需要在Subtitle Edit里将VTT转为SRT格式。</p><hr><h1 id="7-Subtitle-Edit-vvt-srt"><a href="#7-Subtitle-Edit-vvt-srt" class="headerlink" title="7.Subtitle Edit(vvt-srt)"></a>7.Subtitle Edit(vvt-srt)</h1><p><a href="https://www.nikse.dk/subtitleedit/">下载地址</a><br>可以VTT2SRT SRT2VTT,有强大的字幕编辑功能。</p><hr><h1 id="8-Arctime-制作内嵌字幕视频"><a href="#8-Arctime-制作内嵌字幕视频" class="headerlink" title="8.Arctime(制作内嵌字幕视频)"></a>8.Arctime(制作内嵌字幕视频)</h1><p><a href="https://arctime.org/">下载地址</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;准备把一些资源都放在这个博客下，持续更新，有需要得自取。&lt;/p&gt;
&lt;h1 id=&quot;1-Linux学习笔记&quot;&gt;&lt;a href=&quot;#1-Linux学习笔记&quot; class=&quot;headerlink&quot; title=&quot;1.Linux学习笔记&quot;&gt;&lt;/a&gt;1.Linux学习笔记&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://wws.lanzous.com/iKIZfh7eeuh&quot;&gt;链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="资源" scheme="https://zzygeo.cn/categories/%E8%B5%84%E6%BA%90/"/>
    
    
  </entry>
  
  <entry>
    <title>PCL-1-11-Visual-Studio-2019-配置</title>
    <link href="https://zzygeo.cn/2020/10/04/PCL/PCL-1-11-Visual-Studio-2019-%E9%85%8D%E7%BD%AE/"/>
    <id>https://zzygeo.cn/2020/10/04/PCL/PCL-1-11-Visual-Studio-2019-%E9%85%8D%E7%BD%AE/</id>
    <published>2020-10-04T04:22:26.000Z</published>
    <updated>2021-05-24T00:59:10.142Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-软件准备"><a href="#1-软件准备" class="headerlink" title="1.软件准备"></a>1.软件准备</h1><p>1.All in one 安装包。</p><p>2.获取All in one 包对应得PDB文件包，用于后期单步调试。<br><a id="more"></a><br>3.获取PCL源码包</p><p>4.安装Visual studio 2019编译器</p><p><img src="/blog_img/PCL配置/1.jpg" alt="示意图"></p><hr><h1 id="2-链接"><a href="#2-链接" class="headerlink" title="2.链接"></a>2.链接</h1><p><a href="https://github.com/PointCloudLibrary/pcl/releases">pcl下载地址</a><br><a href="https://visualstudio.microsoft.com/zh-hans/downloads/">visual studio下载地址</a></p><hr><h1 id="3-安装事项"><a href="#3-安装事项" class="headerlink" title="3.安装事项"></a>3.安装事项</h1><p>为了方便配置，pcl安装目录尽量默认，不默认后续添加目录需要选择对应的位置。</p><p>pcl安装请一定选择创建系统路径，visual studio和cmake安装位置随意，其他选项默认即可。</p><p>pcl安装完成后，请把下载的pcd文件解压，如下图：<br><img src="/blog_img/PCL配置/2.jpg" alt=""></p><p>将所有文件复制，安装到pcl下的BIN文件下<br><img src="/blog_img/PCL配置/3.jpg" alt=""></p><p>检查pcl安装目录下的 3rdParty-OpenNI2是否只有一个安装包（我的是这样），这可能是事先安装过SDK的原因，请卸载了重新安装在OpenNI2下，安装完成如下图：<br><img src="/blog_img/PCL配置/4.jpg" alt=""></p><hr><h1 id="4-关于Visual-studio安装项目"><a href="#4-关于Visual-studio安装项目" class="headerlink" title="4.关于Visual studio安装项目"></a>4.关于Visual studio安装项目</h1><p>我安装了这些负载</p><p><img src="/blog_img/PCL配置/5.png" alt=""></p><hr><h1 id="5-环境配置"><a href="#5-环境配置" class="headerlink" title="5.环境配置"></a>5.环境配置</h1><p>右键我的电脑——高级系统设置-环境变量，在path选项下新建如下几项，根据你pcl安装的位置来：<br><img src="/blog_img/PCL配置/6.jpg" alt=""></p><p>比如我的：<br>C:\Program Files\PCL 1.11.0\bin<br>C:\Program Files\PCL 1.11.0\3rdParty\FLANN\bin<br>C:\Program Files\PCL 1.11.0\3rdParty\Qhull\bin<br>C:\Program Files\PCL 1.11.0\3rdParty\VTK\bin<br>C:\Program Files\PCL 1.11.0\3rdParty\OpenNI2\Tools<br>C:\Program Files\PCL 1.11.0\3rdParty\OpenNI2\Redist</p><p>在系统变量下，配置如下图：<br><img src="/blog_img/PCL配置/6.png" alt=""><br>比如我的：<br>C:\Program Files\PCL 1.11.0\3rdParty\FLANN\bin<br>C:\Program Files\PCL 1.11.0\3rdParty\OpenNI2\Tools<br>C:\Program Files\PCL 1.11.0\3rdParty\Qhull\bin<br>C:\Program Files\PCL 1.11.0\3rdParty\VTK\bin<br>C:\Program Files\PCL 1.11.0\bin</p><hr><h1 id="6-配置"><a href="#6-配置" class="headerlink" title="6.配置"></a>6.配置</h1><p>打开visual studio，新建一个空项目如图：<br><img src="/blog_img/PCL配置/7.jpg" alt=""></p><p>在release下创建属性表（如果是DEBUG版本请在DEBUG下创建）<br><img src="/blog_img/PCL配置/8.png" alt=""></p><p>切换到解决方案资源管理器，右键-添加-新建项<br><img src="/blog_img/PCL配置/9.png" alt=""></p><p>添加C++文件<br><img src="/blog_img/PCL配置/10.png" alt=""></p><p>接下来配置：<br><img src="/blog_img/PCL配置/11.png" alt=""></p><p>包含目录下添加，建议手点：<br>C:\Program Files\PCL 1.11.0\include\pcl-1.11<br>C:\Program Files\PCL 1.11.0\3rdParty\Boost\include\boost-1_73<br>C:\Program Files\PCL 1.11.0\3rdParty\Eigen\eigen3<br>C:\Program Files\PCL 1.11.0\3rdParty\FLANN\include<br>C:\Program Files\PCL 1.11.0\3rdParty\Qhull\include<br>C:\Program Files\PCL 1.11.0\3rdParty\VTK\include\vtk-8.2<br>C:\Program Files\PCL 1.11.0\3rdParty\OpenNI2\Include</p><p>库目录添加：<br>C:\Program Files\PCL 1.11.0\lib<br>C:\Program Files\PCL 1.11.0\3rdParty\Boost\lib<br>C:\Program Files\PCL 1.11.0\3rdParty\FLANN\lib<br>C:\Program Files\PCL 1.11.0\3rdParty\Qhull\lib<br>C:\Program Files\PCL 1.11.0\3rdParty\VTK\lib<br>C:\Program Files\PCL 1.11.0\3rdParty\OpenNI2\Lib</p><p>接下来配置：<br><img src="/blog_img/PCL配置/12.jpg" alt=""></p><p>在预处理器定义处添加：<br>BOOST_USE_WINDOWS_H<br>NOMINMAX<br>_CRT_SECURE_NO_DEPRECATE</p><p>在项目属性表（Project_one）和release下创建得属性表（test_one）中把所有选项里得SDL检查全改成否，如下图：</p><p><img src="/blog_img/PCL配置/13.jpg" alt=""></p><p><img src="/blog_img/PCL配置/14.jpg" alt=""></p><hr><h1 id="7-附加依赖项"><a href="#7-附加依赖项" class="headerlink" title="7.附加依赖项"></a>7.附加依赖项</h1><p>将PCL 1.11.0\3rdParty\VTK\lib和PCL 1.11.0\lib这两个文件夹下的lib文件的release版本添加到附加依赖项中（DEBUG版本添加DEBUG类型文件）</p><p><img src="/blog_img/PCL配置/15.png" alt=""></p><p>文件名称我已经归类好了</p><p>release版本：</p><p>pcl_common.lib<br>pcl_features.lib<br>pcl_filters.lib<br>pcl_io.lib<br>pcl_io_ply.lib<br>pcl_kdtree.lib<br>pcl_keypoints.lib<br>pcl_ml.lib<br>pcl_octree.lib<br>pcl_outofcore.lib<br>pcl_people.lib<br>pcl_recognition.lib<br>pcl_registration.lib<br>pcl_sample_consensus.lib<br>pcl_search.lib<br>pcl_segmentation.lib<br>pcl_stereo.lib<br>pcl_surface.lib<br>pcl_tracking.lib<br>pcl_visualization.lib<br>vtkChartsCore-8.2.lib<br>vtkCommonColor-8.2.lib<br>vtkCommonComputationalGeometry-8.2.lib<br>vtkCommonCore-8.2.lib<br>vtkCommonDataModel-8.2.lib<br>vtkCommonExecutionModel-8.2.lib<br>vtkCommonMath-8.2.lib<br>vtkCommonMisc-8.2.lib<br>vtkCommonSystem-8.2.lib<br>vtkCommonTransforms-8.2.lib<br>vtkDICOMParser-8.2.lib<br>vtkDomainsChemistry-8.2.lib<br>vtkDomainsChemistryOpenGL2-8.2.lib<br>vtkdoubleconversion-8.2.lib<br>vtkexodusII-8.2.lib<br>vtkexpat-8.2.lib<br>vtkFiltersAMR-8.2.lib<br>vtkFiltersCore-8.2.lib<br>vtkFiltersExtraction-8.2.lib<br>vtkFiltersFlowPaths-8.2.lib<br>vtkFiltersGeneral-8.2.lib<br>vtkFiltersGeneric-8.2.lib<br>vtkFiltersGeometry-8.2.lib<br>vtkFiltersHybrid-8.2.lib<br>vtkFiltersHyperTree-8.2.lib<br>vtkFiltersImaging-8.2.lib<br>vtkFiltersModeling-8.2.lib<br>vtkFiltersParallel-8.2.lib<br>vtkFiltersParallelImaging-8.2.lib<br>vtkFiltersPoints-8.2.lib<br>vtkFiltersProgrammable-8.2.lib<br>vtkFiltersSelection-8.2.lib<br>vtkFiltersSMP-8.2.lib<br>vtkFiltersSources-8.2.lib<br>vtkFiltersStatistics-8.2.lib<br>vtkFiltersTexture-8.2.lib<br>vtkFiltersTopology-8.2.lib<br>vtkFiltersVerdict-8.2.lib<br>vtkfreetype-8.2.lib<br>vtkGeovisCore-8.2.lib<br>vtkgl2ps-8.2.lib<br>vtkglew-8.2.lib<br>vtkGUISupportMFC-8.2.lib<br>vtkhdf5_hl-8.2.lib<br>vtkhdf5-8.2.lib<br>vtkImagingColor-8.2.lib<br>vtkImagingCore-8.2.lib<br>vtkImagingFourier-8.2.lib<br>vtkImagingGeneral-8.2.lib<br>vtkImagingHybrid-8.2.lib<br>vtkImagingMath-8.2.lib<br>vtkImagingMorphological-8.2.lib<br>vtkImagingSources-8.2.lib<br>vtkImagingStatistics-8.2.lib<br>vtkImagingStencil-8.2.lib<br>vtkInfovisCore-8.2.lib<br>vtkInfovisLayout-8.2.lib<br>vtkInteractionImage-8.2.lib<br>vtkInteractionStyle-8.2.lib<br>vtkInteractionWidgets-8.2.lib<br>vtkIOAMR-8.2.lib<br>vtkIOAsynchronous-8.2.lib<br>vtkIOCityGML-8.2.lib<br>vtkIOCore-8.2.lib<br>vtkIOEnSight-8.2.lib<br>vtkIOExodus-8.2.lib<br>vtkIOExport-8.2.lib<br>vtkIOExportOpenGL2-8.2.lib<br>vtkIOExportPDF-8.2.lib<br>vtkIOGeometry-8.2.lib<br>vtkIOImage-8.2.lib<br>vtkIOImport-8.2.lib<br>vtkIOInfovis-8.2.lib<br>vtkIOLegacy-8.2.lib<br>vtkIOLSDyna-8.2.lib<br>vtkIOMINC-8.2.lib<br>vtkIOMovie-8.2.lib<br>vtkIONetCDF-8.2.lib<br>vtkIOParallel-8.2.lib<br>vtkIOParallelXML-8.2.lib<br>vtkIOPLY-8.2.lib<br>vtkIOSegY-8.2.lib<br>vtkIOSQL-8.2.lib<br>vtkIOTecplotTable-8.2.lib<br>vtkIOVeraOut-8.2.lib<br>vtkIOVideo-8.2.lib<br>vtkIOXML-8.2.lib<br>vtkIOXMLParser-8.2.lib<br>vtkjpeg-8.2.lib<br>vtkjsoncpp-8.2.lib<br>vtklibharu-8.2.lib<br>vtklibxml2-8.2.lib<br>vtklz4-8.2.lib<br>vtklzma-8.2.lib<br>vtkmetaio-8.2.lib<br>vtkNetCDF-8.2.lib<br>vtkogg-8.2.lib<br>vtkParallelCore-8.2.lib<br>vtkpng-8.2.lib<br>vtkproj-8.2.lib<br>vtkpugixml-8.2.lib<br>vtkRenderingAnnotation-8.2.lib<br>vtkRenderingContext2D-8.2.lib<br>vtkRenderingContextOpenGL2-8.2.lib<br>vtkRenderingCore-8.2.lib<br>vtkRenderingExternal-8.2.lib<br>vtkRenderingFreeType-8.2.lib<br>vtkRenderingGL2PSOpenGL2-8.2.lib<br>vtkRenderingImage-8.2.lib<br>vtkRenderingLabel-8.2.lib<br>vtkRenderingLOD-8.2.lib<br>vtkRenderingOpenGL2-8.2.lib<br>vtkRenderingVolume-8.2.lib<br>vtkRenderingVolumeOpenGL2-8.2.lib<br>vtksqlite-8.2.lib<br>vtksys-8.2.lib<br>vtktheora-8.2.lib<br>vtktiff-8.2.lib<br>vtkverdict-8.2.lib<br>vtkViewsContext2D-8.2.lib<br>vtkViewsCore-8.2.lib<br>vtkViewsInfovis-8.2.lib<br>vtkzlib-8.2.lib</p><p>DEBUG版本：</p><p>pcl_commond.lib<br>pcl_featuresd.lib<br>pcl_filtersd.lib<br>pcl_io_plyd.lib<br>pcl_iod.lib<br>pcl_kdtreed.lib<br>pcl_keypointsd.lib<br>pcl_mld.lib<br>pcl_octreed.lib<br>pcl_outofcored.lib<br>pcl_peopled.lib<br>pcl_recognitiond.lib<br>pcl_registrationd.lib<br>pcl_sample_consensusd.lib<br>pcl_searchd.lib<br>pcl_segmentationd.lib<br>pcl_stereod.lib<br>pcl_surfaced.lib<br>pcl_trackingd.lib<br>pcl_visualizationd.lib<br>vtkChartsCore-8.2-gd.lib<br>vtkCommonColor-8.2-gd.lib<br>vtkCommonComputationalGeometry-8.2-gd.lib<br>vtkCommonCore-8.2-gd.lib<br>vtkCommonDataModel-8.2-gd.lib<br>vtkCommonExecutionModel-8.2-gd.lib<br>vtkCommonMath-8.2-gd.lib<br>vtkCommonMisc-8.2-gd.lib<br>vtkCommonSystem-8.2-gd.lib<br>vtkCommonTransforms-8.2-gd.lib<br>vtkDICOMParser-8.2-gd.lib<br>vtkDomainsChemistry-8.2-gd.lib<br>vtkDomainsChemistryOpenGL2-8.2-gd.lib<br>vtkdoubleconversion-8.2-gd.lib<br>vtkexodusII-8.2-gd.lib<br>vtkexpat-8.2-gd.lib<br>vtkFiltersAMR-8.2-gd.lib<br>vtkFiltersCore-8.2-gd.lib<br>vtkFiltersExtraction-8.2-gd.lib<br>vtkFiltersFlowPaths-8.2-gd.lib<br>vtkFiltersGeneral-8.2-gd.lib<br>vtkFiltersGeneric-8.2-gd.lib<br>vtkFiltersGeometry-8.2-gd.lib<br>vtkFiltersHybrid-8.2-gd.lib<br>vtkFiltersHyperTree-8.2-gd.lib<br>vtkFiltersImaging-8.2-gd.lib<br>vtkFiltersModeling-8.2-gd.lib<br>vtkFiltersParallel-8.2-gd.lib<br>vtkFiltersParallelImaging-8.2-gd.lib<br>vtkFiltersPoints-8.2-gd.lib<br>vtkFiltersProgrammable-8.2-gd.lib<br>vtkFiltersSelection-8.2-gd.lib<br>vtkFiltersSMP-8.2-gd.lib<br>vtkFiltersSources-8.2-gd.lib<br>vtkFiltersStatistics-8.2-gd.lib<br>vtkFiltersTexture-8.2-gd.lib<br>vtkFiltersTopology-8.2-gd.lib<br>vtkFiltersVerdict-8.2-gd.lib<br>vtkfreetype-8.2-gd.lib<br>vtkGeovisCore-8.2-gd.lib<br>vtkgl2ps-8.2-gd.lib<br>vtkglew-8.2-gd.lib<br>vtkGUISupportMFC-8.2-gd.lib<br>vtkhdf5_hl-8.2-gd.lib<br>vtkhdf5-8.2-gd.lib<br>vtkImagingColor-8.2-gd.lib<br>vtkImagingCore-8.2-gd.lib<br>vtkImagingFourier-8.2-gd.lib<br>vtkImagingGeneral-8.2-gd.lib<br>vtkImagingHybrid-8.2-gd.lib<br>vtkImagingMath-8.2-gd.lib<br>vtkImagingMorphological-8.2-gd.lib<br>vtkImagingSources-8.2-gd.lib<br>vtkImagingStatistics-8.2-gd.lib<br>vtkImagingStencil-8.2-gd.lib<br>vtkInfovisCore-8.2-gd.lib<br>vtkInfovisLayout-8.2-gd.lib<br>vtkInteractionImage-8.2-gd.lib<br>vtkInteractionStyle-8.2-gd.lib<br>vtkInteractionWidgets-8.2-gd.lib<br>vtkIOAMR-8.2-gd.lib<br>vtkIOAsynchronous-8.2-gd.lib<br>vtkIOCityGML-8.2-gd.lib<br>vtkIOCore-8.2-gd.lib<br>vtkIOEnSight-8.2-gd.lib<br>vtkIOExodus-8.2-gd.lib<br>vtkIOExport-8.2-gd.lib<br>vtkIOExportOpenGL2-8.2-gd.lib<br>vtkIOExportPDF-8.2-gd.lib<br>vtkIOGeometry-8.2-gd.lib<br>vtkIOImage-8.2-gd.lib<br>vtkIOImport-8.2-gd.lib<br>vtkIOInfovis-8.2-gd.lib<br>vtkIOLegacy-8.2-gd.lib<br>vtkIOLSDyna-8.2-gd.lib<br>vtkIOMINC-8.2-gd.lib<br>vtkIOMovie-8.2-gd.lib<br>vtkIONetCDF-8.2-gd.lib<br>vtkIOParallel-8.2-gd.lib<br>vtkIOParallelXML-8.2-gd.lib<br>vtkIOPLY-8.2-gd.lib<br>vtkIOSegY-8.2-gd.lib<br>vtkIOSQL-8.2-gd.lib<br>vtkIOTecplotTable-8.2-gd.lib<br>vtkIOVeraOut-8.2-gd.lib<br>vtkIOVideo-8.2-gd.lib<br>vtkIOXML-8.2-gd.lib<br>vtkIOXMLParser-8.2-gd.lib<br>vtkjpeg-8.2-gd.lib<br>vtkjsoncpp-8.2-gd.lib<br>vtklibharu-8.2-gd.lib<br>vtklibxml2-8.2-gd.lib<br>vtklz4-8.2-gd.lib<br>vtklzma-8.2-gd.lib<br>vtkmetaio-8.2-gd.lib<br>vtkNetCDF-8.2-gd.lib<br>vtkogg-8.2-gd.lib<br>vtkParallelCore-8.2-gd.lib<br>vtkpng-8.2-gd.lib<br>vtkproj-8.2-gd.lib<br>vtkpugixml-8.2-gd.lib<br>vtkRenderingAnnotation-8.2-gd.lib<br>vtkRenderingContext2D-8.2-gd.lib<br>vtkRenderingContextOpenGL2-8.2-gd.lib<br>vtkRenderingCore-8.2-gd.lib<br>vtkRenderingExternal-8.2-gd.lib<br>vtkRenderingFreeType-8.2-gd.lib<br>vtkRenderingGL2PSOpenGL2-8.2-gd.lib<br>vtkRenderingImage-8.2-gd.lib<br>vtkRenderingLabel-8.2-gd.lib<br>vtkRenderingLOD-8.2-gd.lib<br>vtkRenderingOpenGL2-8.2-gd.lib<br>vtkRenderingVolume-8.2-gd.lib<br>vtkRenderingVolumeOpenGL2-8.2-gd.lib<br>vtksqlite-8.2-gd.lib<br>vtksys-8.2-gd.lib<br>vtktheora-8.2-gd.lib<br>vtktiff-8.2-gd.lib<br>vtkverdict-8.2-gd.lib<br>vtkViewsContext2D-8.2-gd.lib<br>vtkViewsCore-8.2-gd.lib<br>vtkViewsInfovis-8.2-gd.lib<br>vtkzlib-8.2-gd.lib</p><h1 id="8-程序测试"><a href="#8-程序测试" class="headerlink" title="8.程序测试"></a>8.程序测试</h1><pre><code>#include &lt;pcl/visualization/cloud_viewer.h&gt;  #include &lt;iostream&gt;  #include &lt;pcl/io/io.h&gt;  #include &lt;pcl/io/pcd_io.h&gt;  int user_data;void viewerOneOff(pcl::visualization::PCLVisualizer&amp; viewer)&#123;    viewer.setBackgroundColor(1.0, 0.5, 1.0);    pcl::PointXYZ o;    o.x = 1.0;    o.y = 0;    o.z = 0;    viewer.addSphere(o, 0.25, &quot;sphere&quot;, 0);    std::cout &lt;&lt; &quot;i only run once&quot; &lt;&lt; std::endl;&#125;void viewerPsycho(pcl::visualization::PCLVisualizer&amp; viewer)&#123;    static unsigned count = 0;    std::stringstream ss;    ss &lt;&lt; &quot;Once per viewer loop: &quot; &lt;&lt; count++;    viewer.removeShape(&quot;text&quot;, 0);    viewer.addText(ss.str(), 200, 300, &quot;text&quot;, 0);    //FIXME: possible race condition here:      user_data++;&#125;int main()&#123;    pcl::PointCloud&lt;pcl::PointXYZRGBA&gt;::Ptr cloud(new pcl::PointCloud&lt;pcl::PointXYZRGBA&gt;);    pcl::io::loadPCDFile(&quot;D:\\Microsoft Visual Studio 10.0\\Projects\\pcl\\pcl\\my_point_cloud.pcd&quot;, *cloud);    pcl::visualization::CloudViewer viewer(&quot;Cloud Viewer&quot;);    //blocks until the cloud is actually rendered      viewer.showCloud(cloud);    //use the following functions to get access to the underlying more advanced/powerful      //PCLVisualizer      //This will only get called once      viewer.runOnVisualizationThreadOnce(viewerOneOff);    //This will get called once per visualization iteration      viewer.runOnVisualizationThread(viewerPsycho);    while (!viewer.wasStopped())    &#123;        //you can also do cool processing here          //FIXME: Note that this is running in a separate thread from viewerPsycho          //and you should guard against race conditions yourself...          user_data++;    &#125;    return 0;&#125;</code></pre><p>测试结果：</p><p><img src="/blog_img/PCL配置/16.png" alt=""></p><hr>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;1-软件准备&quot;&gt;&lt;a href=&quot;#1-软件准备&quot; class=&quot;headerlink&quot; title=&quot;1.软件准备&quot;&gt;&lt;/a&gt;1.软件准备&lt;/h1&gt;&lt;p&gt;1.All in one 安装包。&lt;/p&gt;
&lt;p&gt;2.获取All in one 包对应得PDB文件包，用于后期单步调试。&lt;br&gt;</summary>
    
    
    
    <category term="PCL" scheme="https://zzygeo.cn/categories/PCL/"/>
    
    
  </entry>
  
  <entry>
    <title>hexo d 出现错误的用户名和密码的解决办法</title>
    <link href="https://zzygeo.cn/2020/10/02/Hexo/hexo-d-%E5%87%BA%E7%8E%B0%E9%94%99%E8%AF%AF%E7%9A%84%E7%94%A8%E6%88%B7%E5%90%8D%E5%92%8C%E5%AF%86%E7%A0%81%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <id>https://zzygeo.cn/2020/10/02/Hexo/hexo-d-%E5%87%BA%E7%8E%B0%E9%94%99%E8%AF%AF%E7%9A%84%E7%94%A8%E6%88%B7%E5%90%8D%E5%92%8C%E5%AF%86%E7%A0%81%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</id>
    <published>2020-10-02T05:27:01.000Z</published>
    <updated>2021-05-24T00:59:55.647Z</updated>
    
    <content type="html"><![CDATA[<p>在windows搜索栏输入：控制面板<a id="more"></a>)<br><img src="/blog_img/hexo d时错误用户名和密码解决办法/1.png" alt=""><br>然后点击：<br><img src="/blog_img/hexo d时错误用户名和密码解决办法/2.png" alt=""><br><img src="/blog_img/hexo d时错误用户名和密码解决办法/3.png" alt=""><br><img src="/blog_img/hexo d时错误用户名和密码解决办法/4.png" alt=""></p><p>点进去就可以更改用户名和密码了</p><hr>]]></content>
    
    
    <summary type="html">&lt;p&gt;在windows搜索栏输入：控制面板</summary>
    
    
    
    <category term="Hexo" scheme="https://zzygeo.cn/categories/Hexo/"/>
    
    
  </entry>
  
  <entry>
    <title>新电脑上部署hexo</title>
    <link href="https://zzygeo.cn/2020/10/02/Hexo/%E6%96%B0%E7%94%B5%E8%84%91%E4%B8%8A%E9%83%A8%E7%BD%B2hexo/"/>
    <id>https://zzygeo.cn/2020/10/02/Hexo/%E6%96%B0%E7%94%B5%E8%84%91%E4%B8%8A%E9%83%A8%E7%BD%B2hexo/</id>
    <published>2020-10-02T05:07:29.000Z</published>
    <updated>2021-05-24T01:00:12.425Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-安装必要软件"><a href="#1-安装必要软件" class="headerlink" title="1. 安装必要软件"></a>1. 安装必要软件</h1><p>安装 Git 客户端<br>安装 node JS</p><a id="more"></a><hr><h1 id="2-拷贝源文件"><a href="#2-拷贝源文件" class="headerlink" title="2. 拷贝源文件"></a>2. 拷贝源文件</h1><p>将初始电脑上个人博客文件夹下这几个文件夹拷到当前新电脑的准备设置的博客路径下。</p><pre><code>_config.ymlpackage.jsonscaffolds/source/themes/</code></pre><hr><h1 id="3-安装hexo"><a href="#3-安装hexo" class="headerlink" title="3. 安装hexo"></a>3. 安装hexo</h1><p>在 cmd 下输入下面指令安装 hexo:</p><pre><code>npm install -g hexo</code></pre><hr><h1 id="4-在新博客路径下，安装三方依赖库"><a href="#4-在新博客路径下，安装三方依赖库" class="headerlink" title="4. 在新博客路径下，安装三方依赖库"></a>4. 在新博客路径下，安装三方依赖库</h1><pre><code>npm installnpm install hexo-deployer-git --save //文章部署到 git 的模块npm install 主题需要的插件</code></pre><p><strong>千万别hxeo init</strong>，不然你就拉在裤子里了！！！</p><hr><h1 id="5-GITHUB-gitee-添加-SSH-KEYS"><a href="#5-GITHUB-gitee-添加-SSH-KEYS" class="headerlink" title="5. GITHUB/gitee 添加 SSH KEYS"></a>5. GITHUB/gitee 添加 SSH KEYS</h1><p>在GitHub/gitee的ssh keys那里再添加一个当前电脑的环境生成的key，但是可别把原来的电脑删掉了啊。<br>首先在本地创建 SSH Keys:</p><pre><code>ssh-keygen -t rsa -C “xxxx@xxxx.com“</code></pre><p>后面的邮箱即为 github/gitee注册邮箱，也是你登录Github的邮箱（其实无关紧要，只是为了辨识生成的用户名），之后会要求确认路径和输入密码，一路回车就行。<br>成功的话会在git bash页面下看到生成的 .ssh文件夹路径，进去，打开 id_rsa.pub，复制里面的key（全选）即可。然后拷贝到 Github/gitee 的 SSH Keys(这里要添加一个新的)<br>然后在终端中，我们再次测试下公钥有没有添加成功：</p><pre><code>ssh -T git@gitee.com </code></pre><p>会弹出确认命令，输入yes,会弹出你的名字等等，会出现：</p><pre><code>Hi username! You&#39;ve successfully authenticated, but GitHub does not provide shell access.</code></pre><p>然后：</p><pre><code>hexo ghexo shexo d</code></pre><hr>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;1-安装必要软件&quot;&gt;&lt;a href=&quot;#1-安装必要软件&quot; class=&quot;headerlink&quot; title=&quot;1. 安装必要软件&quot;&gt;&lt;/a&gt;1. 安装必要软件&lt;/h1&gt;&lt;p&gt;安装 Git 客户端&lt;br&gt;安装 node JS&lt;/p&gt;</summary>
    
    
    
    <category term="Hexo" scheme="https://zzygeo.cn/categories/Hexo/"/>
    
    
  </entry>
  
  <entry>
    <title>我的Office激活码</title>
    <link href="https://zzygeo.cn/2020/09/26/%E5%85%B6%E4%BB%96/%E6%88%91%E7%9A%84Office%E6%BF%80%E6%B4%BB%E7%A0%81/"/>
    <id>https://zzygeo.cn/2020/09/26/%E5%85%B6%E4%BB%96/%E6%88%91%E7%9A%84Office%E6%BF%80%E6%B4%BB%E7%A0%81/</id>
    <published>2020-09-26T05:05:29.000Z</published>
    <updated>2021-04-24T13:17:10.478Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">Enter password to read.</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="03c1ac4465e4cf3a48495d4bf2e5305f5459e5aa002e29362a916042d55d3feb">a40b706f3ef3cecdee82bde9ce2bd4514c0daefd2ecc9a0471c6dd32fb89c21dd33d989c9838561713a671711864b0b1a1a4480b4508e9ff8837f455c5dce0fe5f300a44bdd7e4e87f4cf4ad6a977b3a2e1fb4941673530eba42a436b7ddbc2a833161220ce856a9c50b0f0a00948c6120e291cacc8235d9112cea2d0ff237ff547ad3c0557cede69bb6e0acac70ff7e8dfd7357b4b0819f29e0b32a89991ff85dbb291e5440a99f3e89272087d1a7bad163b67007c9db378d5b7519efb4bc6adfc98224fb4ce577a17143fe36acb2235be6db2fbdd89c6784c0966f78aecbf7df789c5ac3fbdc42aad6b3332ae1ff1e862ad8340e40571113b1a0f03023896f1f4e9d0282ddc48e33f8992ebced357dfafab8477f1b7ddb0c479b4ef223cd7aa6c3b47bac939edf42c2ea6eeb5976a6c37e76ad4ac9a7c25cf6e5f0161cbe47578cd75de43b1fb65e794e1b15d764b9</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">Welcome to my blog, enter password to read.</summary>
    
    
    
    
    <category term="-office" scheme="https://zzygeo.cn/tags/office/"/>
    
  </entry>
  
  <entry>
    <title>markdown语法</title>
    <link href="https://zzygeo.cn/2020/09/24/Hexo/markdown%E8%AF%AD%E6%B3%95/"/>
    <id>https://zzygeo.cn/2020/09/24/Hexo/markdown%E8%AF%AD%E6%B3%95/</id>
    <published>2020-09-24T06:30:05.000Z</published>
    <updated>2021-05-24T01:00:05.904Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-标题"><a href="#1-标题" class="headerlink" title="1.标题"></a>1.标题</h1><a id="more"></a><pre><code># 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 </code></pre><p>注：# 和「标题文字」之间建议保留一个字符的空格，这是最标准的 Markdown 写法。</p><hr><h1 id="2-粗体、斜体、删除线"><a href="#2-粗体、斜体、删除线" class="headerlink" title="2. 粗体、斜体、删除线"></a>2. 粗体、斜体、删除线</h1><pre><code>*我是斜体***我是粗体*****我是粗斜体***~~我是删除线~~</code></pre><p>显示效果：<br><em>我是斜体</em><br><strong>我是粗体</strong><br><strong><em>我是粗斜体</em></strong><br><del>我是删除线</del></p><hr><h1 id="3-表格"><a href="#3-表格" class="headerlink" title="3. 表格"></a>3. 表格</h1><pre><code>| 学号 | 姓名 | 分数|| :- | -: | :-: || 小明 | 男 | 75 || 小红 | 女 | 79 || 小陆 | 男 | 92 |</code></pre><p>显示效果：</p><div class="table-container"><table><thead><tr><th style="text-align:left">学号</th><th style="text-align:right">姓名</th><th style="text-align:center">分数</th></tr></thead><tbody><tr><td style="text-align:left">小明</td><td style="text-align:right">男</td><td style="text-align:center">75</td></tr><tr><td style="text-align:left">小红</td><td style="text-align:right">女</td><td style="text-align:center">79</td></tr><tr><td style="text-align:left">小陆</td><td style="text-align:right">男</td><td style="text-align:center">92</td></tr></tbody></table></div><hr><h1 id="4-有序列表"><a href="#4-有序列表" class="headerlink" title="4. 有序列表"></a>4. 有序列表</h1><pre><code>1. 文本12. 文本23. 文本3</code></pre><p>显示效果：  </p><ol><li>文本1</li><li>文本2</li><li>文本3</li></ol><hr><h1 id="5-无序列表"><a href="#5-无序列表" class="headerlink" title="5. 无序列表"></a>5. 无序列表</h1><pre><code>- 文本1- 文本2- 文本3</code></pre><p>显示效果：  </p><ul><li>文本1</li><li>文本2</li><li>文本3</li></ul><hr><h1 id="6-行内代码块"><a href="#6-行内代码块" class="headerlink" title="6. 行内代码块"></a>6. 行内代码块</h1><pre><code>C语言里的函数 `scanf()` 怎么使用？</code></pre><p>显示效果：<br>C语言里的函数 <code>scanf()</code> 怎么使用？</p><hr><h1 id="7-分割线"><a href="#7-分割线" class="headerlink" title="7. 分割线"></a>7. 分割线</h1><h2 id="可以在一行中用三个以上的减号、底线来建立一个分隔线，行内不能有其他内容。"><a href="#可以在一行中用三个以上的减号、底线来建立一个分隔线，行内不能有其他内容。" class="headerlink" title="可以在一行中用三个以上的减号、底线来建立一个分隔线，行内不能有其他内容。  "></a>可以在一行中用三个以上的减号、底线来建立一个分隔线，行内不能有其他内容。  </h2><pre><code>___</code></pre><h2 id="显示效果："><a href="#显示效果：" class="headerlink" title="显示效果："></a>显示效果：</h2><hr><hr><h1 id="8-超链接"><a href="#8-超链接" class="headerlink" title="8. 超链接"></a>8. 超链接</h1><p>语法格式为<a href="链接地址" title="链接标题">链接文字</a>，[]里写链接文字，()里写链接地址, ()中的”“中可以为链接指定title属性，title属性为可选。title属性的效果是鼠标悬停在链接上会出现指定的title文字。链接地址与链接标题前有一个空格。<br>    欢迎来到<a href="http://blog.csdn.net/china_jeffery" title="zzygeo">多加香菜的博客</a></p><p>显示效果：<br>欢迎来到<a href="http://blog.csdn.net/china_jeffery" title="zzygeo">多加香菜的博客</a></p><hr><h1 id="9-图片"><a href="#9-图片" class="headerlink" title="9. 图片"></a>9. 图片</h1><p>语法格式为<img src="图片地址" alt="图片Alt" title="图片Title">，图片Alt的意思是如果图片因为某些原因不能显示，就用定义的图片Alt文字来代替图片。 图片Title则和超链接中的链接标题一样，表示鼠标悬停与图片上时出现的文字。 图片Alt 和 图片Titlee 都是可选的。</p><hr><h1 id="10-引用"><a href="#10-引用" class="headerlink" title="10. 引用"></a>10. 引用</h1><pre><code>&gt; 一级引用&gt;&gt; 二级引用&gt;&gt;&gt; 三级引用&gt;&gt;&gt;&gt; 四级引用</code></pre><p>显示效果：</p><blockquote><p>一级引用</p><blockquote><p>二级引用</p><blockquote><p>三级引用</p><blockquote><p>四级引用</p></blockquote></blockquote></blockquote></blockquote><hr><h1 id="11-空格"><a href="#11-空格" class="headerlink" title="11. 空格"></a>11. 空格</h1><pre><code>你好&amp;nbsp;&amp;nbsp;&amp;nbsp;jeffery</code></pre><p>显示效果<br>你好&nbsp;&nbsp;&nbsp;zzy</p><hr><h1 id="12-字体、字号、颜色"><a href="#12-字体、字号、颜色" class="headerlink" title="12. 字体、字号、颜色"></a>12. 字体、字号、颜色</h1><pre><code>&lt;font face=&quot;黑体&quot;&gt;我是黑体字&lt;/font&gt;&lt;font face=&quot;微软雅黑&quot;&gt;我是微软雅黑&lt;/font&gt;&lt;font color=#0099ff size=23 face=&quot;黑体&quot;&gt;我是黑体，颜色#0099ff 字号23&lt;/font&gt;</code></pre><p><font face="黑体">我是黑体字</font>  </p><p><font face="微软雅黑">我是微软雅黑</font>  </p><p><font color=#00 size=23 face="黑体">我是黑体，颜色#0099ff 字号23</font>&lt;/p&gt;</p><hr>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;1-标题&quot;&gt;&lt;a href=&quot;#1-标题&quot; class=&quot;headerlink&quot; title=&quot;1.标题&quot;&gt;&lt;/a&gt;1.标题&lt;/h1&gt;</summary>
    
    
    
    <category term="Hexo" scheme="https://zzygeo.cn/categories/Hexo/"/>
    
    
  </entry>
  
</feed>
