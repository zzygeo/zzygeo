{"meta":{"title":"我说个数，1500W","subtitle":null,"description":"","author":"Regular","url":"https://zzygeo.cn","root":"/"},"pages":[{"title":"categories","date":"2021-02-26T08:36:55.000Z","updated":"2021-05-23T16:57:17.586Z","comments":true,"path":"categories/index.html","permalink":"https://zzygeo.cn/categories/index.html","excerpt":"","text":""},{"title":"About","date":"2021-05-23T15:44:12.000Z","updated":"2021-05-24T01:16:26.212Z","comments":true,"path":"about/index.html","permalink":"https://zzygeo.cn/about/index.html","excerpt":"","text":"1.关于我大家好，我是周钟炎，一名测绘狗，研究生在读。 2016.9-2020.6 中国矿业大学(北京) - 遥感科学与技术 - 学士 2020.9-2022.7 中山大学 - 资源与环境 - 硕士 2.关于blog这个博客是用的吴俊的模板，在这里先贴上demo链接，以及github主题。 第一眼看到这个主题就觉得这个主题非常适合做笔记，很简单实用也不难看。 3.为什么写blog好吧，我就是想转行，在学习开发的同时，记录一些学习的笔记。在这个专业已经耗了好几年，本科已经浪费了很多时间，属实学测绘没什么意思，情况好点的都是与测绘相关的开发，与本行教的那些东西其实是存在脱节的，想学好就自己多折磨吧，带上痛苦面具，然而出去的待遇的实在对不起学了这么久的这玩意，即使我没出去干过，但我觉得其技术栈肯定也不行，会限制发展，真的不如直接一口气转码。"}],"posts":[{"title":"JavaScript基础","slug":"JavaScript/JavaScript","date":"2021-06-08T01:56:55.000Z","updated":"2021-06-08T01:56:32.380Z","comments":true,"path":"2021/06/08/JavaScript/JavaScript/","link":"","permalink":"https://zzygeo.cn/2021/06/08/JavaScript/JavaScript/","excerpt":"","text":"1.JavaScript介绍JavaScript实现包含了三个部分，ECMAScript, DOM和BOM ECMAScript：JavaScript语法 DOM：页面文档对象模型 BOM：浏览器对象模型 JS的特点 1.解释性语言—写完了直接运行，不用去编译 2.类似于C和Java的语法结构 3.动态语言 4.基于原型的面向对象 浏览器执行JS简介 浏览器分为两部分，渲染引擎和JS引擎 渲染引擎：用来解析HTML和CSS，俗称内核，比如chrome浏览器的blink,老版本的webkit JS引擎：也称为JS解释器。用来读取网页中的JavaScript代码，对其处理后运行，比如chrome浏览器的V8 2. JS有三种书写位置1.行内式JS &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&quot;button&quot; value=&quot;点我试试&quot; onclick=&quot;alert(&#39;hello world&#39;)&quot; &lt;/body&gt; &lt;/html&gt; 可以将单行或者少量JS代码写在HTML标签的事件属性中（以on开头的属性），如onclik 注意单双引号的使用：在HTML中我们推荐使用双引号, JS中我们推荐使用单引号 可读性差，在html中编写JS大量代码时，不方便阅读 引号易错，引号多层嵌套匹配时，非常容易弄混 特殊情况下使用 2.内嵌式JS &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; alert(&#39;hello world!&#39;) &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 可以将多行JS代码写到标签中 内嵌JS是学习时常用的方式 3.外部JS文件 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;hello.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 利于HTML页面代码结构化，把大段JS代码独立到HTML页面之外，既美观，也方便文件级别的复用 引用外部JS文件的script标签中间不可以写代码 适用于JS代码量比价大的情况 3. JavaScript输入输出语句&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; // 这是一个输入框 prompt(&#39;请输入年龄&#39;); // alert弹出警示框 alert(&#39;计算的结果是&#39;); // console 控制台输出 给程序员测试用的,f12进入开发者模式可见 console.log(&#39;这是程序员能看到的&#39;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 4. 数据类型JavaScript是一种弱类型或者说动态语言，这意味着不用提前声明变量的类型，==在程序运行过程中，类型会被自动确定。== JavaScript==拥有动态类型，同时也意味着相同的变量可用作不同的类型== 数值型：==isNaN()==可以用来判断非数字，如果是数字返回的是false, 如果不是数字返回的是true &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; console.log(isNaN(5)); //false console.log(isNaN(&#39;str&#39;)) //true &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 字符串长度，直接变量名.length，注意==这里没有括号==。 布尔类型参与加法运算当做0或1来看待 变量声明未赋值，就是undefined未定义数据类型 undefined和数字相加，最后的结果是NaN typeof可以检测变量属于什么类型 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; var num = 10; var str = &#39;明天会更好！&#39;; console.log(typeof(num)); console.log(typeof(str)); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; prompt取过来的值是 字符型的 5. 数据类型转换转换为字符串型 1.把数值型转换为字符串类型 toString(); &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;title&lt;/title&gt; &lt;script&gt; var age = 10; var str = age.toString(); console.log(str); console.log(typeof str); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 2.利用String()方法 3.利用+拼接字符串的方法实现转换效果 ==一般使用的都是第三种方式进行转换，这一方法也称为隐式转换== 转换为数值型 1.通过parseInt函数进行转换，把String转换成整数类型 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;title&lt;/title&gt; &lt;script&gt; var age = prompt(&#39;请输入您的年龄&#39;); console.log(parseInt(age)); console.log(parseInt(&#39;120px&#39;)); //parseInt方法会直接去掉字母，但必须是以数字打头 &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 2.通过parseFloat可以把String转换为浮点型 3.可以通过Number()进行转换 4.利用算数运算 - * / 隐式转换 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;title&lt;/title&gt; &lt;script&gt; console.log(&#39;12&#39; - 0); console.log(&#39;123&#39; - &#39;120&#39;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 转换为布尔型 使用Boolean()函数 代表空、否定的值会被转换为false，如’’、0、NaN、null、undefined 其他的值全部会转换成true &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;title&lt;/title&gt; &lt;script&gt; console.log(Boolean(&#39;&#39;)); console.log(Boolean(0)); console.log(Boolean(NaN)); console.log(Boolean(null)); console.log(Boolean(undefined)); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 6. 运算符=== !== 全等 要求值和数据类型都一致 运算符优先级 优先级 运算符 顺序 1 小括号 () 2 一元运算符 ++ — ! 3 算数运算符 先 * / % 后+ - 4 关系运算符 &gt; &gt;= &lt; &lt;= 5 相等运算符 == != === !== 6 逻辑运算符 先&amp;&amp; 后\\ \\ 7 赋值运算符 = 8 逗号运算符 ， 7. 流程控制和Java语法类似 8. 数组创建数组的方式有两种 var arr = new Array(); var arr1 = []; var arr2 = [1, 2, &#39;zzy&#39;, true]; 注意JavaScript里的数组是==可以混用数据类型的== console.log(arr1); //这里打印的不是地址，包含整个数组的信息 ==新增数组元素：修改索引值，追加数组元素==，push方法也可以 9. 函数&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;title&lt;/title&gt; &lt;script&gt; function getsum(num1, num2)&#123; var sum = 0; for (var i = num1; i &lt;= num2 ; i++) &#123; sum += i; &#125; return sum; &#125; console.log(getsum(10, 20)); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 讲道理，这语法有点无耻 函数与数组 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;title&lt;/title&gt; &lt;script&gt; function getmax(arr)&#123; var max = arr[0]; for (var i = 0; i &lt; arr.length; i++) &#123; if (arr[i] &gt; max)&#123; max = arr[i]; &#125; &#125; return max; &#125; var re = getmax([5, 2, 99, 101, 67, 77]); console.log(re); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 脚本语言就是有点无耻 return 只能返回一个值，传多个以传入的最后一个值为准 函数都是有返回值的 1.如果有return则返回return后面的值 2.如果没有return则返回undefined break, continue,return的区别 break:结束当前的循环体 continue:跳出本次循环，继续执行下次循环 return:不仅可以退出循环，还能够返回return语句中的值，同时还可以结束当前的函数体内的代码 10. arguments在强调一遍脚本语言很无耻。 当我们==不确定有多少个参数传递时==，可以用arguments来获取。在JavaScript中，arguments实际上它是当前函数的一个内置对象。==所有函数都内置了一个arguments对象，arguments对象中存储了传递的所有实参== &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;title&lt;/title&gt; &lt;script&gt; function fn()&#123; console.log(arguments); //arguments是伪数组，没有一些方法，如pop(), console.log(arguments[2]); &#125; fn(1, 2, 3); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 11. 作用域就是代码名字（变量）在某个范围内起作用和效果，目的是为了提高程序的可靠性，更重要的是减少命名冲突 全局作用域：整个script标签 或者是一个单数的js文件 局部作用域：在函数内部就是局部作用域，这个代码的名字只在函数内部起效果和作用 ==注意：如果在函数内部，没有声明直接赋值的变量也属于全局变量== &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;title&lt;/title&gt; &lt;script&gt; function fn()&#123; var num1 =10; num2 = 20; &#125; fn(); console.log(num2); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 12. 预解析JavaScript代码是由浏览器中的JavaScript解释器来执行的。JavaScript解析器在运行JavaScript的时候分为两步：==预解析和代码执行==。 预解析 js解释器==会把js里面所有的var还有function提升到当前作用域的最前面== 代码执行：按照代码书写的顺序从上往下执行 预解析分为变量预解析（变量提升）和函数预解析（函数提升） 变量提升就是把所有的变量声明提升到当前的作用域最前面,==不提升赋值操作== 函数提升就是把所有的函数声明（感觉js的声明好像也包含了定义的意思）提升到当前作用域的最前面，==不调用函数== &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;title&lt;/title&gt; &lt;script&gt; var a = 18; f1(); function f1()&#123; var b = 9; console.log(a); console.log(b); var a = &#39;123&#39;; &#125; /* var a; function f1()&#123; var b; var a; b = 9; console.log(a); //undefined console.log(b); //9 a = &#39;123&#39;; &#125; a =18; f1(); */ &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;title&lt;/title&gt; &lt;script&gt; f1(); console.log(c); console.log(b); console.log(a); function f1()&#123; var a = b = c = 9; console.log(a); console.log(b); console.log(c); &#125; /* function f1()&#123; //相当于var a =9, b =9, c = 9; 函数内部不声明直接赋值相当于全局变量 var a; a = b = c = 9; console.log(a); //9 console.log(b); //9 console.log(c); //9 &#125; f1(); console.log(c); //9 console.log(b); //9 console.log(a); //报错 */ &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 13. 对象创建对象的三种方式: 利用对象字面量创建对象{} &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;title&lt;/title&gt; &lt;script&gt; //1.利用对象字面量创建对象&#123;&#125; // var obj =&#123;&#125;; var obj = &#123; uname: &#39;杰克船长&#39;, age: 18, sex: &#39;男&#39;, sayHi: function ()&#123; console.log(&#39;hi~&#39;) &#125; &#125; /* 细节： 里面的属性和方法采用键值对的形式 属性名： 属性值 多个属性或方法中间用逗号隔开 方法冒号后面跟的是一个匿名函数 */ &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 利用new Object创建对象 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;title&lt;/title&gt; &lt;script&gt; var obj = new Object(); obj.uname = &#39;杰克船长&#39;; obj.age = 18; obj.sex = &#39;男&#39;; obg.sayHi = function ()&#123; console.log(&#39;hi~&#39;); &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 利用构造函数创建对象 为什么需要构造函数来创建对象：因为前面两种创建对象的方式一次只能创建一个对象，因此可以利用函数的方法，重复这些相同的代码，我们就把这个函数称为构造函数 构造函数：就是把我们对象里面一些相同的属性和方法抽象出来封装到函数里面 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;title&lt;/title&gt; &lt;script&gt; function Star(uname, age, sex)&#123; this.name = uname; this.age = age; this.sex = sex; this.sing = function (sang)&#123; console.log(sang) &#125; &#125; var ldh = new Star(&#39;刘德华&#39;, 18, &#39;男&#39;); console.log(typeof ldh); console.log(ldh.name); console.log(ldh.sex); ldh.sing(&#39;冰雨&#39;); var zxy = new Star(&#39;张学友&#39;, 19, &#39;男&#39;); console.log(zxy.name); zxy.sing(&#39;吻别&#39;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 细节： 构造函数名字首字母要大写 ==构造函数不需要return就可以返回结果== 调用构造函数，必须使用new 构造函数和对象区别： 构造函数是泛指的某一大类，它类似于java语言里的类 对象是一个具体的事物 遍历对象 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;title&lt;/title&gt; &lt;script&gt; var obj = &#123; name: &#39;杰克船长&#39;, age: 18, sex: &#39;男&#39; &#125; for (var k in obj)&#123; console.log(k); // 输入k，输出的是属性名 console.log(obj[k]); //obj[k], 得到的是属性值 &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 14. 内置对象JavaScript的对象分为3种：自定义对象、内置对象、浏览器对象 前面两种对象是JS基础内容，属于ECMAScript；第三个浏览器对象属于我们JS独有的 内置对象就是指JS语言自带的一些对象，这些对象供开发者使用，并提供了一些常用的或是最基本而必要的功能（属性和方法） MDN： Mozilla开发者网络提供了有关开放网络技术的信息，包括HTML、CSS和万维网以及HTML5应用的API MDN Math对象&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;title&lt;/title&gt; &lt;script&gt; console.log(Math.floor(5.1)); //向下取整, 5 console.log(Math.ceil(5.1)); //向上取整, 6 console.log(Math.round(-3.1)); //就近取整, -3 console.log(Math.round(-3.5)); //搞个坐标轴从左到右看, -3 console.log(Math.round(5.5)); //6 console.log(Math.abs(-2.3)); //2.3 console.log(Math.random()); function getRandomIntInclusive(min, max) &#123; min = Math.ceil(min); max = Math.floor(max); return Math.floor(Math.random() * (max - min + 1) + min); &#125; console.log(getRandomIntInclusive(1, 10)); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 日期对象Date日期对象是一个构造函数，必须使用new来调用创建我们的日期对象 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;title&lt;/title&gt; &lt;script&gt; var date = new Date(); console.log(date); var date1 = new Date(1999,1,11); //返回的月份会比输入的多1个月，0-11开始进行计算 console.log(date1); var date2 = new Date(&#39;1998-11-24 22:11:34&#39;); console.log(date2); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;title&lt;/title&gt; &lt;script&gt; var date = new Date(); console.log(date.getFullYear()); console.log(date.getMonth() + 1); console.log(date.getDate()); console.log(date.getDay()); //周一返回的是1 周六返回的是6，但是周日返回的是0 &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 时间戳（指距离1970年1月1号00:00过去的毫秒数） ==var date = +new Date(); 可以直接获取时间戳== 其他方法不再赘述，查阅MDN文档即可 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;title&lt;/title&gt; &lt;script&gt; function conutDown(time) &#123; var inputTime = +new Date(time); var nowTime = Date.now(); var times = (inputTime - nowTime) / 1000; var d = parseInt( times / 60 / 60 / 24); d = d &lt; 10 ? &#39;0&#39; + d : d; var h = parseInt(times / 60 / 60 % 24); h = h &lt; 10 ? &#39;0&#39; + h : h; var m = parseInt(times / 60 % 60); m = m &lt; 10 ? &#39;0&#39; + m : m; var s = parseInt(times % 60); s = s &lt; 10 ? &#39;0&#39; + s : s; return d + &#39;天&#39; + h + &#39;时&#39; + m + &#39;分&#39; + s + &#39;秒&#39;; &#125; console.log(conutDown(&#39;2021-6-7 21:00:00&#39;)); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 数组对象push: 尾插 pop: 尾删 unshift: 头插 shift: 头删 sort:排序 reverse: 翻转 ==升序降序的写法：== &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;title&lt;/title&gt; &lt;script&gt; var arr1 = [13, 4, 77, 1, 7]; var arr2 = [13, 3, 77, 7, 1]; arr1.sort(function (a, b) &#123;//仿函数,升序 return a - b; &#125;); arr2.sort(function (a, b) &#123;//仿函数,降序 return b -a; &#125;) console.log(arr1); console.log(arr2); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 数组去重 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;title&lt;/title&gt; &lt;script&gt; function unique(arr) &#123;//利用indexOf去判断 var arr1 = []; for (var i = 0; i &lt; arr.length; i++) &#123; if (arr1.indexOf(arr[i]) == -1)&#123; arr1.push(arr[i]); &#125; &#125; return arr1; &#125; var arr = unique([1, 2, 3, 5, 1, 2, 2, 7 ,8 ,9]); console.log(arr); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 数组转换成字符串 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;title&lt;/title&gt; &lt;script&gt; //1.第一种方法 var arr = [1, 2, 3]; console.log(arr.toString()); //2第二种方法,使用join,可以自己指定分隔符 console.log(arr.join(&#39;-&#39;)); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 15. 基本包装类型&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;title&lt;/title&gt; &lt;script&gt; var str = &#39;andy&#39;; console.log(str.length); //4 //对象才有属性和方法， 复杂的数据类型才有属性和方法 //简单数据类型会具有length属性，是因为简单数据类型被包装成了复杂数据类型 //步骤如下： var temp = new String(&#39;andy&#39;); //临时变量复制给str str = temp; //销毁临时变量 temp = null; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 16. 字符串的不可变性字符串不可变性是指里面的值不可变，虽然看上去内容改变了，但其实是地址变了，内存中新开辟了一个内存空间，所以大量使用字符串拼接会出现效率问题。 根据字符返回位置： var str = &#39;春天来了，这是春天的气息&#39;; console.log(str.indexOf(&#39;春&#39;)); console.log(str.indexOf(&#39;春&#39;, 3)); //从索引号是3的位置开始往后查找 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;title&lt;/title&gt; &lt;script&gt; var arr = [&#39;red&#39;, &#39;blue&#39;, &#39;red&#39;, &#39;green&#39;, &#39;pink&#39;, &#39;red&#39;]; var index = arr.indexOf(&#39;red&#39;); // console.log(arr.indexOf(&#39;red&#39;)); var num = 0; while (index != -1) &#123; console.log(index); num++; index = arr.indexOf(&#39;red&#39;, index + 1); &#125; console.log(&#39;red出现的次数为：&#39; + num); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 根据位置返回字符： charAt(index); 返回指定位置的字符 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;title&lt;/title&gt; &lt;script&gt; var str = &#39;andy&#39;; for (var i = 0; i &lt; str.length; i++) &#123; console.log(str.charAt(i)); &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 2.charCodeAt(index) 返回指定位置处的ASCII码,用于判断用户按下了哪个键 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;title&lt;/title&gt; &lt;script&gt; var str = &#39;andy&#39;; for (var i = 0; i &lt; str.length; i++) &#123; console.log(str.charCodeAt(i)); &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 3.str[index]; 获取指定位置处字符,H5新增的写法 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;title&lt;/title&gt; &lt;script&gt; var str = &#39;andy&#39;; for (var i = 0; i &lt; str.length; i++) &#123; console.log(str[i]); &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;title&lt;/title&gt; &lt;script&gt; var o = &#123; age: 18 &#125; if (o[&#39;age&#39;]) &#123;//判断类里是否有该属性 console.log(&#39;里面有该属性&#39;); &#125;else &#123; console.log(&#39;没有该属性&#39;); &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;title&lt;/title&gt; &lt;script&gt; //统计出现次数最多的字符 var str = &#39;abcoefoxyozzopp&#39;; var o = &#123;&#125;; for (var i = 0; i &lt; str.length; i++) &#123; var val = str[i]; if (o[val]) &#123; o[val]++; &#125;else &#123; o[val] = 1; &#125; &#125; console.log(o) //2. 遍历对象 var max = 0; var ch = &#39;&#39;; for (var k in o) &#123; if (o[k] &gt; max)&#123; max = o[k]; ch = k; &#125; &#125; console.log(max); console.log(ch); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 字符串操作方法 1.concat(‘字符串1’，’字符串2’); 等效于+, +更常用 2.substr(start, length); 从start位置开始，length取的个数 3.slice(start, end); 从start位置开始，截取到end位置，end取不到 4.substring(start, end); 从start位置开始，截取到end位置，end取不到，基本和slice相同，但是不接受负值 5.替换字符 replace(‘被替换的字符’, ‘替换为的字符’); 它只会替换第一个字符 6.字符转换为数组 split(‘分隔符’); &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;title&lt;/title&gt; &lt;script&gt; var str = &#39;red&#39;; console.log(str.concat(&#39;blue&#39;)); var str1 = &#39;改革春风吹满地&#39;; console.log(str1.substr(2, 2)); //第一个2是索引号，第二个2是截取的数量 var str2 = &#39;andyandy&#39;; console.log(str2.replace(&#39;a&#39;, &#39;b&#39;)); //它只会替换第一个字母 //利用循环可以全部替换 var str3 = &#39;abcoefoxyozzopp&#39;; while (str3.indexOf(&#39;o&#39;) != -1)&#123;//替换后不断复制给自己，继续进行替换 str3 = str3.replace(&#39;o&#39;, &#39;*&#39;); &#125; console.log(str3); var str4 = &#39;red, pink, blue&#39;; //字符串转换为数组，前面有join把数组转换为字符串 console.log(str4.split(&#39;,&#39;)); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 17. 数据类型分配简单数据类型里有一个是特殊的，就是null,他是一个空对象，在当初设计的时候写错了，后来都使用了，也就这样规定了,一般初始化对象时使用 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;title&lt;/title&gt; &lt;script&gt; var num = null; console.log(typeof num); //返回的是Object &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 堆和栈 1、栈：由操作系统自动分配释放存放函数的参数值、局部变量的值等。 2、堆：存储复杂类型（对象），一般由程序员分配释放，若程序员不释放，由垃圾回收器机制回收 引用类型（复杂数据类型）：通过new关键字创建的对象，如Object、Array、Date等 引用类型变量里（栈空间）里存放的是地址，真正的对象实例存放在堆空间中","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zzygeo.cn/categories/JavaScript/"}],"tags":[]},{"title":"C++知识点","slug":"C++/C++知识点","date":"2021-05-31T03:22:15.000Z","updated":"2021-05-31T04:03:10.856Z","comments":true,"path":"2021/05/31/C++/C++知识点/","link":"","permalink":"https://zzygeo.cn/2021/05/31/C++/C++%E7%9F%A5%E8%AF%86%E7%82%B9/","excerpt":"","text":"1. cin.clear()是用来更改cin的状态标示符的。 cin.sync（）是用来清除缓存区的数据流的。如果标示符没有改变那么即使清除了数据流也无法输入。所以两个要联合起来使用。 我们定义要输入到的变量是整型,但如果我们输入了英文字母或者汉字,那就会发生错误,cin里有个方法能检测这个错误,就是cin.rdstate(); 当cin.rdstate()返回0(即ios::goodbit)时表示无错误,可以继续输入或者操作,若返回4则发生非致命错误即ios::failbit,则不能继续输入或操作.而cin.clear则可以控制我们此时cin里对这个问题的一个标识.语发如下: cin.clear(标识符); 标识符号为: goodbit 无错误Eofbit 已到达文件尾failbit 非致命的输入/输出错误，可挽回badbit 致命的输入/输出错误,无法挽回 若在输入输出类里.需要加ios::标识符号通过cin.clear,我们能确认它的内部标识符,如果输入错误则能重新输入.结合真正的清空数据流方法cin.sync(),请看下例: include &lt;iostream&gt; using namespace std; int main() &#123; int a; while(1) &#123; cin&gt;&gt;a; if(!cin) //条件可改写为cin.fail() &#123; cout&lt;&lt;&quot;输入有错!请重新输入&quot;&lt;&lt;endl; cin.clear(); cin.sync(); //清空流 &#125; else &#123; cout&lt;&lt;a; break; &#125; &#125; system(&quot;pause&quot;); &#125; 上面的cin.clear()默认参数为0,即无错误,正常操作.当我们输入英文字母’k’时,它的状态标识改为fail,即错误,用cout对用户输出信息,再用cin.clear让错误标识改回为0,让我们可以继续输入,再清空流数据继续输入.如果我们没有了cin.clear,则会进入死循环,其过程为我们输入了英文字母,它的状态标识便为fail,当运行到条件判断时,便总是回到错误的条件表示里,并且我们再也没办法输入,因为错误的表示关闭了cin,所以会进入死循环. 2. 常量指针和指针常量在第一次听黑马C++的时候，是按老师的说法自己记忆的，而在回顾C++ primer plus时，对这个的理解才更加深刻，先看两者的声明。 int sloth =3; const int* ps = &amp;sloth; // a pointer to const int int* const finger = &amp;sloth; // a const pointer to int 根据英文的理解比中文好的多， a pointer to const int 代表这个指针指向的常量是不可以改变的，但是这个指针是指向却是可以改变的。 第二个表明这个指针它是一个常量，它是没法改变的，但是他指向的值却是可以改变的，记住这个英文的注解就可以了。","categories":[{"name":"C++","slug":"C","permalink":"https://zzygeo.cn/categories/C/"}],"tags":[]},{"title":"面向对象高级部分","slug":"Java基础/面向对象高级部分","date":"2021-05-24T02:49:32.000Z","updated":"2021-05-24T04:58:03.663Z","comments":true,"path":"2021/05/24/Java基础/面向对象高级部分/","link":"","permalink":"https://zzygeo.cn/2021/05/24/Java%E5%9F%BA%E7%A1%80/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/","excerpt":"","text":"1.类变量和类方法介绍 ==类变量可以通过类名直接来访问== ==堆区 or 静态域==，需要看jdk的版本 ==不管static变量在哪里，共识（1）static变量是同一个类所有对象共享 （2）static类变量，在类加载的时候就生成了== package com.zzy.static_; public class VisitStatic &#123; public static void main(String[] args) &#123; //类变量是随着类的加载创建的,不创建对象实例也可以访问 System.out.println(A.name); &#125; &#125; class A&#123; public static String name = &quot;韩顺平教育&quot;; &#125; ==加上static称为类变量或静态变量，否则称为实例变量/普通变量/非静态变量== ==类方法也可以通过类名进行访问== 类方法的使用场景 类方法的细节 ==根据加载的时间来的，类在创建的时候，类变量和类方法就已经有了==，而普通变量和普通方法是在类实例的时候才出现 2.理解main方法语法 如果想在idea中也给args字符串数组传入字符串，需要在以下的窗口去传入 3.代码块介绍 package com.zzy.codeblock_; public class CodeBlock01 &#123; public static void main(String[] args) &#123; Movie movie1 = new Movie(&quot;你好，李焕英&quot;); &#125; &#125; class Movie&#123; private String name; private double price; private String director; //3个构造器，函数重载 //3个构造器都有相同的语句，代码看起来比较冗余 //可以将相同的语句放入代码块中,不管调用哪个构造器创建对象，都会先调用代码块的内容 //代码块调用的顺序优先于构造器 &#123; System.out.println(&quot;电影屏幕打开...&quot;); System.out.println(&quot;广告开始...&quot;); System.out.println(&quot;电影正式开始...&quot;); &#125; public Movie(String name) &#123; System.out.println(&quot;Movie(String name)构造器被调用&quot;); this.name = name; &#125; public Movie(double price, String director) &#123; this.price = price; this.director = director; &#125; public Movie(String name, double price, String director) &#123; this.name = name; this.price = price; this.director = director; &#125; &#125; 输出结果 代码块使用注意事项（1）static代码块也叫静态代码块，作用就是对类进行初始化，==而且它随着类的加载而执行，并且只会执行一次。如果是普通代码块，每创建一个对象，就执行。== （2）类什么时候被加载（重要） ==创建对象实例时（new）== ==创建子类对象实例，父类也被会加载,父类先被加载，子类后被加载== ==使用类的静态成员时（静态属性，静态方法）== 创建一个对象时，在一个类调用的顺序是： ==调用静态代码块和静态属性初始化（静态代码块和静态属性初始化调用的优先级一样，如果有多个静态代码块和多个静态变量初始化，则按他们定义的顺序调用）== ==调用普通代码块和普通属性的初始化（普通代码块和普通属性初始化调用的优先级一样，如果有多个普通代码块和多个普通属性初始化，则按定义顺序调用）== ==调用构造方法== ==构造器的最前面其实隐含了super()和调用普通代码块== 当创建一个子类对象时（继承关系），他们的静态代码块，静态属性初始化，普通代码块，普通属性初始化，构造方法的调用顺序如下： ==父类的静态代码块和静态属性（优先级一样，按定义顺序执行）== ==子类的静态代码块和静态属性（优先级一样，按定义顺序执行）== ==父类的普通代码块和普通属性初始化（优先级一样，按定义顺序执行）== ==父类的构造方法== ==子类的普通代码块和普通属性初始化（优先级一样，按定义顺序执行）== ==子类的构造方法== package com.zzy.codeblock_; public class CodeBlockDetail03 &#123; public static void main(String[] args) &#123; B b = new B(); &#125; &#125; class A&#123; public A()&#123; System.out.println(&quot;A的无参构造器调用&quot;); //6 &#125; public static int n1 = getN1(); public static int getN1()&#123; System.out.println(&quot;A的静态属性的调用&quot;); //1 return 100; &#125; static &#123; System.out.println(&quot;A类的静态代码块的调用&quot;); //2 &#125; &#123; System.out.println(&quot;A类的普通代码块调用&quot;); //5 &#125; &#125; class B extends A&#123; public B()&#123; System.out.println(&quot;B类的无参构造器&quot;); //8 &#125; public static int N2 = getN2(); public static int getN2()&#123; System.out.println(&quot;B类的静态属性调用&quot;); //3 return 200; &#125; static &#123; System.out.println(&quot;B类的静态代码块调用&quot;); //4 &#125; &#123; System.out.println(&quot;B类的普通代码块调用&quot;); //7 &#125; &#125; 4.设计模式介绍静态方法和属性的经典使用 设计模式是在大量的实践中总结和理论化之后优选的代码结构、编程风格、以及解决问题的思考方式。设计模式就像是经典的棋谱，不同的棋局，我们用不同的棋谱，免去我们自己再思考和摸索。 单例模式 1.所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能==存在一个对象实例==，并且该类==只提供一个取得其对象实例==的方法 2.单例模式有两种 1）饿汉式 2）懒汉式 饿汉式的单例模式步骤如下: 1)构造器私有化 =》防止直接new 2)类的内部创建对象 3)向外暴露一个静态的公共方法 4)代码实现 package com.zzy.Single_; public class SingleTon01 &#123; public static void main(String[] args) &#123; GirlFriend instance1 = GirlFriend.getInstance(); System.out.println(instance1); GirlFriend instance2 = GirlFriend.getInstance(); System.out.println(instance2); &#125; &#125; //只能有一个女朋友 class GirlFriend&#123; private String name; //内部创建一个私有的 private static GirlFriend girl = new GirlFriend(&quot;小红&quot;); //如何防止只能创建一个女朋友 private GirlFriend(String name)&#123; this.name = name; &#125; public static GirlFriend getInstance()&#123; return girl; &#125; @Override public String toString() &#123; return &quot;GirlFriend&#123;&quot; + &quot;name=&#39;&quot; + name + &#39;\\&#39;&#39; + &#39;&#125;&#39;; &#125; &#125; 懒汉式的单例模式1)仍然构造器私有化 2)定义一个静态属性对象 3)提供一个public的static方法，可以返回一个Cat对象 4)只有当用户使用getInstance时，才返回cat对象，后面再次调用时，会返回上次创建的cat对象 饿汉式VS懒汉式 二者最主要的区别在于创建对象的时机不同：饿汉式是在类加载就创建了对象实例，而懒汉式是在使用时（调用instance）才创建。 饿汉式不存在线程安全的问题，懒汉式存在线程安全的问题（后面学习线程后，在进行完善） 饿汉式存在浪费资源的可能。因为如果一个程序员一个对象实例都没有使用，那么饿汉式创建的对象就浪费了，懒汉式是使用时才创建，不存在这个问题。 在javaSE标准中, java.lang.Runtime就是经典的单例模式 5.final关键字介绍final可以修饰类、属性、方法和局部变量 在某些情况下，程序员可能有以下需求，就会使用到final： 1)当==不希望类被继承==时，可以用final修饰 2)当==不希望父类的某个方法被子类覆盖/重写==时，可以使用final关键字修饰。 3)当==不希望类的某个属性的值被修改==，可以用final修饰 4)当==不希望某个局部变量被修改==（比如函数里），可以使用final修饰 final的使用细节1）final修饰的属性又叫常量，一般用XX_XX_XX来命名 2）final修饰的属性==在定义时，必须赋初值==，并且==以后不能再修改==，赋值可以加在如下位置之一【选择一个位置赋初值即可】 ==定义时==，如 public final double TAX_RATE = 0.08; ==在构造器中== ==在代码块中== 3）如果==final修饰的属性是静态的==，则初始化的位置只能是 ==1. 定义时 2. 在静态代码块== 而不能在构造器中赋值(==参考类加载的先后顺序==)。 4）==final类不能继承，但是可以实例化对象== 5）如果类不是final类，但是含有final方法，则该方法虽然不可以重写，但是可以被继承。 package com.zzy.final_; public class Final01 &#123; public static void main(String[] args) &#123; //final不可以继承，但是可以实例化对象 System.out.println(Test02.num); //final方法虽然不能被重写，但是可以被继承 Test04 test04 = new Test04(); test04.say(); &#125; &#125; class Test01&#123; public final double TAX_RATE = 0.08; //1.在定义时赋值 public final double TAX_RATE1; public final double TAX_RATE2; public static final double TAX_RATE3 = 0.01; //修饰静态属性，可以在定义时赋值 public static final double TAX_RATE4; //修饰静态属性，可以在定义时赋值 public Test01()&#123;//2.在构造器中赋值 TAX_RATE1 = 0.8; &#125; static&#123; TAX_RATE4 = 0.04; //在静态代码块中可行 &#125; &#123; //3.在代码块中赋值 TAX_RATE2 = 0.1; &#125; &#125; final class Test02&#123; public static int num = 5; &#125; class Test03&#123; public final void say()&#123; System.out.println(&quot;Test03类的say方法&quot;); &#125; &#125; class Test04 extends Test03&#123; public double val = 5.0; &#125; 5）一般来说，如果==一个类已经是final类了，就没有必要再将方法修饰成final==方法。 6）==final不能修饰构造器== 7）==final和static往往搭配使用==，效率更高，不会导致类加载，底层编译器做了优化处理 8）包装类（Integer,Double，Float, Boolean等都是final），String也是final方法 package com.zzy.final_; public class Final &#123; public static void main(String[] args) &#123; //不会导致类加载 System.out.println(Test05.num); &#125; &#125; class Test05&#123; public final static int num = 5; static&#123; System.out.println(&quot;Test05的静态代码块&quot;); &#125; &#125; 6.抽象类介绍当父类的一些方法不能确定时，可以用abstract关键字来修饰该方法，这个方法就是抽象方法，用abstract来修饰该类就是抽象类 1）用abstract关键字来修饰一个类时，这个类就叫抽象类 2）用abstract关键字来修饰一个方法时，这个方法就是抽象方法 访问修饰符 abstract 返回类型 方法名(参数列表)； //没有方法体 3）==抽象类的价值更多作用是在于设计，是设计者设计好后，让子类继承并实现抽象类== 4）抽象类，是面试比较爱问的知识点，在框架和设计模式使用较多 抽象类的细节1）抽象类==不能被实例化== 2）抽象类不一定要包含abstract方法。也就是说，抽象类可以没有abstract方法 3）一旦类==包含了abstract方法，则这个类必须声明为abstract== 4）abstract==只能修饰类和方法，不能修饰属性和其他的== 5）抽象类可以由任意成员【因为抽象类还是类】，比如：非抽象方法，构造器，静态属性等 6）==抽象方法不能有主体==，即不能实现 7）如果==一个类继承了抽象类，则它必须实现抽象类的所有抽象方法==，==除非它自己也声明为abstract类==。 8）抽象方法不能使用private、final、static来修饰，因为这些关键字都是和重写违背的 package com.zzy.Animal; public class AbstractDetails &#123; public static void main(String[] args) &#123; //抽象类，不能被初始化 //new A(); &#125; &#125; abstract class A&#123;//抽象类的方法可以不抽象化 public void hi()&#123; System.out.println(&quot;hi&quot;); &#125; &#125; //一旦类包含了abstract方法，则这个类必须声明为abstract abstract class B&#123; public abstract void hi(); &#125; class C&#123; //abstract只能修饰类和方法，不能修饰其他的 //public abstract int n1 = 5; &#125; package com.zzy.Animal; public class AbstractDetails01 &#123; public static void main(String[] args) &#123; &#125; &#125; abstract class E&#123; public abstract void hi(); &#125; abstract class F extends E&#123; //除非自己也声明为abstract类 &#125; class G extends E&#123; @Override public void hi() &#123;//这里相当于重写父类E的抽象方法 System.out.println(&quot;话不投机，说你妈逼&quot;); &#125; &#125; 抽象类最佳实践-模板设计模式需求 1）有多个类，完成不同的任务job 2）要求能够得到各自完成任务的时间 感情的自然流露 先用最容易想到的方法 分析问题，提出使用模板设计模式 父类 package com.zzy.Animal; abstract public class Template &#123; public abstract void job(); public void calculateTime()&#123; long start = System.currentTimeMillis(); job(); //这里涉及到动态绑定机制 long end = System.currentTimeMillis(); System.out.println(&quot;任务运行时间为：&quot; + (end - start)); &#125; &#125; 父类AA package com.zzy.Animal; public class AA extends Template&#123; //计算任务 //从1加到10000 public void job()&#123; long num = 0; for (long i = 1; i &lt;= 800000; i++) &#123; num += i; &#125; &#125; &#125; 子类BB package com.zzy.Animal; public class BB extends Template&#123; public void job()&#123; long num = 0; for (long i = 1; i &lt;= 80000; i++) &#123; num *= i; &#125; &#125; &#125; 测试类 package com.zzy.Animal; public class TestTemplate &#123; public static void main(String[] args) &#123; AA aa = new AA(); aa.calculateTime(); BB bb = new BB(); bb.calculateTime(); &#125; &#125; 7.接口介绍 细节1）接口不能被实例化 2）接口中的所有方法是public方法，接口中抽象方法，可以不用abstract修饰 3）一个普通类实现接口，就必须将该接口的所有方法都实现 4）抽象了实现接口，可以不用实现接口的方法 5）一个类同时可以实现多个接口 6）接口中的属性，只能是final的，而且是public static final 修饰符，因此必须初始化 7）接口中属性的访问形式：接口名.属性名 8）接口不能继承其他的类，但是可以继承多个别的接口 9）接口的修饰符只能是public和默认，这一点和类的修饰符是一样的 接口和继承解决的问题不同 继承的价值主要在于：解决代码的复用性和可维护性 接口的价值主要在于：设计，设计好各种规范，让其他类去实现这些方法。即更加的灵活 接口比继承更加灵活 接口比继承更加灵活，继承是满足is -a的关系, 而接口只 需满足 like -a的关系 接口在一定程度上实现代码解耦（即：接口规范性+动态绑定机制） 接口的多态特性接口既可以接受A对象，又可以接受相机对象，就体现了接口，多态 一个接口的数组里，既可以存放A对象，也可以存放B对象，也体现了多态特性，这里还设计到向上转型和向下转型 接口存在多态传递现象 8.内部类介绍如果定义类在局部位置（方法/代码块）：（1）局部内部类 （2）匿名内部类 定义在成员位置：（1）成员内部类 （2）静态内部类 一个类的内部类又完整的嵌套了另一个类结构 。被嵌套的类称为内部类（inner class），嵌套其他类的类称为外部类（outer class）。是我们类的第五大成员，内部类的最大特点就是可以直接访问私有属性，并且可以体现类和类之间的包含关系，是学习的难点。 入门代码： package com.zzy.innerclass; public class InnerClass01 &#123;//外部其他类 public static void main(String[] args) &#123; &#125; &#125; class Outer&#123;//外部类 private int n1 = 100; public void m1()&#123; System.out.println(&quot;m1()&quot;); &#125; public Outer(int n1) &#123; this.n1 = n1; &#125; &#123; System.out.println(&quot;Outer的代码块哦&quot;); &#125; class Inner&#123; //内部类 &#125; &#125; 局部内部类的使用局部内部类是定义在外部类的局部位置，比如方法中，并且有类名 可以直接访问外部类的所有成员，包含私有的 不能添加访问修饰符，因为它的地位就是一个局部变量。局部变量是不能使用修饰符的。但是可以使用final修饰，因为局部变量也可以使用final 作用域：仅仅在定义它的方法或者代码块中 局部访问类—访问外部类的成员—可以==直接访问== 外部类—访问—局部内部类成员 访问方式：创建对象，再访问 外部其他类—不能访问—局部内部类（因为局部内部类也是一个局部变量） 如果外部类和局部内部类的成员重名，默认遵守就近原则，如果想访问外部类的成员，可以使用（外部类名.this.成员）去访问 记住： 局部内部类定义在方法中/代码块 作用域在方法体或者代码块中 本质仍然是一个类 package com.zzy.innerclass; /* 演示局部内部类 */ public class LocalInnerClass &#123; public static void main(String[] args) &#123; Outer02 outer02 = new Outer02(); outer02.m1(); System.out.println(&quot;outer02 hashcode = &quot; + outer02); &#125; &#125; class Outer02&#123; private int n1 = 100; private void m2()&#123; System.out.println(&quot;m2()&quot;); &#125; public void m1()&#123;//方法 //局部内部类是定义在外部类的局部位置，通常在方法 class Inner02&#123; //局部内部类 //可以直接访问外部内的所有成员，包含私有的 //局部内部类的作用域在定义的方法或者代码块里面 private int n1 = 800; public void f1()&#123; System.out.println(&quot;n1 = &quot; + n1 + &quot; n1 = &quot; + Outer02.this.n1); System.out.println(&quot;Outer02.this hashcode = &quot; + Outer02.this); m2(); &#125; &#125; //外部类在方法中，可以创建Inner02对象的实例，然后调用方法 Inner02 inner02 = new Inner02(); inner02.f1(); &#125; &#125; 匿名内部类（1）本质是类 （2）内部类 （3）该类没有名字（其实是类名加$） (4)同时还是一个对象 匿名内部类是定义在外部类的局部位置，比如方法中，并且没有类名 package com.zzy.innerclass; /** * 演示匿名内部类的使用 */ public class AnonymousInnerClass &#123; public static void main(String[] args) &#123; Outer04 outer04 = new Outer04(); outer04.method(); &#125; &#125; class Outer04&#123;//外部类 private int n1 = 10; public void method()&#123; //基于接口的匿名内部类 //这个基于接口的类我只使用一次就不用了,则在其他外部类去写这个类有点浪费 //可以使用匿名内部类来简化开发 //编译类型？ IA //运行类型：是系统自动分配的，但是可以用类.getclass()进行查看 //jdk底层在创建匿名内部类的时候，立马就创建了Outer$1的实例，并且把地址返回给接收new对象的对象 //匿名内部类只能使用一次，注意区别实例和匿明内部类的区别 IA tiger = new IA()&#123; @Override public void cry()&#123; System.out.println(&quot;老虎叫唤...&quot;); &#125; &#125;; System.out.println(&quot;tiger的运行类型：&quot; + tiger.getClass()); tiger.cry(); //基于类的匿名内部类 Father baba = new Father(&quot;baba&quot;)&#123; @Override public void test() &#123; System.out.println(&quot;匿名内部类重写了test方法&quot;); &#125; &#125;; System.out.println(&quot;baba的运行类型&quot; + baba.getClass()); baba.test(); &#125; &#125; interface IA&#123;//接口 public abstract void cry(); &#125; class Father&#123; public Father(String name)&#123;//构造器 &#125; public void test()&#123;//方法 System.out.println(&quot;父类的test方法&quot;); &#125; &#125; 匿名内部类的使用细节 匿名内部类的语法比较奇特，它既是一个类的定义，同时本身也是一个对象，从语法上，它既有定义类的特征，也有创建对象的特征 可以直接访问外部类的所有成员，包含私有的 不能添加访问修饰符，因为它的地位就是一个局部变量 作用域：仅仅定义在它的方法或者代码块中 匿名内部类—访问—&gt;外部类成员【直接访问】 外部其他类—不能访问—&gt;匿名内部类【因为匿名内部类地位是一个局部变量】 如果外部类和匿名内部类的成员重名时，匿名内部类访问的话，遵循就近一致原则，如果想访问外部类的成员，可以使用（外部类名.this.成员）去访问 package com.zzy.innerclass; public class AnonymousInnerClassDetails &#123; public static void main(String[] args) &#123; Outer05 outer05 = new Outer05(); outer05.f1(); &#125; &#125; class Outer05&#123; private int n1 = 99; public void f1()&#123; //创建一个基于类的匿名内部类 Person person = new Person()&#123;//编译类型Person,运行类型是匿名对象 @Override public void hi()&#123; System.out.println(&quot;匿名内部类重写了 hi方法&quot;); &#125; &#125;; person.hi(); new Person()&#123;//编译类型Person,运行类型是匿名对象 @Override public void hi()&#123; System.out.println(&quot;匿名内部类重写了 hi方法&quot;); &#125; @Override public void ok(String name) &#123; super.ok(name); &#125; &#125;.ok(&quot;小周&quot;); &#125; &#125; class Person&#123; public void hi()&#123; System.out.println(&quot;Person hi()&quot;); &#125; public void ok(String name)&#123; System.out.println(&quot;name = &quot; + name); &#125; &#125; 匿名内部类的最佳实践当做实参直接传递，简洁高效 package com.zzy.innerclass; public class InnerClassExercise01 &#123; public static void main(String[] args) &#123; f1(new AA() &#123;//当做实参直接传递，简洁高效 @Override public void show() &#123; System.out.println(&quot;匿名内部类&quot;); &#125; &#125;); &#125; //静态方法,形参是接口类型 public static void f1(AA aa)&#123; aa.show(); &#125; &#125; interface AA&#123; public abstract void show(); &#125; package com.zzy.innerclass; public class InnerClassExercise02 &#123; public static void main(String[] args) &#123; alarmclock(new Bell() &#123;//匿名内部类作为实参 @Override public void ring() &#123; System.out.println(&quot;懒猪起床了&quot;); &#125; &#125;); alarmclock(new Bell() &#123; @Override public void ring() &#123; System.out.println(&quot;小伙伴上课了&quot;); &#125; &#125;); &#125; public static void alarmclock(Bell bell)&#123; bell.ring(); &#125; &#125; interface Bell&#123; public abstract void ring(); &#125;","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://zzygeo.cn/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"IDEA快捷键","slug":"Java基础/IDEA快捷键","date":"2021-05-24T02:48:12.000Z","updated":"2021-06-07T14:07:58.361Z","comments":true,"path":"2021/05/24/Java基础/IDEA快捷键/","link":"","permalink":"https://zzygeo.cn/2021/05/24/Java%E5%9F%BA%E7%A1%80/IDEA%E5%BF%AB%E6%8D%B7%E9%94%AE/","excerpt":"","text":"查看类的结构：ctrl+f12 查看类的继承图：ctrl+alt+shift+u 查看函数参数：ctrl+p 查看函数介绍：ctrl+q 格式化代码：ctrl+shift+l 代码补全：alt+/ 提示关键字：alt+shift+/ 万能结错/生成返回值变量：alt+enter 查看继承结构：ctrl+h 反撤销：ctrl+shift+z 大小写转换：ctrl+shift+u 收起所有的方法：ctrl+shift+- 打开所有的方法：ctrl+shfit++ 重命名：shift+f6 打开文件所在位置：ctrl+shift+x 生成try-catch等：ctrl+alt+t 局部变量抽取为成员变量：ctrl+alt+f 添加到收藏夹：alt+shift+f 搜索类中的错误：f2 复制选取：ctrl+shift+v 显示方法在哪调用过：ctrl+shift+h 快写构造函数：alt+insert","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://zzygeo.cn/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"dpkg被中断的解决办法","slug":"Ubuntu/dpkg被中断的解决办法","date":"2021-03-13T17:40:02.000Z","updated":"2021-05-24T00:57:48.469Z","comments":true,"path":"2021/03/14/Ubuntu/dpkg被中断的解决办法/","link":"","permalink":"https://zzygeo.cn/2021/03/14/Ubuntu/dpkg%E8%A2%AB%E4%B8%AD%E6%96%AD%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/","excerpt":"linux系统安装软件是有时会碰到“dpkg 被中断,您必须手工运行 sudo dpkg –configure -a解决此问题”，然而按照提示运行却并没能很好的解决问题。其实导致这个问题的主要原因是因为/var/lib/dpkg/updates文件下的文件有问题，可能是其他软件安装过程或是其他原因导致的，这里删除掉然后重建即可。","text":"linux系统安装软件是有时会碰到“dpkg 被中断,您必须手工运行 sudo dpkg –configure -a解决此问题”，然而按照提示运行却并没能很好的解决问题。其实导致这个问题的主要原因是因为/var/lib/dpkg/updates文件下的文件有问题，可能是其他软件安装过程或是其他原因导致的，这里删除掉然后重建即可。 sudo rm /var/lib/dpkg/updates/* sudo apt-get update sudo apt-get upgrade 解释：[]sudo apt-get update指令会重新建立这些资料，所以不必担心删除后会出问题；[]sudo apt-get upgrade会更新你的电脑里面已安装的软件的明细，根据软件的明细更新软件到最新版。PS：“dpkg ”是“Debian Packager ”的简写。为 “Debian” 专门开发的套件管理系统，方便软件的安装、更新及移除。所有源自“Debian”的“Linux ”发行版都使用 “dpkg” 参考博客","categories":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://zzygeo.cn/categories/Ubuntu/"}],"tags":[]},{"title":"安装snap以及常用命令","slug":"Ubuntu/安装snap","date":"2021-03-13T17:35:25.000Z","updated":"2021-05-24T00:58:39.914Z","comments":true,"path":"2021/03/14/Ubuntu/安装snap/","link":"","permalink":"https://zzygeo.cn/2021/03/14/Ubuntu/%E5%AE%89%E8%A3%85snap/","excerpt":"1.安装snap","text":"1.安装snap sudo apt-get install snapd sudo apt-get install snapcraft 2.常用命令//列出已经安装的snap包 sudo snap list //搜索要安装的snap包 sudo snap find &lt;text to search&gt; //安装一个snap包 sudo snap install &lt;snap name&gt; //更新一个snap包，如果你后面不加包的名字的话那就是更新所有的snap包 sudo snap refresh &lt;snap name&gt; //把一个包还原到以前安装的版本 sudo snap revert &lt;snap name&gt; //删除一个snap包 sudo snap remove &lt;snap name&gt;","categories":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://zzygeo.cn/categories/Ubuntu/"}],"tags":[]},{"title":"ubuntu配置C/C++开发环境","slug":"Ubuntu/ubuntu配置C-C-开发环境","date":"2021-03-13T17:31:07.000Z","updated":"2021-05-24T00:58:14.532Z","comments":true,"path":"2021/03/14/Ubuntu/ubuntu配置C-C-开发环境/","link":"","permalink":"https://zzygeo.cn/2021/03/14/Ubuntu/ubuntu%E9%85%8D%E7%BD%AEC-C-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/","excerpt":"1.在代码文件夹下建立两个文件launch.json 以及 tasks.json","text":"1.在代码文件夹下建立两个文件launch.json 以及 tasks.json 2.给这个两个文件配置文件launch.json: &#123; // Use IntelliSense to learn about possible attributes. // Hover to view descriptions of existing attributes. // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387 &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ &#123; &quot;name&quot;: &quot;(gdb) Launch&quot;, &quot;type&quot;: &quot;cppdbg&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;program&quot;: &quot;$&#123;workspaceFolder&#125;/$&#123;fileBasenameNoExtension&#125;.out&quot;, &quot;args&quot;: [], &quot;stopAtEntry&quot;: false, &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;&quot;, &quot;environment&quot;: [], &quot;externalConsole&quot;: true, //如果不要窗口弹出，在ide中显示，就设置成 false &quot;MIMode&quot;: &quot;gdb&quot;, &quot;preLaunchTask&quot;: &quot;build&quot;, //表示预先生成一个中间文件，用于g++运行 &quot;setupCommands&quot;: [ &#123; &quot;description&quot;: &quot;Enable pretty-printing for gdb&quot;, &quot;text&quot;: &quot;-enable-pretty-printing&quot;, &quot;ignoreFailures&quot;: true &#125; ] &#125; ] &#125; tasks.json: &#123; // See https://go.microsoft.com/fwlink/?LinkId=733558 // for the documentation about the tasks.json format &quot;version&quot;: &quot;2.0.0&quot;, &quot;tasks&quot;: [ &#123; &quot;label&quot;: &quot;build&quot;, &quot;type&quot;: &quot;shell&quot;, &quot;command&quot;: &quot;g++&quot;, &quot;args&quot;: [&quot;-g&quot;, &quot;$&#123;file&#125;&quot;, &quot;-std=c++11&quot;, &quot;-o&quot;, &quot;$&#123;fileBasenameNoExtension&#125;.out&quot;] //相当于 g++ -g main.cpp -std=c++11 -o main.out &#125; ] &#125; 参考博客","categories":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://zzygeo.cn/categories/Ubuntu/"}],"tags":[]},{"title":"ubuntu安装gcc依赖关系报错","slug":"Ubuntu/ubuntu安装gcc依赖关系报错","date":"2021-03-13T17:26:01.000Z","updated":"2021-05-24T00:57:56.428Z","comments":true,"path":"2021/03/14/Ubuntu/ubuntu安装gcc依赖关系报错/","link":"","permalink":"https://zzygeo.cn/2021/03/14/Ubuntu/ubuntu%E5%AE%89%E8%A3%85gcc%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB%E6%8A%A5%E9%94%99/","excerpt":"使用aptitude包依赖管理工具替代apt处理，看其他的博客说这个得慎用，不过用来安装gcc倒是没啥问题。","text":"使用aptitude包依赖管理工具替代apt处理，看其他的博客说这个得慎用，不过用来安装gcc倒是没啥问题。 sudo apt-get install aptitude sudo aptitude install gcc g++ 解决方案里选择no,yes,yes.参考博客","categories":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://zzygeo.cn/categories/Ubuntu/"}],"tags":[]},{"title":"ubuntu安装vim依赖关系报错","slug":"Ubuntu/ubuntu安装vim依赖关系报错","date":"2021-03-13T17:22:16.000Z","updated":"2021-05-24T00:58:01.518Z","comments":true,"path":"2021/03/14/Ubuntu/ubuntu安装vim依赖关系报错/","link":"","permalink":"https://zzygeo.cn/2021/03/14/Ubuntu/ubuntu%E5%AE%89%E8%A3%85vim%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB%E6%8A%A5%E9%94%99/","excerpt":"按如下步骤进行就可：","text":"按如下步骤进行就可： sudo apt-get purge vim-common sudo apt-get update sudo apt-get upgrade sudo apt-get install vim","categories":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://zzygeo.cn/categories/Ubuntu/"}],"tags":[]},{"title":"ubuntu下的firefox无法播放视频解决方案","slug":"Ubuntu/ubuntu下的firefox无法播放视频解决方案","date":"2021-03-13T17:09:31.000Z","updated":"2021-05-24T00:58:20.789Z","comments":true,"path":"2021/03/14/Ubuntu/ubuntu下的firefox无法播放视频解决方案/","link":"","permalink":"https://zzygeo.cn/2021/03/14/Ubuntu/ubuntu%E4%B8%8B%E7%9A%84firefox%E6%97%A0%E6%B3%95%E6%92%AD%E6%94%BE%E8%A7%86%E9%A2%91%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","excerpt":"1.下载flash的tar.gz文件直接去官网链接下载","text":"1.下载flash的tar.gz文件直接去官网链接下载 2.解压tar.gz文件tar -zxvf filename.tar.gz 注意filename.tar.gz就是你下载的文件的名字，可以直接复制下载包名字。 3.移动解压文件夹先进入安装包目录下,然后 sudo cp libflashplayer.so /usr/lib/firefox/browser/plugins sudo cp -r usr/* /usr 4.缺少依赖报错解决sudo apt-get install ffmpeg //ffmpeg支持H.264解码","categories":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://zzygeo.cn/categories/Ubuntu/"}],"tags":[]},{"title":"ubuntu下解决wps2019缺少字体问题","slug":"Ubuntu/ubuntu下解决wps2019缺少字体问题","date":"2021-03-13T16:56:33.000Z","updated":"2021-05-24T00:58:26.096Z","comments":true,"path":"2021/03/14/Ubuntu/ubuntu下解决wps2019缺少字体问题/","link":"","permalink":"https://zzygeo.cn/2021/03/14/Ubuntu/ubuntu%E4%B8%8B%E8%A7%A3%E5%86%B3wps2019%E7%BC%BA%E5%B0%91%E5%AD%97%E4%BD%93%E9%97%AE%E9%A2%98/","excerpt":"主要参考博客","text":"主要参考博客 1.准备字体包下载链接 2.解压到指定目录下sudo unzip wps_symbol_fonts.zip -d /home/&lt;user&gt;/usr/share/fonts 3.到解压的根目录下安装依次打开每个文件并点击安装即可","categories":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://zzygeo.cn/categories/Ubuntu/"}],"tags":[]},{"title":"Ubuntu更换源教程","slug":"Ubuntu/Ubuntu更换源教程","date":"2021-03-13T16:34:31.000Z","updated":"2021-05-24T00:58:08.039Z","comments":true,"path":"2021/03/14/Ubuntu/Ubuntu更换源教程/","link":"","permalink":"https://zzygeo.cn/2021/03/14/Ubuntu/Ubuntu%E6%9B%B4%E6%8D%A2%E6%BA%90%E6%95%99%E7%A8%8B/","excerpt":"参考博客","text":"参考博客 1.备份源列表sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak 2.打开sources.list文件sudo gedit /etc/apt/sources.list 3.修改sources.list文件# 阿里镜像源 deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse 4.更新并升级sudo apt-get update &amp;&amp; sudo apt-get upgrade 5.恢复源列表sudo cp /etc/apt/sources.list.bak /etc/apt/sources.list 其他的源请自己搜索，这里只放了阿里云的。","categories":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://zzygeo.cn/categories/Ubuntu/"}],"tags":[]},{"title":"github设置自己的域名","slug":"Hexo/github设置自己的域名","date":"2021-01-20T08:30:55.000Z","updated":"2021-05-24T00:59:47.893Z","comments":true,"path":"2021/01/20/Hexo/github设置自己的域名/","link":"","permalink":"https://zzygeo.cn/2021/01/20/Hexo/github%E8%AE%BE%E7%BD%AE%E8%87%AA%E5%B7%B1%E7%9A%84%E5%9F%9F%E5%90%8D/","excerpt":"哈哈，上次整了一晚上的没整明白，今天两下就整好了，看来真的进步不错哈哈，至少看东西，解决问题更有耐心也更能看懂了。","text":"哈哈，上次整了一晚上的没整明白，今天两下就整好了，看来真的进步不错哈哈，至少看东西，解决问题更有耐心也更能看懂了。 1.购买域名我是买的阿里云的域名，如下图：域名解析如下： 2.github仓库设置域名地址在blog目录下的source文件下，创一个叫CNAME的无后缀文件，里面填入你的域名，比如我的 zzygeo.cn 如下图：如下图，主要是要设置博客上传分支的目录，以及更改你自己的域名（创建CNAME后自动生成），采用https加密。 到此就设置完成了！","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://zzygeo.cn/categories/Hexo/"}],"tags":[]},{"title":"pcl+vs+cmake编译","slug":"PCL/pcl-vs-cmake编译","date":"2020-12-27T14:50:27.000Z","updated":"2021-05-24T00:59:31.373Z","comments":true,"path":"2020/12/27/PCL/pcl-vs-cmake编译/","link":"","permalink":"https://zzygeo.cn/2020/12/27/PCL/pcl-vs-cmake%E7%BC%96%E8%AF%91/","excerpt":"上一篇写的配置可能是最基础的，也是很麻烦，其实可以用cmake来偷个懒，这样就不用附加依赖性已经加入库目录和包含目录了。","text":"上一篇写的配置可能是最基础的，也是很麻烦，其实可以用cmake来偷个懒，这样就不用附加依赖性已经加入库目录和包含目录了。 1.软件准备1.All in one 安装包。 2.获取All in one 包对应得PDB文件包，用于后期单步调试。 3.安装Visual studio 2019编译器 4.cmake 其实源码包用不上，懒得改了，最复杂的方式就是源代码加第三方库进行配置，等我配置好了也会再一篇关于源码方式的配置。 2.链接pcl下载地址visual studio下载地址cmake下载地址 3.安装事项为了方便配置，pcl安装目录尽量默认，不默认后续添加目录需要选择对应的位置。 pcl安装请一定选择创建系统路径，visual studio和cmake安装位置随意，其他选项默认即可。 pcl安装完成后，请把下载的pcd文件解压，如下图： 将所有文件复制，安装到pcl下的BIN文件下 检查pcl安装目录下的 3rdParty-OpenNI2是否只有一个安装包（我的是这样），这可能是事先安装过SDK的原因，请卸载了重新安装在OpenNI2下，安装完成如下图： cmake 安装请选择添加到系统路径，没选的话也可以自己手动添加，添加的方式为cmake目录下bin文件 比如C:\\APP\\Cmake\\bin这样的形式。 4.关于Visual studio安装项目我安装了这些负载 5.环境配置右键我的电脑——高级系统设置-环境变量，在path选项下新建如下几项，根据你pcl安装的位置来： 比如我的：C:\\Program Files\\PCL 1.11.0\\binC:\\Program Files\\PCL 1.11.0\\3rdParty\\FLANN\\binC:\\Program Files\\PCL 1.11.0\\3rdParty\\Qhull\\binC:\\Program Files\\PCL 1.11.0\\3rdParty\\VTK\\binC:\\Program Files\\PCL 1.11.0\\3rdParty\\OpenNI2\\ToolsC:\\Program Files\\PCL 1.11.0\\3rdParty\\OpenNI2\\Redist 在系统变量下，配置如下图：比如我的：C:\\Program Files\\PCL 1.11.0\\3rdParty\\FLANN\\binC:\\Program Files\\PCL 1.11.0\\3rdParty\\OpenNI2\\ToolsC:\\Program Files\\PCL 1.11.0\\3rdParty\\Qhull\\binC:\\Program Files\\PCL 1.11.0\\3rdParty\\VTK\\binC:\\Program Files\\PCL 1.11.0\\bin 6.cmake编译以管理员身份运行cmake-gui在你想要的文件下创建一个名为example的文件夹，然后在此目录下创建一个source和cmake_bin文件，比如我的： 在source里面创建一个cpp文件和CMakeLists.txt文件。CmakeLists.txt里写入以下内容： cmake_minimum_required(VERSION 2.6 FATAL_ERROR) project(test) find_package(PCL 1.4 REQUIRED) include_directories($&#123;PCL_INCLUDE_DIRS&#125;) link_directories($&#123;PCL_LIBRARY_DIRS&#125;) add_definitions($&#123;PCL_DEFINITIONS&#125;) add_executable (test test.cpp) target_link_libraries (test $&#123;PCL_LIBRARIES&#125;) 其中这个test就是你创建的测试代码的名字，请保持一致，如果你换别的名字，请把txt文件的名字也一起改了。我的如下： 测试代码请网上去找，我用的是上一篇文件里的（里面有个D盘文件的读取可能会报错，但只要能出彩色的那个图就算配置成功了）。 跟着步骤添加 点击Configure，选x64 再点击一次configure 点击Generate,出现Generating done. 找到cmake_bin底下的test_sln 打开。 将test设置为启动项，并调试。","categories":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://zzygeo.cn/categories/Ubuntu/"}],"tags":[]},{"title":"Unable to access 'https://gitee.com/自己的项目/': Could not resolve host: gitee.com问题的解决","slug":"Ubuntu/Unable-to-access-https-gitee-com-自己的项目-Could-not-resolve-host-gitee-com问题的解决","date":"2020-10-22T17:28:36.000Z","updated":"2021-05-24T00:58:33.166Z","comments":true,"path":"2020/10/23/Ubuntu/Unable-to-access-https-gitee-com-自己的项目-Could-not-resolve-host-gitee-com问题的解决/","link":"","permalink":"https://zzygeo.cn/2020/10/23/Ubuntu/Unable-to-access-https-gitee-com-%E8%87%AA%E5%B7%B1%E7%9A%84%E9%A1%B9%E7%9B%AE-Could-not-resolve-host-gitee-com%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3/","excerpt":"果然玩hexo报错是在所难免，就好像我已经长大，读研以后乃至以后得日子，可能总是繁琐常伴。今天在hexo d推到GITEE上时，报了错。","text":"果然玩hexo报错是在所难免，就好像我已经长大，读研以后乃至以后得日子，可能总是繁琐常伴。今天在hexo d推到GITEE上时，报了错。原因是由于爬梯子代理网络的问题，其实折腾了下。具体哪个步骤解决了这个问题，我也不是很清楚，这次做好记录方便以后继续更新把。 首先我是从这篇博客里查到了我的ip，然后ping了查到的ip，然后在system32\\drives\\etc\\hosts里添加了 IP gitee.com 然而这并没有继续运行成功。然后我有尝试1.管理员身份运行cmd2.输入 netsh winsock reset 3.重启 还有尝试命令行输入 git config --global --unset http.proxy git config --global --unset https.proxy 最后发现还是不行，结果我把第一步添加的IP gitee.com删了居然好了。 所以我觉得问题在以下原因，第一个是我没有在打开代理下hexo d,平时确实是没有注意这个问题，但关闭代理下好像有时候也成功过，但这个问题确实出在了代理的问题上。另外就是我的代理导致了无法上传上去，上述的两个操作我也不知道哪个解决了这个问题，毕竟我先添加了IP，然后再试了这两种清楚的。如果下次再出现这个问题，有了结果再继续补充。 2020/11/17他妈个头的，翻墙今天又部署不上去了，前面的用了也不好使，又试了一下这个更改DNS的方法成功了，链接在这","categories":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://zzygeo.cn/categories/Ubuntu/"}],"tags":[]},{"title":"资源","slug":"其他/资源","date":"2020-10-04T06:53:31.000Z","updated":"2021-05-24T01:35:25.910Z","comments":true,"path":"2020/10/04/其他/资源/","link":"","permalink":"https://zzygeo.cn/2020/10/04/%E5%85%B6%E4%BB%96/%E8%B5%84%E6%BA%90/","excerpt":"准备把一些资源都放在这个博客下，持续更新，有需要得自取。 1.Linux学习笔记链接","text":"准备把一些资源都放在这个博客下，持续更新，有需要得自取。 1.Linux学习笔记链接 2.cloud compare中文版使用手册链接 3.深度学习吴恩达深度学习课程 吴恩达课程配套科目 吴恩达深度学习笔记 4.壁纸地址 5.1080p下载下载地址 6.视频字幕下载下载地址版权限制，目前下载为VTT格式，需要在Subtitle Edit里将VTT转为SRT格式。 7.Subtitle Edit(vvt-srt)下载地址可以VTT2SRT SRT2VTT,有强大的字幕编辑功能。 8.Arctime(制作内嵌字幕视频)下载地址","categories":[{"name":"资源","slug":"资源","permalink":"https://zzygeo.cn/categories/%E8%B5%84%E6%BA%90/"}],"tags":[]},{"title":"PCL-1-11-Visual-Studio-2019-配置","slug":"PCL/PCL-1-11-Visual-Studio-2019-配置","date":"2020-10-04T04:22:26.000Z","updated":"2021-05-24T00:59:10.142Z","comments":true,"path":"2020/10/04/PCL/PCL-1-11-Visual-Studio-2019-配置/","link":"","permalink":"https://zzygeo.cn/2020/10/04/PCL/PCL-1-11-Visual-Studio-2019-%E9%85%8D%E7%BD%AE/","excerpt":"1.软件准备1.All in one 安装包。 2.获取All in one 包对应得PDB文件包，用于后期单步调试。","text":"1.软件准备1.All in one 安装包。 2.获取All in one 包对应得PDB文件包，用于后期单步调试。3.获取PCL源码包 4.安装Visual studio 2019编译器 2.链接pcl下载地址visual studio下载地址 3.安装事项为了方便配置，pcl安装目录尽量默认，不默认后续添加目录需要选择对应的位置。 pcl安装请一定选择创建系统路径，visual studio和cmake安装位置随意，其他选项默认即可。 pcl安装完成后，请把下载的pcd文件解压，如下图： 将所有文件复制，安装到pcl下的BIN文件下 检查pcl安装目录下的 3rdParty-OpenNI2是否只有一个安装包（我的是这样），这可能是事先安装过SDK的原因，请卸载了重新安装在OpenNI2下，安装完成如下图： 4.关于Visual studio安装项目我安装了这些负载 5.环境配置右键我的电脑——高级系统设置-环境变量，在path选项下新建如下几项，根据你pcl安装的位置来： 比如我的：C:\\Program Files\\PCL 1.11.0\\binC:\\Program Files\\PCL 1.11.0\\3rdParty\\FLANN\\binC:\\Program Files\\PCL 1.11.0\\3rdParty\\Qhull\\binC:\\Program Files\\PCL 1.11.0\\3rdParty\\VTK\\binC:\\Program Files\\PCL 1.11.0\\3rdParty\\OpenNI2\\ToolsC:\\Program Files\\PCL 1.11.0\\3rdParty\\OpenNI2\\Redist 在系统变量下，配置如下图：比如我的：C:\\Program Files\\PCL 1.11.0\\3rdParty\\FLANN\\binC:\\Program Files\\PCL 1.11.0\\3rdParty\\OpenNI2\\ToolsC:\\Program Files\\PCL 1.11.0\\3rdParty\\Qhull\\binC:\\Program Files\\PCL 1.11.0\\3rdParty\\VTK\\binC:\\Program Files\\PCL 1.11.0\\bin 6.配置打开visual studio，新建一个空项目如图： 在release下创建属性表（如果是DEBUG版本请在DEBUG下创建） 切换到解决方案资源管理器，右键-添加-新建项 添加C++文件 接下来配置： 包含目录下添加，建议手点：C:\\Program Files\\PCL 1.11.0\\include\\pcl-1.11C:\\Program Files\\PCL 1.11.0\\3rdParty\\Boost\\include\\boost-1_73C:\\Program Files\\PCL 1.11.0\\3rdParty\\Eigen\\eigen3C:\\Program Files\\PCL 1.11.0\\3rdParty\\FLANN\\includeC:\\Program Files\\PCL 1.11.0\\3rdParty\\Qhull\\includeC:\\Program Files\\PCL 1.11.0\\3rdParty\\VTK\\include\\vtk-8.2C:\\Program Files\\PCL 1.11.0\\3rdParty\\OpenNI2\\Include 库目录添加：C:\\Program Files\\PCL 1.11.0\\libC:\\Program Files\\PCL 1.11.0\\3rdParty\\Boost\\libC:\\Program Files\\PCL 1.11.0\\3rdParty\\FLANN\\libC:\\Program Files\\PCL 1.11.0\\3rdParty\\Qhull\\libC:\\Program Files\\PCL 1.11.0\\3rdParty\\VTK\\libC:\\Program Files\\PCL 1.11.0\\3rdParty\\OpenNI2\\Lib 接下来配置： 在预处理器定义处添加：BOOST_USE_WINDOWS_HNOMINMAX_CRT_SECURE_NO_DEPRECATE 在项目属性表（Project_one）和release下创建得属性表（test_one）中把所有选项里得SDL检查全改成否，如下图： 7.附加依赖项将PCL 1.11.0\\3rdParty\\VTK\\lib和PCL 1.11.0\\lib这两个文件夹下的lib文件的release版本添加到附加依赖项中（DEBUG版本添加DEBUG类型文件） 文件名称我已经归类好了 release版本： pcl_common.libpcl_features.libpcl_filters.libpcl_io.libpcl_io_ply.libpcl_kdtree.libpcl_keypoints.libpcl_ml.libpcl_octree.libpcl_outofcore.libpcl_people.libpcl_recognition.libpcl_registration.libpcl_sample_consensus.libpcl_search.libpcl_segmentation.libpcl_stereo.libpcl_surface.libpcl_tracking.libpcl_visualization.libvtkChartsCore-8.2.libvtkCommonColor-8.2.libvtkCommonComputationalGeometry-8.2.libvtkCommonCore-8.2.libvtkCommonDataModel-8.2.libvtkCommonExecutionModel-8.2.libvtkCommonMath-8.2.libvtkCommonMisc-8.2.libvtkCommonSystem-8.2.libvtkCommonTransforms-8.2.libvtkDICOMParser-8.2.libvtkDomainsChemistry-8.2.libvtkDomainsChemistryOpenGL2-8.2.libvtkdoubleconversion-8.2.libvtkexodusII-8.2.libvtkexpat-8.2.libvtkFiltersAMR-8.2.libvtkFiltersCore-8.2.libvtkFiltersExtraction-8.2.libvtkFiltersFlowPaths-8.2.libvtkFiltersGeneral-8.2.libvtkFiltersGeneric-8.2.libvtkFiltersGeometry-8.2.libvtkFiltersHybrid-8.2.libvtkFiltersHyperTree-8.2.libvtkFiltersImaging-8.2.libvtkFiltersModeling-8.2.libvtkFiltersParallel-8.2.libvtkFiltersParallelImaging-8.2.libvtkFiltersPoints-8.2.libvtkFiltersProgrammable-8.2.libvtkFiltersSelection-8.2.libvtkFiltersSMP-8.2.libvtkFiltersSources-8.2.libvtkFiltersStatistics-8.2.libvtkFiltersTexture-8.2.libvtkFiltersTopology-8.2.libvtkFiltersVerdict-8.2.libvtkfreetype-8.2.libvtkGeovisCore-8.2.libvtkgl2ps-8.2.libvtkglew-8.2.libvtkGUISupportMFC-8.2.libvtkhdf5_hl-8.2.libvtkhdf5-8.2.libvtkImagingColor-8.2.libvtkImagingCore-8.2.libvtkImagingFourier-8.2.libvtkImagingGeneral-8.2.libvtkImagingHybrid-8.2.libvtkImagingMath-8.2.libvtkImagingMorphological-8.2.libvtkImagingSources-8.2.libvtkImagingStatistics-8.2.libvtkImagingStencil-8.2.libvtkInfovisCore-8.2.libvtkInfovisLayout-8.2.libvtkInteractionImage-8.2.libvtkInteractionStyle-8.2.libvtkInteractionWidgets-8.2.libvtkIOAMR-8.2.libvtkIOAsynchronous-8.2.libvtkIOCityGML-8.2.libvtkIOCore-8.2.libvtkIOEnSight-8.2.libvtkIOExodus-8.2.libvtkIOExport-8.2.libvtkIOExportOpenGL2-8.2.libvtkIOExportPDF-8.2.libvtkIOGeometry-8.2.libvtkIOImage-8.2.libvtkIOImport-8.2.libvtkIOInfovis-8.2.libvtkIOLegacy-8.2.libvtkIOLSDyna-8.2.libvtkIOMINC-8.2.libvtkIOMovie-8.2.libvtkIONetCDF-8.2.libvtkIOParallel-8.2.libvtkIOParallelXML-8.2.libvtkIOPLY-8.2.libvtkIOSegY-8.2.libvtkIOSQL-8.2.libvtkIOTecplotTable-8.2.libvtkIOVeraOut-8.2.libvtkIOVideo-8.2.libvtkIOXML-8.2.libvtkIOXMLParser-8.2.libvtkjpeg-8.2.libvtkjsoncpp-8.2.libvtklibharu-8.2.libvtklibxml2-8.2.libvtklz4-8.2.libvtklzma-8.2.libvtkmetaio-8.2.libvtkNetCDF-8.2.libvtkogg-8.2.libvtkParallelCore-8.2.libvtkpng-8.2.libvtkproj-8.2.libvtkpugixml-8.2.libvtkRenderingAnnotation-8.2.libvtkRenderingContext2D-8.2.libvtkRenderingContextOpenGL2-8.2.libvtkRenderingCore-8.2.libvtkRenderingExternal-8.2.libvtkRenderingFreeType-8.2.libvtkRenderingGL2PSOpenGL2-8.2.libvtkRenderingImage-8.2.libvtkRenderingLabel-8.2.libvtkRenderingLOD-8.2.libvtkRenderingOpenGL2-8.2.libvtkRenderingVolume-8.2.libvtkRenderingVolumeOpenGL2-8.2.libvtksqlite-8.2.libvtksys-8.2.libvtktheora-8.2.libvtktiff-8.2.libvtkverdict-8.2.libvtkViewsContext2D-8.2.libvtkViewsCore-8.2.libvtkViewsInfovis-8.2.libvtkzlib-8.2.lib DEBUG版本： pcl_commond.libpcl_featuresd.libpcl_filtersd.libpcl_io_plyd.libpcl_iod.libpcl_kdtreed.libpcl_keypointsd.libpcl_mld.libpcl_octreed.libpcl_outofcored.libpcl_peopled.libpcl_recognitiond.libpcl_registrationd.libpcl_sample_consensusd.libpcl_searchd.libpcl_segmentationd.libpcl_stereod.libpcl_surfaced.libpcl_trackingd.libpcl_visualizationd.libvtkChartsCore-8.2-gd.libvtkCommonColor-8.2-gd.libvtkCommonComputationalGeometry-8.2-gd.libvtkCommonCore-8.2-gd.libvtkCommonDataModel-8.2-gd.libvtkCommonExecutionModel-8.2-gd.libvtkCommonMath-8.2-gd.libvtkCommonMisc-8.2-gd.libvtkCommonSystem-8.2-gd.libvtkCommonTransforms-8.2-gd.libvtkDICOMParser-8.2-gd.libvtkDomainsChemistry-8.2-gd.libvtkDomainsChemistryOpenGL2-8.2-gd.libvtkdoubleconversion-8.2-gd.libvtkexodusII-8.2-gd.libvtkexpat-8.2-gd.libvtkFiltersAMR-8.2-gd.libvtkFiltersCore-8.2-gd.libvtkFiltersExtraction-8.2-gd.libvtkFiltersFlowPaths-8.2-gd.libvtkFiltersGeneral-8.2-gd.libvtkFiltersGeneric-8.2-gd.libvtkFiltersGeometry-8.2-gd.libvtkFiltersHybrid-8.2-gd.libvtkFiltersHyperTree-8.2-gd.libvtkFiltersImaging-8.2-gd.libvtkFiltersModeling-8.2-gd.libvtkFiltersParallel-8.2-gd.libvtkFiltersParallelImaging-8.2-gd.libvtkFiltersPoints-8.2-gd.libvtkFiltersProgrammable-8.2-gd.libvtkFiltersSelection-8.2-gd.libvtkFiltersSMP-8.2-gd.libvtkFiltersSources-8.2-gd.libvtkFiltersStatistics-8.2-gd.libvtkFiltersTexture-8.2-gd.libvtkFiltersTopology-8.2-gd.libvtkFiltersVerdict-8.2-gd.libvtkfreetype-8.2-gd.libvtkGeovisCore-8.2-gd.libvtkgl2ps-8.2-gd.libvtkglew-8.2-gd.libvtkGUISupportMFC-8.2-gd.libvtkhdf5_hl-8.2-gd.libvtkhdf5-8.2-gd.libvtkImagingColor-8.2-gd.libvtkImagingCore-8.2-gd.libvtkImagingFourier-8.2-gd.libvtkImagingGeneral-8.2-gd.libvtkImagingHybrid-8.2-gd.libvtkImagingMath-8.2-gd.libvtkImagingMorphological-8.2-gd.libvtkImagingSources-8.2-gd.libvtkImagingStatistics-8.2-gd.libvtkImagingStencil-8.2-gd.libvtkInfovisCore-8.2-gd.libvtkInfovisLayout-8.2-gd.libvtkInteractionImage-8.2-gd.libvtkInteractionStyle-8.2-gd.libvtkInteractionWidgets-8.2-gd.libvtkIOAMR-8.2-gd.libvtkIOAsynchronous-8.2-gd.libvtkIOCityGML-8.2-gd.libvtkIOCore-8.2-gd.libvtkIOEnSight-8.2-gd.libvtkIOExodus-8.2-gd.libvtkIOExport-8.2-gd.libvtkIOExportOpenGL2-8.2-gd.libvtkIOExportPDF-8.2-gd.libvtkIOGeometry-8.2-gd.libvtkIOImage-8.2-gd.libvtkIOImport-8.2-gd.libvtkIOInfovis-8.2-gd.libvtkIOLegacy-8.2-gd.libvtkIOLSDyna-8.2-gd.libvtkIOMINC-8.2-gd.libvtkIOMovie-8.2-gd.libvtkIONetCDF-8.2-gd.libvtkIOParallel-8.2-gd.libvtkIOParallelXML-8.2-gd.libvtkIOPLY-8.2-gd.libvtkIOSegY-8.2-gd.libvtkIOSQL-8.2-gd.libvtkIOTecplotTable-8.2-gd.libvtkIOVeraOut-8.2-gd.libvtkIOVideo-8.2-gd.libvtkIOXML-8.2-gd.libvtkIOXMLParser-8.2-gd.libvtkjpeg-8.2-gd.libvtkjsoncpp-8.2-gd.libvtklibharu-8.2-gd.libvtklibxml2-8.2-gd.libvtklz4-8.2-gd.libvtklzma-8.2-gd.libvtkmetaio-8.2-gd.libvtkNetCDF-8.2-gd.libvtkogg-8.2-gd.libvtkParallelCore-8.2-gd.libvtkpng-8.2-gd.libvtkproj-8.2-gd.libvtkpugixml-8.2-gd.libvtkRenderingAnnotation-8.2-gd.libvtkRenderingContext2D-8.2-gd.libvtkRenderingContextOpenGL2-8.2-gd.libvtkRenderingCore-8.2-gd.libvtkRenderingExternal-8.2-gd.libvtkRenderingFreeType-8.2-gd.libvtkRenderingGL2PSOpenGL2-8.2-gd.libvtkRenderingImage-8.2-gd.libvtkRenderingLabel-8.2-gd.libvtkRenderingLOD-8.2-gd.libvtkRenderingOpenGL2-8.2-gd.libvtkRenderingVolume-8.2-gd.libvtkRenderingVolumeOpenGL2-8.2-gd.libvtksqlite-8.2-gd.libvtksys-8.2-gd.libvtktheora-8.2-gd.libvtktiff-8.2-gd.libvtkverdict-8.2-gd.libvtkViewsContext2D-8.2-gd.libvtkViewsCore-8.2-gd.libvtkViewsInfovis-8.2-gd.libvtkzlib-8.2-gd.lib 8.程序测试#include &lt;pcl/visualization/cloud_viewer.h&gt; #include &lt;iostream&gt; #include &lt;pcl/io/io.h&gt; #include &lt;pcl/io/pcd_io.h&gt; int user_data; void viewerOneOff(pcl::visualization::PCLVisualizer&amp; viewer) &#123; viewer.setBackgroundColor(1.0, 0.5, 1.0); pcl::PointXYZ o; o.x = 1.0; o.y = 0; o.z = 0; viewer.addSphere(o, 0.25, &quot;sphere&quot;, 0); std::cout &lt;&lt; &quot;i only run once&quot; &lt;&lt; std::endl; &#125; void viewerPsycho(pcl::visualization::PCLVisualizer&amp; viewer) &#123; static unsigned count = 0; std::stringstream ss; ss &lt;&lt; &quot;Once per viewer loop: &quot; &lt;&lt; count++; viewer.removeShape(&quot;text&quot;, 0); viewer.addText(ss.str(), 200, 300, &quot;text&quot;, 0); //FIXME: possible race condition here: user_data++; &#125; int main() &#123; pcl::PointCloud&lt;pcl::PointXYZRGBA&gt;::Ptr cloud(new pcl::PointCloud&lt;pcl::PointXYZRGBA&gt;); pcl::io::loadPCDFile(&quot;D:\\\\Microsoft Visual Studio 10.0\\\\Projects\\\\pcl\\\\pcl\\\\my_point_cloud.pcd&quot;, *cloud); pcl::visualization::CloudViewer viewer(&quot;Cloud Viewer&quot;); //blocks until the cloud is actually rendered viewer.showCloud(cloud); //use the following functions to get access to the underlying more advanced/powerful //PCLVisualizer //This will only get called once viewer.runOnVisualizationThreadOnce(viewerOneOff); //This will get called once per visualization iteration viewer.runOnVisualizationThread(viewerPsycho); while (!viewer.wasStopped()) &#123; //you can also do cool processing here //FIXME: Note that this is running in a separate thread from viewerPsycho //and you should guard against race conditions yourself... user_data++; &#125; return 0; &#125; 测试结果：","categories":[{"name":"PCL","slug":"PCL","permalink":"https://zzygeo.cn/categories/PCL/"}],"tags":[]},{"title":"hexo d 出现错误的用户名和密码的解决办法","slug":"Hexo/hexo-d-出现错误的用户名和密码的解决办法","date":"2020-10-02T05:27:01.000Z","updated":"2021-05-24T00:59:55.647Z","comments":true,"path":"2020/10/02/Hexo/hexo-d-出现错误的用户名和密码的解决办法/","link":"","permalink":"https://zzygeo.cn/2020/10/02/Hexo/hexo-d-%E5%87%BA%E7%8E%B0%E9%94%99%E8%AF%AF%E7%9A%84%E7%94%A8%E6%88%B7%E5%90%8D%E5%92%8C%E5%AF%86%E7%A0%81%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/","excerpt":"在windows搜索栏输入：控制面板","text":"在windows搜索栏输入：控制面板)然后点击： 点进去就可以更改用户名和密码了","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://zzygeo.cn/categories/Hexo/"}],"tags":[]},{"title":"新电脑上部署hexo","slug":"Hexo/新电脑上部署hexo","date":"2020-10-02T05:07:29.000Z","updated":"2021-05-24T01:00:12.425Z","comments":true,"path":"2020/10/02/Hexo/新电脑上部署hexo/","link":"","permalink":"https://zzygeo.cn/2020/10/02/Hexo/%E6%96%B0%E7%94%B5%E8%84%91%E4%B8%8A%E9%83%A8%E7%BD%B2hexo/","excerpt":"1. 安装必要软件安装 Git 客户端安装 node JS","text":"1. 安装必要软件安装 Git 客户端安装 node JS 2. 拷贝源文件将初始电脑上个人博客文件夹下这几个文件夹拷到当前新电脑的准备设置的博客路径下。 _config.yml package.json scaffolds/ source/ themes/ 3. 安装hexo在 cmd 下输入下面指令安装 hexo: npm install -g hexo 4. 在新博客路径下，安装三方依赖库npm install npm install hexo-deployer-git --save //文章部署到 git 的模块 npm install 主题需要的插件 千万别hxeo init，不然你就拉在裤子里了！！！ 5. GITHUB/gitee 添加 SSH KEYS在GitHub/gitee的ssh keys那里再添加一个当前电脑的环境生成的key，但是可别把原来的电脑删掉了啊。首先在本地创建 SSH Keys: ssh-keygen -t rsa -C “xxxx@xxxx.com“ 后面的邮箱即为 github/gitee注册邮箱，也是你登录Github的邮箱（其实无关紧要，只是为了辨识生成的用户名），之后会要求确认路径和输入密码，一路回车就行。成功的话会在git bash页面下看到生成的 .ssh文件夹路径，进去，打开 id_rsa.pub，复制里面的key（全选）即可。然后拷贝到 Github/gitee 的 SSH Keys(这里要添加一个新的)然后在终端中，我们再次测试下公钥有没有添加成功： ssh -T git@gitee.com 会弹出确认命令，输入yes,会弹出你的名字等等，会出现： Hi username! You&#39;ve successfully authenticated, but GitHub does not provide shell access. 然后： hexo g hexo s hexo d","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://zzygeo.cn/categories/Hexo/"}],"tags":[]},{"title":"markdown语法","slug":"Hexo/markdown语法","date":"2020-09-24T06:30:05.000Z","updated":"2021-05-24T01:00:05.904Z","comments":true,"path":"2020/09/24/Hexo/markdown语法/","link":"","permalink":"https://zzygeo.cn/2020/09/24/Hexo/markdown%E8%AF%AD%E6%B3%95/","excerpt":"1.标题","text":"1.标题 # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 注：# 和「标题文字」之间建议保留一个字符的空格，这是最标准的 Markdown 写法。 2. 粗体、斜体、删除线*我是斜体* **我是粗体** ***我是粗斜体*** ~~我是删除线~~ 显示效果：我是斜体我是粗体我是粗斜体我是删除线 3. 表格| 学号 | 姓名 | 分数| | :- | -: | :-: | | 小明 | 男 | 75 | | 小红 | 女 | 79 | | 小陆 | 男 | 92 | 显示效果： 学号 姓名 分数 小明 男 75 小红 女 79 小陆 男 92 4. 有序列表1. 文本1 2. 文本2 3. 文本3 显示效果： 文本1 文本2 文本3 5. 无序列表- 文本1 - 文本2 - 文本3 显示效果： 文本1 文本2 文本3 6. 行内代码块C语言里的函数 `scanf()` 怎么使用？ 显示效果：C语言里的函数 scanf() 怎么使用？ 7. 分割线可以在一行中用三个以上的减号、底线来建立一个分隔线，行内不能有其他内容。 ___ 显示效果： 8. 超链接语法格式为链接文字，[]里写链接文字，()里写链接地址, ()中的”“中可以为链接指定title属性，title属性为可选。title属性的效果是鼠标悬停在链接上会出现指定的title文字。链接地址与链接标题前有一个空格。 欢迎来到多加香菜的博客 显示效果：欢迎来到多加香菜的博客 9. 图片语法格式为，图片Alt的意思是如果图片因为某些原因不能显示，就用定义的图片Alt文字来代替图片。 图片Title则和超链接中的链接标题一样，表示鼠标悬停与图片上时出现的文字。 图片Alt 和 图片Titlee 都是可选的。 10. 引用&gt; 一级引用 &gt;&gt; 二级引用 &gt;&gt;&gt; 三级引用 &gt;&gt;&gt;&gt; 四级引用 显示效果： 一级引用 二级引用 三级引用 四级引用 11. 空格你好&amp;nbsp;&amp;nbsp;&amp;nbsp;jeffery 显示效果你好&nbsp;&nbsp;&nbsp;zzy 12. 字体、字号、颜色&lt;font face=&quot;黑体&quot;&gt;我是黑体字&lt;/font&gt; &lt;font face=&quot;微软雅黑&quot;&gt;我是微软雅黑&lt;/font&gt; &lt;font color=#0099ff size=23 face=&quot;黑体&quot;&gt;我是黑体，颜色#0099ff 字号23&lt;/font&gt; 我是黑体字 我是微软雅黑 我是黑体，颜色#0099ff 字号23&lt;/p&gt;","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://zzygeo.cn/categories/Hexo/"}],"tags":[]}],"categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zzygeo.cn/categories/JavaScript/"},{"name":"C++","slug":"C","permalink":"https://zzygeo.cn/categories/C/"},{"name":"Java基础","slug":"Java基础","permalink":"https://zzygeo.cn/categories/Java%E5%9F%BA%E7%A1%80/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://zzygeo.cn/categories/Ubuntu/"},{"name":"Hexo","slug":"Hexo","permalink":"https://zzygeo.cn/categories/Hexo/"},{"name":"资源","slug":"资源","permalink":"https://zzygeo.cn/categories/%E8%B5%84%E6%BA%90/"},{"name":"PCL","slug":"PCL","permalink":"https://zzygeo.cn/categories/PCL/"}],"tags":[]}